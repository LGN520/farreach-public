#include "model/linear_model_wrapper.h"

namespace ROCKSDB_NAMESPACE {

LinearModelWrapper::LinearModelWrapper(const std::vector<std::string> &index_keys,
		const std::vector<std::vector<std::string>> &data_keys_list,
		uint32_t index_model_n, uint32_t data_model_n) {
	data_block_n_ = data_keys_list.size();
	index_model_n_ = index_model_n;
	data_model_n_ = data_model_n;

	index_models_ = new linear_model_t[index_model_n_]; // index_model_n_
	index_pivots_ = new std::string[index_model_n_];
	data_models_list_ = new linear_model_t*[data_block_n_];
	data_pivots_list_ = new std::string*[data_block_n_];
	for (size_t i = 0; i < data_block_n_; i++) {
		data_models_list_[i] = nullptr;
		data_pivots_list_[i] = nullptr;
	} // data_block_n_ * data_model_n_

	// Train index models
	uint32_t per_index_keys_n = index_keys.size() / index_model_n_;
	uint32_t tail_index_keys_n = per_index_keys_n + index_keys.size() % index_model_n_;
	std::vector<std::string>::const_iterator index_keys_iter = index_keys.begin();
	for (size_t i = 0; i < index_model_n_; i++) {
		index_pivots_[i] = *index_keys_iter;
		if (i != index_model_n_ - 1) {
			index_models_[i].prepare(index_keys_iter, per_index_keys_n);
			index_keys_iter += per_index_keys_n;
		}
		else {
			index_models_[i].prepare(index_keys_iter, tail_index_keys_n);
		}
		//printf("index_models[%u].error_bound = %u, limit: %u\n", uint32_t(i), uint32_t(index_models_[i].error_bound), uint32_t(index_models_[i].limit));
	}
	
	// Train data models
	for (size_t data_block_i = 0; data_block_i < data_block_n_; data_block_i++) {
		const std::vector<std::string> &data_keys = data_keys_list[data_block_i];
		if (data_keys.size() != 0) { // unprepared model will has a weights = nullptr
			data_models_list_[data_block_i] = new linear_model_t[data_model_n_];
			data_pivots_list_[data_block_i] = new std::string[data_model_n_];
			linear_model_t *data_models_ = data_models_list_[data_block_i];
			std::string *data_pivots_ = data_pivots_list_[data_block_i];
			uint32_t per_data_keys_n = data_keys.size() / data_model_n_;
			uint32_t tail_data_keys_n = per_data_keys_n + data_keys.size() % data_model_n_;
			std::vector<std::string>::const_iterator data_keys_iter = data_keys.begin();
			for (size_t i = 0; i < data_model_n_; i++) {
				data_pivots_[i] = *data_keys_iter;
				if (i != data_model_n_ - 1) {
					data_models_[i].prepare(data_keys_iter, per_data_keys_n);
					data_keys_iter = data_keys_iter + per_data_keys_n;
				}
				else {
					data_models_[i].prepare(data_keys_iter, tail_data_keys_n);
				}
				//printf("data_models_list[%u][%u].error_bound = %u, limit: %u\n", uint32_t(data_block_i), uint32_t(i), uint32_t(data_models_[i].error_bound), uint32_t(data_models_[i].limit));
			}
		}
	}

	// Legacy code for single model

	/*std::vector<size_t> index_positions(index_keys.size());
	for (size_t i = 0; i < index_keys.size(); i++) {
		index_positions[i] = i;
	}
	index_model_.prepare(index_keys, index_positions);*/

	/*for (size_t data_block_i = 0; data_block_i < data_keys_list.size(); data_block_i++) {
		std::vector<size_t> data_positions(data_keys_list[data_block_i].size());
		for (size_t i = 0; i < data_keys_list[data_block_i].size(); i++) {
			data_positions[i] = i;
		}
		data_models_[data_block_i].prepare(data_keys_list[data_block_i], data_positions);
	}*/
}

ModelResult LinearModelWrapper::index_predict(const Slice &key) const {
	ModelResult result;
	//uint32_t cur_i = 0;
	//uint32_t prev_i = 0;
	uint32_t index_model_i = 0;
	/*while (index_model_n_ > 1) {
		if (cur_i >= index_model_n_) {
			index_model_i = prev_i;
			break;
		}
		int cmp = key.compare(Slice(index_pivots_[cur_i]));
		if (cmp > 0) {
			prev_i = cur_i;
			cur_i++;
		}
		else if (cmp < 0) {
			index_model_i = prev_i;
			break;
		}
		else {
			index_model_i = cur_i;
			break;
		}
	}*/
	result.predict_idx = index_models_[index_model_i].predict(key);
	result.error_bound = index_models_[index_model_i].error_bound;
	return result;
} 

ModelResult LinearModelWrapper::data_predict(const Slice &key, const uint32_t &data_idx) const {
	if (unlikely(data_idx >= data_block_n_)) {
		printf("[LinearModelWrapper::data_predict] Invalid data idx %u >= # of data block %u\n", data_idx, data_block_n_);
		exit(-1);
	}
	
	if (unlikely(data_models_list_[data_idx] == nullptr)) {
		printf("[LinearModelWrapper::data_predict] Should not invoke data_predict for empty data block!\n");
		exit(-1);
	}

	ModelResult result;
	//std::string *data_pivots_ = data_pivots_list_[data_idx];
	uint32_t data_model_i = 0;

	// Simple search for data_model_n = 2
	/*if (likely(data_model_n_ == 2)) {
		int cmp = key.compare(Slice(data_pivots_[1]));
		if (cmp >= 0) {
			data_model_i = 1;
		}
	}*/

	// Binary search
	/*if (likely(data_model_n_ > 1)) {
		int32_t left = -1, right = int32_t(data_model_n_ - 1);
		while (left != right) {
			int32_t mid = left + (right - left + 1) / 2;
			int cmp = key.compare(Slice(data_pivots_[mid]));
			if (cmp < 0) {
				right = mid - 1;
			}
			else if (cmp > 0) {
				left = mid;
			}
			else {
				left = right = mid;
				break;
			}
		}

		if (left != -1) {
			data_model_i = left;
		}
		else {
			data_model_i = 0;
		}
	}*/

	// Linear search
	/*uint32_t cur_i = 0;
	uint32_t prev_i = 0;
	while (data_model_n_ > 1) {
		if (cur_i >= data_model_n_) {
			data_model_i = prev_i;
			break;
		}
		int cmp = key.compare(Slice(data_pivots_[cur_i]));
		if (cmp > 0) {
			prev_i = cur_i;
			cur_i++;
		}
		else if (cmp < 0) {
			data_model_i = prev_i;
			break;
		}
		else {
			data_model_i = cur_i;
			break;
		}
	}*/

	result.predict_idx = data_models_list_[data_idx][data_model_i].predict(key);
	result.error_bound = data_models_list_[data_idx][data_model_i].error_bound;
	return result;
}


LinearModelWrapper::~LinearModelWrapper() {
	delete index_models_;
	delete index_pivots_;
	for (uint32_t i = 0; i < data_block_n_; i++) {
		if (data_models_list_[i] != nullptr) delete data_models_list_[i];
		if (data_pivots_list_[i] != nullptr) delete data_pivots_list_[i];
	}
	delete data_models_list_;
	delete data_pivots_list_;
}

/*uint32_t LinearModelWrapper::index_predict(const Slice &key) const {
	size_t result = index_model_.predict(key);
	return uint32_t(result);
}

uint32_t LinearModelWrapper::index_error_bound() const {
	size_t result = index_model_.error_bound;
	return uint32_t(result);
}

uint32_t LinearModelWrapper::data_predict(const Slice &key, const uint32_t &data_idx) const {
	size_t result = data_models_[data_idx].predict(key);
	return uint32_t(result);
}

uint32_t LinearModelWrapper::data_error_bound(const uint32_t &data_idx) const {
	size_t result = data_models_[data_idx].error_bound;
	return uint32_t(result);
}

LinearModelWrapper::~LinearModelWrapper() {
	delete data_models_;
}*/

}
