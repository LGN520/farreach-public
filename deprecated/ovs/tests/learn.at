AT_BANNER([learning action])

AT_SETUP([learning action - parsing and formatting])
AT_DATA([flows.txt], [[
actions=learn()
actions=learn(send_flow_rem)
actions=learn(delete_learned)
actions=learn(send_flow_rem,delete_learned)
actions=learn(NXM_OF_VLAN_TCI[0..11], NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[], output:NXM_OF_IN_PORT[], load:10->NXM_NX_REG0[5..10])
actions=learn(table=1,idle_timeout=10, hard_timeout=20, fin_idle_timeout=5, fin_hard_timeout=10, priority=10, cookie=0xfedcba9876543210, in_port=99,eth_dst=eth_src,load:in_port->reg1[16..31])
actions=learn(limit=4096)
actions=learn(limit=4096,result_dst=reg0[0])
]])
AT_CHECK([ovs-ofctl parse-flows flows.txt], [0],
[[usable protocols: any
chosen protocol: OpenFlow10-table_id
OFPT_FLOW_MOD (xid=0x1): ADD actions=learn(table=1)
OFPT_FLOW_MOD (xid=0x2): ADD actions=learn(table=1,send_flow_rem)
OFPT_FLOW_MOD (xid=0x3): ADD actions=learn(table=1,delete_learned)
OFPT_FLOW_MOD (xid=0x4): ADD actions=learn(table=1,send_flow_rem,delete_learned)
OFPT_FLOW_MOD (xid=0x5): ADD actions=learn(table=1,NXM_OF_VLAN_TCI[0..11],NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],output:NXM_OF_IN_PORT[],load:0xa->NXM_NX_REG0[5..10])
OFPT_FLOW_MOD (xid=0x6): ADD actions=learn(table=1,idle_timeout=10,hard_timeout=20,fin_idle_timeout=5,fin_hard_timeout=10,priority=10,cookie=0xfedcba9876543210,in_port=99,NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],load:NXM_OF_IN_PORT[]->NXM_NX_REG1[16..31])
OFPT_FLOW_MOD (xid=0x7): ADD actions=learn(table=1,limit=4096)
OFPT_FLOW_MOD (xid=0x8): ADD actions=learn(table=1,limit=4096,result_dst=NXM_NX_REG0[0])
]])
AT_CLEANUP

AT_SETUP([learning action - parsing and formatting - illegal in_port_oxm])
AT_CHECK([[ovs-ofctl parse-flow 'actions=learn(table=1, in_port_oxm=123456)']],
  [1], [], [stderr])
AT_CHECK([sed -e 's/.*|ofp_port|WARN|//' < stderr], [0],
  [[port 123456 is outside the supported range 0 through ffff or 0xffffff00 through 0xffffffff
ovs-ofctl: table=1, in_port_oxm=123456: in_port_oxm value 123456 cannot be parsed as a subfield (123456: unknown field `123456') or an immediate value (123456: port value out of range for in_port_oxm)
]], [[]])
AT_CLEANUP

AT_SETUP([learning action - parsing and formatting - OXM])
AT_DATA([flows.txt], [[
actions=learn(output:OXM_OF_IN_PORT[])
actions=learn(table=1, in_port=1, load:OXM_OF_IN_PORT[]->NXM_NX_REG1[], load:0xfffffffe->OXM_OF_IN_PORT[])
]])
AT_CHECK([ovs-ofctl -O OpenFlow12 parse-flows flows.txt], [0],
[[usable protocols: any
chosen protocol: OXM-OpenFlow12
OFPT_FLOW_MOD (OF1.2) (xid=0x1): ADD actions=learn(table=1,output:OXM_OF_IN_PORT[])
OFPT_FLOW_MOD (OF1.2) (xid=0x2): ADD actions=learn(table=1,in_port=1,load:OXM_OF_IN_PORT[]->NXM_NX_REG1[],load:0xfffffffe->OXM_OF_IN_PORT[])
]])
AT_CLEANUP

AT_SETUP([learning action - examples])
AT_DATA([flows.txt], [[
# These are the examples from ofp-actions.c.
actions=learn(in_port=99,NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[], load:NXM_OF_IN_PORT[]->NXM_NX_REG1[16..31])
actions=learn(NXM_OF_VLAN_TCI[0..11], NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],output:NXM_OF_IN_PORT[])
table=0 actions=learn(table=1,hard_timeout=10, NXM_OF_VLAN_TCI[0..11],output:NXM_OF_IN_PORT[]), resubmit(,1)
table=1 priority=0 actions=flood
]])
AT_CHECK([ovs-ofctl parse-flows flows.txt], [0],
[[usable protocols: OXM,OpenFlow10+table_id,NXM+table_id,OpenFlow11
chosen protocol: OpenFlow10+table_id
OFPT_FLOW_MOD (xid=0x1): ADD table:255 actions=learn(table=1,in_port=99,NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],load:NXM_OF_IN_PORT[]->NXM_NX_REG1[16..31])
OFPT_FLOW_MOD (xid=0x2): ADD table:255 actions=learn(table=1,NXM_OF_VLAN_TCI[0..11],NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[],output:NXM_OF_IN_PORT[])
OFPT_FLOW_MOD (xid=0x3): ADD actions=learn(table=1,hard_timeout=10,NXM_OF_VLAN_TCI[0..11],output:NXM_OF_IN_PORT[]),resubmit(,1)
OFPT_FLOW_MOD (xid=0x4): ADD table:1 priority=0 actions=FLOOD
]])
AT_CLEANUP

AT_SETUP([learning action - satisfied prerequisites])
AT_DATA([flows.txt],
[[actions=learn(eth_type=0x800,load:5->NXM_OF_IP_DST[])
ip,actions=learn(load:NXM_OF_IP_DST[]->NXM_NX_REG1[])
ip,actions=learn(eth_type=0x800,OXM_OF_IPV4_DST[])
]])
AT_CHECK([ovs-ofctl parse-flows flows.txt], [0],
[[usable protocols: any
chosen protocol: OpenFlow10-table_id
OFPT_FLOW_MOD (xid=0x1): ADD actions=learn(table=1,eth_type=0x800,load:0x5->NXM_OF_IP_DST[])
OFPT_FLOW_MOD (xid=0x2): ADD ip actions=learn(table=1,load:NXM_OF_IP_DST[]->NXM_NX_REG1[])
OFPT_FLOW_MOD (xid=0x3): ADD ip actions=learn(table=1,eth_type=0x800,NXM_OF_IP_DST[])
]])
AT_CLEANUP

AT_SETUP([learning action - invalid prerequisites])
AT_CHECK([[ovs-ofctl parse-flow 'actions=learn(load:5->NXM_OF_IP_DST[])']],
  [1], [], [stderr])
AT_CHECK([sed -e 's/.*|meta_flow|WARN|//' < stderr], [0],
  [[destination field ip_dst lacks correct prerequisites
ovs-ofctl: actions are invalid with specified match (OFPBAC_MATCH_INCONSISTENT)
]], [[]])
AT_CHECK([[ovs-ofctl parse-flow 'actions=learn(load:NXM_OF_IP_DST[]->NXM_NX_REG1[])']],
  [1], [], [stderr])
AT_CHECK([sed -e 's/.*|meta_flow|WARN|//' < stderr], [0],
  [[source field ip_dst lacks correct prerequisites
ovs-ofctl: actions are invalid with specified match (OFPBAC_MATCH_INCONSISTENT)
]])
AT_CLEANUP

AT_SETUP([learning action - too-long immediate value])
dnl 129 bits is too long.
AT_CHECK([[ovs-ofctl parse-flow 'actions=learn(load:0x1fedbca9876543210fedbca9876543210->NXM_NX_IPV6_DST[])']],
  [1], [], [[ovs-ofctl: 0x1fedbca9876543210fedbca9876543210->NXM_NX_IPV6_DST[]: value does not fit into 128 bits
]])

dnl 128 bits is merely a bad prerequisite.
AT_CHECK([[ovs-ofctl parse-flow 'actions=learn(load:0xfedbca9876543210fedbca9876543210->NXM_NX_IPV6_DST[])']], [1], [], [stderr])
AT_CHECK([sed -e 's/.*|meta_flow|WARN|//' < stderr], [0],
  [[destination field ipv6_dst lacks correct prerequisites
ovs-ofctl: actions are invalid with specified match (OFPBAC_MATCH_INCONSISTENT)
]], [[]])
AT_CLEANUP

AT_SETUP([learning action - standard VLAN+MAC learning])
OVS_VSWITCHD_START(
  [add-port br0 p1 -- set Interface p1 type=dummy ofport_request=1 -- \
   add-port br0 p2 -- set Interface p2 type=dummy ofport_request=2 -- \
   add-port br0 p3 -- set Interface p3 type=dummy ofport_request=3])
# Set up flow table for VLAN+MAC learning.
AT_DATA([flows.txt], [[
table=0 actions=learn(table=1, hard_timeout=60, NXM_OF_VLAN_TCI[0..11], NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[], output:NXM_OF_IN_PORT[]), resubmit(,1)
table=1 priority=0 actions=flood
]])
AT_CHECK([ovs-ofctl add-flows br0 flows.txt])

# Trace an ARP packet arriving on port 3, to create a MAC learning entry.
flow="in_port(3),eth(src=50:54:00:00:00:05,dst=ff:ff:ff:ff:ff:ff),eth_type(0x0806),arp(sip=192.168.0.1,tip=192.168.0.2,op=1,sha=50:54:00:00:00:05,tha=00:00:00:00:00:00)"
AT_CHECK([ovs-appctl ofproto/trace ovs-dummy "$flow" -generate], [0], [stdout])
actual=`tail -1 stdout | sed 's/Datapath actions: //'`

expected="1,2,100"
AT_CHECK([ovs-dpctl normalize-actions "$flow" "$expected"], [0], [stdout])
mv stdout expout
AT_CHECK([ovs-dpctl normalize-actions "$flow" "$actual"], [0], [expout])

# Check for the MAC learning entry.
AT_CHECK([ovs-ofctl dump-flows br0 table=1 --no-stats --sort], [0], [dnl
 table=1, priority=0 actions=FLOOD
 table=1, hard_timeout=60, vlan_tci=0x0000/0x0fff,dl_dst=50:54:00:00:00:05 actions=output:3
])

# Trace a packet arrival destined for the learned MAC.
# (This will also learn a MAC.)
AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'in_port(1),eth(src=50:54:00:00:00:06,dst=50:54:00:00:00:05),eth_type(0x0806),arp(sip=192.168.0.2,tip=192.168.0.1,op=2,sha=50:54:00:00:00:06,tha=50:54:00:00:00:05)' -generate], [0], [stdout])
AT_CHECK([tail -1 stdout], [0], [Datapath actions: 3
])

# Check for both MAC learning entries.
AT_CHECK([ovs-ofctl dump-flows br0 table=1 --no-stats | sort], [0], [dnl
 table=1, hard_timeout=60, vlan_tci=0x0000/0x0fff,dl_dst=50:54:00:00:00:05 actions=output:3
 table=1, hard_timeout=60, vlan_tci=0x0000/0x0fff,dl_dst=50:54:00:00:00:06 actions=output:1
 table=1, priority=0 actions=FLOOD
])

# Trace a packet arrival that updates the first learned MAC entry.
flow="in_port(2),eth(src=50:54:00:00:00:05,dst=ff:ff:ff:ff:ff:ff),eth_type(0x0806),arp(sip=192.168.0.1,tip=192.168.0.2,op=1,sha=50:54:00:00:00:05,tha=00:00:00:00:00:00)"
AT_CHECK([ovs-appctl ofproto/trace ovs-dummy "$flow" -generate], [0], [stdout])
actual=`tail -1 stdout | sed 's/Datapath actions: //'`

expected="1,3,100"
AT_CHECK([ovs-dpctl normalize-actions "$flow" "$expected"], [0], [stdout])
mv stdout expout
AT_CHECK([ovs-dpctl normalize-actions "$flow" "$actual"], [0], [expout])

# Check that the MAC learning entry was updated.
AT_CHECK([ovs-ofctl dump-flows br0 table=1 --no-stats | sort], [0], [dnl
 table=1, hard_timeout=60, vlan_tci=0x0000/0x0fff,dl_dst=50:54:00:00:00:05 actions=output:2
 table=1, hard_timeout=60, vlan_tci=0x0000/0x0fff,dl_dst=50:54:00:00:00:06 actions=output:1
 table=1, priority=0 actions=FLOOD
])
OVS_VSWITCHD_STOP
AT_CLEANUP

dnl This test checks that repeated uses of a "learn" action cause the
dnl modified time of the learned flow to advance.  Otherwise, the
dnl learned flow will expire after its hard timeout even though it's
dnl supposed to be refreshed.  (The expiration can be hard to see since
dnl it gets re-learned again the next time a packet appears, but
dnl sometimes the expiration can cause temporary flooding etc.)
AT_SETUP([learning action - learn refreshes hard_age])
OVS_VSWITCHD_START(
  [add-port br0 p1 -- set Interface p1 type=dummy ofport_request=1 -- \
   add-port br0 p2 -- set Interface p2 type=dummy ofport_request=2 -- \
   add-port br0 p3 -- set Interface p3 type=dummy ofport_request=3])

ovs-appctl time/stop

# Set up flow table for MAC learning.
AT_DATA([flows.txt], [[
table=0 actions=learn(table=1, hard_timeout=10, NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[], output:NXM_OF_IN_PORT[]), resubmit(,1)
table=1 priority=0 actions=flood
]])
AT_CHECK([ovs-ofctl add-flows br0 flows.txt])

# Trace an ICMP packet arriving on port 3, to create a MAC learning entry.
flow="in_port(3),eth(src=50:54:00:00:00:07,dst=50:54:00:00:00:05),eth_type(0x0800),ipv4(src=192.168.0.2,dst=192.168.0.1,proto=1,tos=0,ttl=64,frag=no),icmp(type=0,code=0)"
AT_CHECK([ovs-appctl ofproto/trace ovs-dummy "$flow" -generate], [0], [stdout])
actual=`tail -1 stdout | sed 's/Datapath actions: //'`

expected="1,2,100"
AT_CHECK([ovs-dpctl normalize-actions "$flow" "$expected"], [0], [stdout])
mv stdout expout
AT_CHECK([ovs-dpctl normalize-actions "$flow" "$actual"], [0], [expout])

# Check that the MAC learning entry appeared.
AT_CHECK([ovs-ofctl dump-flows br0 table=1 --no-stats | sort], [0], [dnl
 table=1, hard_timeout=10, dl_dst=50:54:00:00:00:07 actions=output:3
 table=1, priority=0 actions=FLOOD
])

# For 25 seconds, make sure that the MAC learning entry doesn't
# disappear as long as we refresh it every second.
for i in 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25; do
    ovs-appctl time/warp 1000
    AT_CHECK([ovs-appctl ofproto/trace ovs-dummy "$flow" -generate], [0], [stdout])

    # Check that the entry is there.
    AT_CHECK([ovs-ofctl dump-flows br0 table=1], [0], [stdout])
    AT_CHECK([ofctl_strip < stdout | sort], [0], [dnl
 table=1, hard_timeout=10, dl_dst=50:54:00:00:00:07 actions=output:3
 table=1, priority=0 actions=FLOOD
NXST_FLOW reply:
])

    if test $i != 1; then
        # Check that hard_age has appeared.  We need to do this separately
        # from the above check because ofctl_strip removes it.  dump-flows
        # only prints hard_age when it is different from the flow's duration
        # (that is, the number of seconds from the time it was created),
        # so we only check for it after we've refreshed the flow once.
        AT_CHECK([grep dl_dst=50:54:00:00:00:07 stdout | grep -c hard_age],
                 [0], [1
])
    fi
done

# Make sure that 15 seconds without refreshing makes the flow time out.
ovs-appctl time/warp 15000 5000
sleep 1
AT_CHECK([ovs-ofctl dump-flows br0 table=1 --no-stats | sort], [0], [dnl
 table=1, priority=0 actions=FLOOD
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([learning action - TCPv4 port learning])
OVS_VSWITCHD_START(
  [add-port br0 p1 -- set Interface p1 type=dummy -- \
   add-port br0 p2 -- set Interface p2 type=dummy -- \
   add-port br0 p3 -- set Interface p3 type=dummy])
# Set up flow table for TCPv4 port learning.
AT_CHECK([[ovs-ofctl add-flow br0 'table=0 tcp actions=learn(table=1, hard_timeout=60, eth_type=0x800, nw_proto=6, NXM_OF_IP_SRC[]=NXM_OF_IP_DST[], NXM_OF_IP_DST[]=NXM_OF_IP_SRC[], NXM_OF_TCP_SRC[]=NXM_OF_TCP_DST[], NXM_OF_TCP_DST[]=NXM_OF_TCP_SRC[]), flood']])

# Trace a TCPv4 packet arriving on port 3.
flow="in_port(3),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:06),eth_type(0x0800),ipv4(src=192.168.0.2,dst=192.168.0.1,proto=6,tos=0,ttl=64,frag=no),tcp(src=40000,dst=80)"
AT_CHECK([ovs-appctl ofproto/trace ovs-dummy "$flow" -generate], [0], [stdout])
actual=`tail -1 stdout | sed 's/Datapath actions: //'`

expected="1,2,100"
AT_CHECK([ovs-dpctl normalize-actions "$flow" "$expected"], [0], [stdout])
mv stdout expout
AT_CHECK([ovs-dpctl normalize-actions "$flow" "$actual"], [0], [expout])

# Check for the learning entry.
AT_CHECK([ovs-ofctl dump-flows br0 table=1 --no-stats | sort], [0], [dnl
 table=1, hard_timeout=60, tcp,nw_src=192.168.0.1,nw_dst=192.168.0.2,tp_src=80,tp_dst=40000 actions=drop
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([learning action - TCPv6 port learning])
OVS_VSWITCHD_START(
  [add-port br0 p1 -- set Interface p1 type=dummy -- \
   add-port br0 p2 -- set Interface p2 type=dummy -- \
   add-port br0 p3 -- set Interface p3 type=dummy])
# Set up flow table for TCPv6 port learning.
# Also add a 128-bit-wide "load" action and a 128-bit literal match to check
# that they work.
AT_CHECK([[ovs-ofctl add-flow br0 'table=0 tcp6 actions=learn(table=1, hard_timeout=60, eth_type=0x86dd, nw_proto=6, NXM_NX_IPV6_SRC[]=NXM_NX_IPV6_DST[], ipv6_dst=2001:0db8:85a3:0000:0000:8a2e:0370:7334, NXM_OF_TCP_SRC[]=NXM_OF_TCP_DST[], NXM_OF_TCP_DST[]=NXM_OF_TCP_SRC[], load(0x20010db885a308d313198a2e03707348->NXM_NX_IPV6_DST[])), flood']])

# Trace a TCPv6 packet arriving on port 3.
flow="in_port(3),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:06),eth_type(0x86dd),ipv6(src=fec0::2,dst=fec0::1,label=0,proto=6,tclass=0,hlimit=255,frag=no),tcp(src=40000,dst=80)"
AT_CHECK([ovs-appctl ofproto/trace ovs-dummy "$flow" -generate], [0], [stdout])
actual=`tail -1 stdout | sed 's/Datapath actions: //'`

expected="1,2,100"
AT_CHECK([ovs-dpctl normalize-actions "$flow" "$expected"], [0], [stdout])
mv stdout expout
AT_CHECK([ovs-dpctl normalize-actions "$flow" "$actual"], [0], [expout])

# Check for the learning entry.
AT_CHECK([ovs-ofctl dump-flows br0 --no-stats | sort], [0], [dnl
 table=1, hard_timeout=60, tcp6,ipv6_src=fec0::1,ipv6_dst=2001:db8:85a3::8a2e:370:7334,tp_src=80,tp_dst=40000 actions=load:0x13198a2e03707348->NXM_NX_IPV6_DST[[0..63]],load:0x20010db885a308d3->NXM_NX_IPV6_DST[[64..127]]
 tcp6 actions=learn(table=1,hard_timeout=60,eth_type=0x86dd,nw_proto=6,NXM_NX_IPV6_SRC[[]]=NXM_NX_IPV6_DST[[]],ipv6_dst=2001:db8:85a3::8a2e:370:7334,NXM_OF_TCP_SRC[[]]=NXM_OF_TCP_DST[[]],NXM_OF_TCP_DST[[]]=NXM_OF_TCP_SRC[[]],load:0x20010db885a308d313198a2e03707348->NXM_NX_IPV6_DST[[]]),FLOOD
])
OVS_VSWITCHD_STOP
AT_CLEANUP

# In this use of a learn action, the first packet in the flow creates
# a new flow that changes the behavior of subsequent packets in the
# flow.
AT_SETUP([learning action - self-modifying flow])
OVS_VSWITCHD_START
add_of_ports br0 1 2 3

ovs-appctl time/stop
# Set up flow table for TCPv4 port learning.
AT_CHECK([[ovs-ofctl add-flow br0 'actions=load:3->NXM_NX_REG0[0..15],learn(table=0,priority=65535,NXM_OF_ETH_SRC[],NXM_OF_VLAN_TCI[0..11],output:NXM_NX_REG0[0..15]),output:2']])

# Trace some packets arriving.  The particular packets don't matter.
for i in 1 2 3 4 5 6 7 8 9 10; do
    ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=0,ttl=64,frag=no),tcp(src=8,dst=9)'
    ovs-appctl time/warp 10
    if [[ $i -eq 1 ]]; then
        sleep 1
    fi
done

# Check for the learning entry.
ovs-appctl time/warp 1000
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0],
[[ n_packets=1, n_bytes=118, actions=load:0x3->NXM_NX_REG0[0..15],learn(table=0,priority=65535,NXM_OF_ETH_SRC[],NXM_OF_VLAN_TCI[0..11],output:NXM_NX_REG0[0..15]),output:2
 n_packets=9, n_bytes=1062, priority=65535,vlan_tci=0x0000/0x0fff,dl_src=50:54:00:00:00:05 actions=output:3
NXST_FLOW reply:
]])

# Check that the first packet went out port 2 and the rest out port 3.
AT_CHECK(
  [(ovs-ofctl dump-ports br0 2; ovs-ofctl dump-ports br0 3) | strip_xids], [0],
  [OFPST_PORT reply: 1 ports
  port  2: rx pkts=0, bytes=0, drop=?, errs=?, frame=?, over=?, crc=?
           tx pkts=1, bytes=118, drop=?, errs=?, coll=?
OFPST_PORT reply: 1 ports
  port  3: rx pkts=0, bytes=0, drop=?, errs=?, frame=?, over=?, crc=?
           tx pkts=9, bytes=1062, drop=?, errs=?, coll=?
])

OVS_VSWITCHD_STOP
AT_CLEANUP

# This test is much like the previous, but adds idle timeouts and sends
# two different flows to the bridge. This tests that the statistics are
# attributed correctly.
AT_SETUP([learning action - self-modifying flow with idle_timeout])
OVS_VSWITCHD_START
add_of_ports br0 1 2 3

ovs-appctl time/stop
# Set up flow table for TCPv4 port learning.
AT_CHECK([[ovs-ofctl add-flow br0 'actions=load:3->NXM_NX_REG0[0..15],learn(table=0,idle_timeout=5,priority=65535,NXM_OF_ETH_SRC[],NXM_OF_VLAN_TCI[0..11],output:NXM_NX_REG0[0..15]),output:2']])

# Trace some packets arriving.  The particular packets don't matter.
for i in `seq 1 10`; do
    ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=0,ttl=64,frag=no),tcp(src=8,dst=9)'
    ovs-appctl time/warp 10
    if [[ $i -eq 1 ]]; then
        sleep 1
    fi
done

# Trace some packets arriving.  This is is a different flow from the previous.
# Note that we advance time by 1 second between each packet here.
for i in `seq 1 10`; do
    ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:06,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=0,ttl=64,frag=no),tcp(src=8,dst=9)'
    ovs-appctl time/warp 1000
    # Note: netdev-dummy/receive merely queues the packet.
    # We need to wait for other thread to process the packet
    # and update the flow's 'used' for the packet.
    # (i % 3 == 0) below is somehow arbitrary but chosen to ensure
    # that we update the flow's 'used' frequently enough to prevent
    # idle_timeout.
    if [[ $i -eq 1 -o $((i % 3)) -eq 0 ]]; then
        sleep 1
    fi
done

# Check that the first packet of each flow went out port 2 and the rest out
# port 3.
AT_CHECK(
  [(ovs-ofctl dump-ports br0 2; ovs-ofctl dump-ports br0 3) | strip_xids], [0],
  [OFPST_PORT reply: 1 ports
  port  2: rx pkts=0, bytes=0, drop=?, errs=?, frame=?, over=?, crc=?
           tx pkts=2, bytes=236, drop=?, errs=?, coll=?
OFPST_PORT reply: 1 ports
  port  3: rx pkts=0, bytes=0, drop=?, errs=?, frame=?, over=?, crc=?
           tx pkts=18, bytes=2124, drop=?, errs=?, coll=?
])

# Check for the learning entry.
ovs-appctl time/warp 1000
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0],
[[ n_packets=2, n_bytes=236, actions=load:0x3->NXM_NX_REG0[0..15],learn(table=0,idle_timeout=5,priority=65535,NXM_OF_ETH_SRC[],NXM_OF_VLAN_TCI[0..11],output:NXM_NX_REG0[0..15]),output:2
 n_packets=9, n_bytes=1062, idle_timeout=5, priority=65535,vlan_tci=0x0000/0x0fff,dl_src=50:54:00:00:00:06 actions=output:3
NXST_FLOW reply:
]])
OVS_VSWITCHD_STOP
AT_CLEANUP

# This test is much like the previous, but adds hard timeouts and sends
# two different flows to the bridge. This tests that the statistics are
# attributed correctly.
AT_SETUP([learning action - self-modifying flow with hard_timeout])
OVS_VSWITCHD_START
add_of_ports br0 1 2 3

ovs-appctl time/stop
# Set up flow table for TCPv4 port learning.
AT_CHECK([[ovs-ofctl add-flow br0 'actions=load:3->NXM_NX_REG0[0..15],learn(table=0,hard_timeout=10,priority=65535,NXM_OF_ETH_SRC[],NXM_OF_VLAN_TCI[0..11],output:NXM_NX_REG0[0..15]),output:2']])

# Trace some packets arriving.  The particular packets don't matter.
for i in `seq 1 10`; do
    ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:05,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=0,ttl=64,frag=no),tcp(src=8,dst=9)'
    if [[ $i -eq 1 ]]; then
        sleep 1
    fi
    ovs-appctl time/warp 10
done

# Check that the first packet of each flow went out port 2 and the rest out
# port 3.
AT_CHECK(
  [(ovs-ofctl dump-ports br0 2; ovs-ofctl dump-ports br0 3) | strip_xids], [0],
  [OFPST_PORT reply: 1 ports
  port  2: rx pkts=0, bytes=0, drop=?, errs=?, frame=?, over=?, crc=?
           tx pkts=1, bytes=118, drop=?, errs=?, coll=?
OFPST_PORT reply: 1 ports
  port  3: rx pkts=0, bytes=0, drop=?, errs=?, frame=?, over=?, crc=?
           tx pkts=9, bytes=1062, drop=?, errs=?, coll=?
])

# Trace some packets arriving.  This is is a different flow from the previous.
# Note that we advance time by 2 second between each packet here.
for i in `seq 1 10`; do
    ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:06,dst=50:54:00:00:00:07),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=6,tos=0,ttl=64,frag=no),tcp(src=8,dst=9)'
    # Note: hard_timeout should fire immediately after #6 packet.
    # #7 packet re-install the flow and the following 3 packets
    # (#8, #9, #10) use the flow.
    # it's difficult to predict the exact timing of rule expiry
    # because it's affected by flow dumper thread via udpif_dump_seq.
    # hard_timeout value for this test was chosen to overcome the uncertainty.
    #
    # receive #1  learn, install flow with hard_timeout=10
    #  sleep to ensure the flow installation
    #  (warp, timeout left 8s)
    # receive #2   the learned flow
    #  (warp, timeout left 6s)
    # receive #3
    #  (warp, timeout left 4s)
    # receive #4
    #  (warp, timeout left 2s)
    # receive #5
    #  (warp, timeout left 0s)
    #  NOTE: OVS does not consider this expired yet.  cf. rule_expire()
    # receive #6
    #  (warp, timeout left -2s)
    #  sleep to ensure flow expiration
    # receive #7  learn, install flow with hard_timeout=10
    #  sleep to ensure the flow installation
    #  (warp, timeout left 8s)
    # receive #8
    #  (warp, timeout left 6s)
    # receive #9
    #  (warp, timeout left 4s)
    # receive #10
    #  (warp, timeout left 2s)
    if [[ $i -eq 1 -o $i -eq 7 ]]; then
        sleep 1
    fi
    ovs-appctl time/warp 2000
    if [[ $i -eq 6 ]]; then
        sleep 1
    fi
done

# Check that the first packet of each flow went out port 2 and the rest out
# port 3.
AT_CHECK(
  [(ovs-ofctl dump-ports br0 2; ovs-ofctl dump-ports br0 3) | strip_xids], [0],
  [OFPST_PORT reply: 1 ports
  port  2: rx pkts=0, bytes=0, drop=?, errs=?, frame=?, over=?, crc=?
           tx pkts=3, bytes=354, drop=?, errs=?, coll=?
OFPST_PORT reply: 1 ports
  port  3: rx pkts=0, bytes=0, drop=?, errs=?, frame=?, over=?, crc=?
           tx pkts=17, bytes=2006, drop=?, errs=?, coll=?
])

# Check for the learning entry.
ovs-appctl time/warp 1000
sleep 1
AT_CHECK([ovs-ofctl dump-flows br0 | ofctl_strip | sort], [0],
[[ n_packets=3, n_bytes=354, actions=load:0x3->NXM_NX_REG0[0..15],learn(table=0,hard_timeout=10,priority=65535,NXM_OF_ETH_SRC[],NXM_OF_VLAN_TCI[0..11],output:NXM_NX_REG0[0..15]),output:2
 n_packets=3, n_bytes=354, hard_timeout=10, priority=65535,vlan_tci=0x0000/0x0fff,dl_src=50:54:00:00:00:06 actions=output:3
NXST_FLOW reply:
]])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([learning action - fin_timeout feature])
# This is a totally artificial use of the "learn" action.  The only purpose
# is to check that specifying fin_idle_timeout or fin_hard_timeout causes
# a corresponding fin_timeout action to end up in the learned flows.
OVS_VSWITCHD_START(
    [add-port br0 p1 -- set Interface p1 type=dummy ofport_request=1])
AT_CHECK([[ovs-ofctl add-flow br0 'actions=learn(fin_hard_timeout=10, fin_idle_timeout=5, NXM_OF_ETH_DST[]=NXM_OF_ETH_SRC[], output:NXM_OF_IN_PORT[])']])
AT_CHECK([ovs-appctl ofproto/trace ovs-dummy 'in_port(1),eth(src=50:54:00:00:00:05,dst=ff:ff:ff:ff:ff:ff),eth_type(0x0806),arp(sip=192.168.0.1,tip=192.168.0.2,op=1,sha=50:54:00:00:00:05,tha=00:00:00:00:00:00)' -generate], [0], [ignore])
AT_CHECK([ovs-ofctl dump-flows br0 table=1 --no-stats], [0],
[ table=1, dl_dst=50:54:00:00:00:05 actions=fin_timeout(idle_timeout=5,hard_timeout=10),output:1
])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([learning action - delete_learned feature])
OVS_VSWITCHD_START

# Add some initial flows and check that it was successful.
AT_DATA([flows.txt], [dnl
                       reg0=0x1 actions=learn(delete_learned,cookie=0x123)
                       reg0=0x2 actions=learn(delete_learned,cookie=0x123)
cookie=0x123, table=1, reg0=0x3 actions=drop
cookie=0x123, table=1, reg0=0x4 actions=drop
cookie=0x123, table=2, reg0=0x5 actions=drop
cookie=0x234, table=1, reg0=0x6 actions=drop
])
AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
AT_CHECK([ovs-ofctl dump-flows br0 --no-stats | sort], [0], [dnl
 cookie=0x123, table=1, reg0=0x3 actions=drop
 cookie=0x123, table=1, reg0=0x4 actions=drop
 cookie=0x123, table=2, reg0=0x5 actions=drop
 cookie=0x234, table=1, reg0=0x6 actions=drop
 reg0=0x1 actions=learn(table=1,delete_learned,cookie=0x123)
 reg0=0x2 actions=learn(table=1,delete_learned,cookie=0x123)
])

# Delete one of the learn actions.  The learned flows should stay, since there
# is another learn action with the identical target.
AT_CHECK([ovs-ofctl del-flows br0 'table=0 reg0=1'])
AT_CHECK([ovs-ofctl dump-flows br0 --no-stats | sort], [0], [dnl
 cookie=0x123, table=1, reg0=0x3 actions=drop
 cookie=0x123, table=1, reg0=0x4 actions=drop
 cookie=0x123, table=2, reg0=0x5 actions=drop
 cookie=0x234, table=1, reg0=0x6 actions=drop
 reg0=0x2 actions=learn(table=1,delete_learned,cookie=0x123)
])

# Change the flow with the learn action by adding a second action.  The learned
# flows should stay because the learn action is still there.
AT_CHECK([ovs-ofctl mod-flows br0 'table=0 reg0=2 actions=output:1,learn(delete_learned,cookie=0x123)'])
AT_CHECK([ovs-ofctl dump-flows br0 --no-stats | sort], [0], [dnl
 cookie=0x123, table=1, reg0=0x3 actions=drop
 cookie=0x123, table=1, reg0=0x4 actions=drop
 cookie=0x123, table=2, reg0=0x5 actions=drop
 cookie=0x234, table=1, reg0=0x6 actions=drop
 reg0=0x2 actions=output:1,learn(table=1,delete_learned,cookie=0x123)
])

# Change the flow with the learn action by replacing its learn action by one
# with a different target.  The (previous) learned flows disappear.
AT_CHECK([ovs-ofctl mod-flows br0 'table=0 reg0=2 actions=learn(delete_learned,cookie=0x234)'])
AT_CHECK([ovs-ofctl dump-flows br0 --no-stats | sort], [0], [dnl
 cookie=0x123, table=2, reg0=0x5 actions=drop
 cookie=0x234, table=1, reg0=0x6 actions=drop
 reg0=0x2 actions=learn(table=1,delete_learned,cookie=0x234)
])

# Use add-flow to replace the flow with the learn action by one with the
# same learn action and an extra action.  The (new) learned flow remains.
AT_CHECK([ovs-ofctl add-flow br0 'table=0 reg0=2 actions=learn(delete_learned,cookie=0x234),output:2'])
AT_CHECK([ovs-ofctl dump-flows br0 --no-stats | sort], [0], [dnl
 cookie=0x123, table=2, reg0=0x5 actions=drop
 cookie=0x234, table=1, reg0=0x6 actions=drop
 reg0=0x2 actions=learn(table=1,delete_learned,cookie=0x234),output:2
])

# Delete the flow with the learn action.  The learned flow disappears too.
AT_CHECK([ovs-ofctl del-flows br0 table=0])
AT_CHECK([ovs-ofctl dump-flows br0 --no-stats | sort], [0], [dnl
 cookie=0x123, table=2, reg0=0x5 actions=drop
])

# Add a new set of flows to check on a corner case: the learned flows
# contain their own learn actions which cascade to further deletions.
# This can't happen if the learned flows were actually created by a
# learn action, since the learn action has very restricted action
# support, but there's no restriction that the deleted flows were
# created by a learn action.
AT_DATA([flows.txt], [dnl
                       reg0=0x1 actions=learn(table=1,delete_learned,cookie=0x123)
                       reg0=0x2 actions=learn(table=2,delete_learned,cookie=0x234)
cookie=0x123, table=1, reg0=0x3 actions=learn(table=3,delete_learned,cookie=0x345)
cookie=0x234, table=2, reg0=0x3 actions=learn(table=4,delete_learned,cookie=0x456)
cookie=0x345, table=3, reg0=0x4 actions=learn(table=5,delete_learned,cookie=0x567)
cookie=0x456, table=4, reg0=0x5 actions=learn(table=5,delete_learned,cookie=0x567)
cookie=0x567, table=5, reg0=0x6 actions=drop
cookie=0x567, table=5, reg0=0x7 actions=drop
cookie=0x567, table=5, reg0=0x8 actions=drop
])
AT_CHECK([ovs-ofctl del-flows br0])
AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
AT_CHECK([ovs-ofctl dump-flows br0 --no-stats | sort], [0], [dnl
 cookie=0x123, table=1, reg0=0x3 actions=learn(table=3,delete_learned,cookie=0x345)
 cookie=0x234, table=2, reg0=0x3 actions=learn(table=4,delete_learned,cookie=0x456)
 cookie=0x345, table=3, reg0=0x4 actions=learn(table=5,delete_learned,cookie=0x567)
 cookie=0x456, table=4, reg0=0x5 actions=learn(table=5,delete_learned,cookie=0x567)
 cookie=0x567, table=5, reg0=0x6 actions=drop
 cookie=0x567, table=5, reg0=0x7 actions=drop
 cookie=0x567, table=5, reg0=0x8 actions=drop
 reg0=0x1 actions=learn(table=1,delete_learned,cookie=0x123)
 reg0=0x2 actions=learn(table=2,delete_learned,cookie=0x234)
])

# Deleting the flow with reg0=1 should cascade to delete a few levels
# of learned flows, but the ones with cookie=0x567 stick around
# because of the flow with cookie=0x456.
AT_CHECK([ovs-ofctl del-flows br0 'table=0 reg0=1'])
AT_CHECK([ovs-ofctl dump-flows br0 --no-stats | sort], [0], [dnl
 cookie=0x234, table=2, reg0=0x3 actions=learn(table=4,delete_learned,cookie=0x456)
 cookie=0x456, table=4, reg0=0x5 actions=learn(table=5,delete_learned,cookie=0x567)
 cookie=0x567, table=5, reg0=0x6 actions=drop
 cookie=0x567, table=5, reg0=0x7 actions=drop
 cookie=0x567, table=5, reg0=0x8 actions=drop
 reg0=0x2 actions=learn(table=2,delete_learned,cookie=0x234)
])

# Deleting the flow with reg0=2 should cascade to delete all the rest:
AT_CHECK([ovs-ofctl del-flows br0 'table=0 reg0=2'])
AT_CHECK([ovs-ofctl dump-flows br0 --no-stats | sort])
OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([learning action - delete_learned/limit with packet])
OVS_VSWITCHD_START(
    [add-port br0 p1 -- set Interface p1 type=dummy ofport_request=1 --\
     add-port br0 p2 -- set Interface p2 type=dummy ofport_request=2])

# Add some initial flows and check that it was successful.
AT_DATA([flows.txt], [dnl
table=0 actions=set_field:0x2->reg7,set_field:0xabcdef01->metadata, resubmit(,1)
table=1 actions=learn(table=10,delete_learned,cookie=0x123,limit=3,result_dst=NXM_NX_REG6[[0]],NXM_OF_ETH_DST[[]]=NXM_OF_ETH_SRC[[]],OXM_OF_METADATA[[]],output:NXM_NX_REG7)
])

AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
AT_CHECK([ovs-ofctl dump-flows br0 --no-stats | sort], [0], [dnl
 actions=load:0x2->NXM_NX_REG7[[]],load:0xabcdef01->OXM_OF_METADATA[[]],resubmit(,1)
 table=1, actions=learn(table=10,delete_learned,cookie=0x123,limit=3,result_dst=NXM_NX_REG6[[0]],NXM_OF_ETH_DST[[]]=NXM_OF_ETH_SRC[[]],OXM_OF_METADATA[[]],output:NXM_NX_REG7[[]])
])

dnl Each packet will generate its own flow at table=10, except last one
AT_CHECK([ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:01,dst=50:54:00:00:00:ff),eth_type(0x1234)'])
AT_CHECK([ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:02,dst=50:54:00:00:00:ff),eth_type(0x1234)'])
AT_CHECK([ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:03,dst=50:54:00:00:00:ff),eth_type(0x1234)'])
AT_CHECK([ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:04,dst=50:54:00:00:00:ff),eth_type(0x1234)'])

AT_CHECK([ovs-ofctl dump-flows br0 table=10 --no-stats | sort], [0], [dnl
 cookie=0x123, table=10, metadata=0xabcdef01,dl_dst=50:54:00:00:00:01 actions=output:2
 cookie=0x123, table=10, metadata=0xabcdef01,dl_dst=50:54:00:00:00:02 actions=output:2
 cookie=0x123, table=10, metadata=0xabcdef01,dl_dst=50:54:00:00:00:03 actions=output:2
])

ovs-appctl revalidator/wait

AT_CHECK([ovs-ofctl del-flows br0 'table=1'])
AT_CHECK([ovs-ofctl dump-flows br0 table=10 --no-stats | sort], [0], [dnl
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([learning action - limit])
OVS_VSWITCHD_START
AT_CHECK([ovs-appctl vlog/set dpif:dbg dpif_netdev:dbg])
add_of_ports br0 1 2
AT_DATA([flows.txt], [dnl
table=0 in_port=1 actions=learn(table=1,dl_dst=dl_src,cookie=0x1,limit=1),2
])
AT_CHECK([ovs-ofctl add-flows br0 flows.txt])
AT_CHECK([ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:01,dst=50:54:00:00:00:ff),eth_type(0x1234)'])
AT_CHECK([ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:02,dst=50:54:00:00:00:ff),eth_type(0x1234)'])

OVS_WAIT_UNTIL([ovs-ofctl dump-ports br0 2 | grep -o 'tx pkts=2' >/dev/null])

AT_CHECK([ovs-ofctl dump-flows br0 table=1 --no-stats], [0], [dnl
 cookie=0x1, table=1, dl_dst=50:54:00:00:00:01 actions=drop
])

dnl Delete the learned flow
AT_CHECK([ovs-ofctl del-flows br0 table=1])

AT_CHECK([ovs-ofctl dump-flows br0 table=1 | ofctl_strip | sort], [0], [dnl
NXST_FLOW reply:
])

ovs-appctl revalidator/wait

AT_CHECK([ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:02,dst=50:54:00:00:00:ff),eth_type(0x1234)'])
AT_CHECK([ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:01,dst=50:54:00:00:00:ff),eth_type(0x1234)'])

OVS_WAIT_UNTIL([ovs-ofctl dump-ports br0 2 | grep -o 'tx pkts=4' >/dev/null])

AT_CHECK([ovs-ofctl dump-flows br0 table=1 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, table=1, dl_dst=50:54:00:00:00:02 actions=drop
NXST_FLOW reply:
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([learning action - limit result_dst])
OVS_VSWITCHD_START
AT_CHECK([ovs-appctl vlog/set dpif:dbg dpif_netdev:dbg])
add_of_ports br0 1
AT_DATA([flows.txt], [dnl
table=0 in_port=1 actions=learn(table=1,dl_dst=dl_src,cookie=0x1,limit=1,result_dst=reg0[[0]]),controller
])
AT_CHECK([ovs-ofctl add-flows br0 flows.txt])

AT_CAPTURE_FILE([ofctl_monitor.log])
AT_CHECK([ovs-ofctl monitor br0 65534 invalid_ttl -P nxt_packet_in --detach --no-chdir --pidfile 2> ofctl_monitor.log])

AT_CHECK([ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:01,dst=50:54:00:00:00:ff),eth_type(0x1234)'])
AT_CHECK([ovs-appctl netdev-dummy/receive p1 'in_port(1),eth(src=50:54:00:00:00:02,dst=50:54:00:00:00:ff),eth_type(0x1234)'])

OVS_WAIT_UNTIL([test `wc -l < ofctl_monitor.log` -ge 4])
OVS_WAIT_UNTIL([ovs-appctl -t ovs-ofctl exit])

AT_CHECK([cat ofctl_monitor.log], [0], [dnl
NXT_PACKET_IN (xid=0x0): cookie=0x0 total_len=14 reg0=0x1,in_port=1 (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=50:54:00:00:00:01,dl_dst=50:54:00:00:00:ff,dl_type=0x1234
NXT_PACKET_IN (xid=0x0): cookie=0x0 total_len=14 in_port=1 (via action) data_len=14 (unbuffered)
vlan_tci=0x0000,dl_src=50:54:00:00:00:02,dl_dst=50:54:00:00:00:ff,dl_type=0x1234
])

AT_CHECK([ovs-ofctl dump-flows br0 table=1 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, table=1, dl_dst=50:54:00:00:00:01 actions=drop
NXST_FLOW reply:
])

OVS_VSWITCHD_STOP
AT_CLEANUP

AT_SETUP([learning action - different limits])
OVS_VSWITCHD_START
AT_CHECK([ovs-appctl vlog/set dpif:dbg dpif_netdev:dbg])
add_of_ports br0 1 2 3
AT_DATA([flows.txt], [dnl
table=0 in_port=1 udp,actions=learn(table=11,dl_type=0x0800,nw_proto=17,udp_src=udp_dst,limit=1,result_dst=reg0[[0]]),resubmit(,1)
table=0 in_port=2 udp,actions=learn(table=12,dl_type=0x0800,nw_proto=17,udp_src=udp_dst,limit=10,result_dst=reg0[[0]]),resubmit(,1)
table=0 in_port=3 udp,actions=learn(table=13,dl_type=0x0800,nw_proto=17,udp_src=udp_dst,limit=20,result_dst=reg0[[0]]),resubmit(,1)
dnl
dnl These flows simply counts the packets that executed a successful learn action:
dnl
table=1 cookie=1,reg0=1,in_port=1 actions=drop
table=1 cookie=2,reg0=1,in_port=2 actions=drop
table=1 cookie=3,reg0=1,in_port=3 actions=drop
dnl
dnl These flows simply counts the packets that didn't execute a successful learn action:
dnl
table=1 cookie=1,reg0=0,in_port=1 actions=drop
table=1 cookie=2,reg0=0,in_port=2 actions=drop
table=1 cookie=3,reg0=0,in_port=3 actions=drop
])
AT_CHECK([ovs-ofctl add-flows br0 flows.txt])

for i in `seq 1001 1030`; do
    ovs-appctl netdev-dummy/receive p1 "in_port(1),eth(src=50:54:00:00:00:01,dst=50:54:00:00:00:ff),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=17,tos=0,ttl=64,frag=no),udp(src=1,dst=$i)"
    ovs-appctl netdev-dummy/receive p2 "in_port(2),eth(src=50:54:00:00:00:01,dst=50:54:00:00:00:ff),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=17,tos=0,ttl=64,frag=no),udp(src=1,dst=$i)"
    ovs-appctl netdev-dummy/receive p3 "in_port(3),eth(src=50:54:00:00:00:01,dst=50:54:00:00:00:ff),eth_type(0x0800),ipv4(src=192.168.0.1,dst=192.168.0.2,proto=17,tos=0,ttl=64,frag=no),udp(src=1,dst=$i)"
done

dnl Check successful counters:
AT_CHECK([ovs-ofctl dump-flows br0 table=1,reg0=1 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, table=1, n_packets=1, n_bytes=106, reg0=0x1,in_port=1 actions=drop
 cookie=0x2, table=1, n_packets=10, n_bytes=1060, reg0=0x1,in_port=2 actions=drop
 cookie=0x3, table=1, n_packets=20, n_bytes=2120, reg0=0x1,in_port=3 actions=drop
NXST_FLOW reply:
])

dnl Check failed counters:
AT_CHECK([ovs-ofctl dump-flows br0 table=1,reg0=0 | ofctl_strip | sort], [0], [dnl
 cookie=0x1, table=1, n_packets=29, n_bytes=3074, reg0=0,in_port=1 actions=drop
 cookie=0x2, table=1, n_packets=20, n_bytes=2120, reg0=0,in_port=2 actions=drop
 cookie=0x3, table=1, n_packets=10, n_bytes=1060, reg0=0,in_port=3 actions=drop
NXST_FLOW reply:
])

dnl Check learned flows:

AT_CHECK([ovs-ofctl dump-flows br0 table=13 | ofctl_strip | sort], [0], [dnl
 table=13, udp,tp_src=1001 actions=drop
 table=13, udp,tp_src=1002 actions=drop
 table=13, udp,tp_src=1003 actions=drop
 table=13, udp,tp_src=1004 actions=drop
 table=13, udp,tp_src=1005 actions=drop
 table=13, udp,tp_src=1006 actions=drop
 table=13, udp,tp_src=1007 actions=drop
 table=13, udp,tp_src=1008 actions=drop
 table=13, udp,tp_src=1009 actions=drop
 table=13, udp,tp_src=1010 actions=drop
 table=13, udp,tp_src=1011 actions=drop
 table=13, udp,tp_src=1012 actions=drop
 table=13, udp,tp_src=1013 actions=drop
 table=13, udp,tp_src=1014 actions=drop
 table=13, udp,tp_src=1015 actions=drop
 table=13, udp,tp_src=1016 actions=drop
 table=13, udp,tp_src=1017 actions=drop
 table=13, udp,tp_src=1018 actions=drop
 table=13, udp,tp_src=1019 actions=drop
 table=13, udp,tp_src=1020 actions=drop
NXST_FLOW reply:
])

AT_CHECK([ovs-ofctl dump-flows br0 table=12 | ofctl_strip | sort], [0], [dnl
 table=12, udp,tp_src=1001 actions=drop
 table=12, udp,tp_src=1002 actions=drop
 table=12, udp,tp_src=1003 actions=drop
 table=12, udp,tp_src=1004 actions=drop
 table=12, udp,tp_src=1005 actions=drop
 table=12, udp,tp_src=1006 actions=drop
 table=12, udp,tp_src=1007 actions=drop
 table=12, udp,tp_src=1008 actions=drop
 table=12, udp,tp_src=1009 actions=drop
 table=12, udp,tp_src=1010 actions=drop
NXST_FLOW reply:
])

AT_CHECK([ovs-ofctl dump-flows br0 table=11 | ofctl_strip | sort], [0], [dnl
 table=11, udp,tp_src=1001 actions=drop
NXST_FLOW reply:
])

AT_CHECK([ovs-vsctl del-br br0])

ovs-appctl time/warp 500
ovs-appctl time/warp 500
ovs-appctl time/warp 500
ovs-appctl time/warp 500

AT_CHECK([ovs-vsctl add-br br1 -- set b br1 datapath_type=dummy])

OVS_VSWITCHD_STOP
AT_CLEANUP
