<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TommyDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="tommy.css" rel="stylesheet" type="text/css">
</head>
<body>

<!-- Generated by Doxygen 1.7.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>tommyds/tommylist.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Double linked list for collisions into hashtables.  
<a href="#_details">More...</a></p>

<p><a href="tommylist_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtommy__node__struct.html">tommy_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommylist_8h.html#a45d098412d5f0be21113b252caee491b">tommy_list</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Double linked list type.  <a href="#a45d098412d5f0be21113b252caee491b"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommylist_8h.html#a2fc05289c0e8797ffe45e28b9d3671ff">tommy_list_init</a> (<a class="el" href="structtommy__node__struct.html">tommy_list</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the list.  <a href="#a2fc05289c0e8797ffe45e28b9d3671ff"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtommy__node__struct.html">tommy_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommylist_8h.html#aa9e7b5d591c265d71d518e27f7589d47">tommy_list_head</a> (<a class="el" href="structtommy__node__struct.html">tommy_list</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the head of the list.  <a href="#aa9e7b5d591c265d71d518e27f7589d47"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtommy__node__struct.html">tommy_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommylist_8h.html#ad0c26b19b90a829fa72fae178b3fd9d1">tommy_list_tail</a> (<a class="el" href="structtommy__node__struct.html">tommy_list</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the tail of the list.  <a href="#ad0c26b19b90a829fa72fae178b3fd9d1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommylist_8h.html#a34f45481430a2dab5034b3bc49a6a711">tommy_list_insert_head</a> (<a class="el" href="structtommy__node__struct.html">tommy_list</a> *list, <a class="el" href="structtommy__node__struct.html">tommy_node</a> *node, void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element at the head of a list.  <a href="#a34f45481430a2dab5034b3bc49a6a711"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommylist_8h.html#a98e34efdc68731f3e6da976e4d54ef63">tommy_list_insert_tail</a> (<a class="el" href="structtommy__node__struct.html">tommy_list</a> *list, <a class="el" href="structtommy__node__struct.html">tommy_node</a> *node, void *data)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element at the tail of a list.  <a href="#a98e34efdc68731f3e6da976e4d54ef63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommylist_8h.html#ad2dfbf52d6cd1a3f55d0822e90386905">tommy_list_remove_existing</a> (<a class="el" href="structtommy__node__struct.html">tommy_list</a> *list, <a class="el" href="structtommy__node__struct.html">tommy_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from the list.  <a href="#ad2dfbf52d6cd1a3f55d0822e90386905"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommylist_8h.html#aa23d4cbad2a1b0c9015de64dee8a95f6">tommy_list_concat</a> (<a class="el" href="structtommy__node__struct.html">tommy_list</a> *first, <a class="el" href="structtommy__node__struct.html">tommy_list</a> *second)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Concats two lists.  <a href="#aa23d4cbad2a1b0c9015de64dee8a95f6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommylist_8h.html#a0edd81ae314ffaccc527945a68df1165">tommy_list_sort</a> (<a class="el" href="structtommy__node__struct.html">tommy_list</a> *list, <a class="el" href="tommytypes_8h.html#a2e56e0b56065d3200e65f2a5518651d0">tommy_compare_func</a> *cmp)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts a list.  <a href="#a0edd81ae314ffaccc527945a68df1165"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="tommytypes_8h.html#afa577fad20a7ce79f14522a0d202bc96">tommy_bool_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommylist_8h.html#aa5c92e5869f68dc5c55c55336e01ba6f">tommy_list_empty</a> (<a class="el" href="structtommy__node__struct.html">tommy_list</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if empty.  <a href="#aa5c92e5869f68dc5c55c55336e01ba6f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="tommytypes_8h.html#a802a296e9903e3bc098432b9bdad03ab">tommy_count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommylist_8h.html#a931501223fc80c9c8a5998e21afc5c64">tommy_list_count</a> (<a class="el" href="structtommy__node__struct.html">tommy_list</a> *list)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of elements.  <a href="#a931501223fc80c9c8a5998e21afc5c64"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommylist_8h.html#aff0d5bf37382622516d889faac501b61">tommy_list_foreach</a> (<a class="el" href="structtommy__node__struct.html">tommy_list</a> *list, <a class="el" href="tommytypes_8h.html#a8caf78c4fb7706a85093f99598d61b5d">tommy_foreach_func</a> *func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the specified function for each element in the list.  <a href="#aff0d5bf37382622516d889faac501b61"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommylist_8h.html#a1ee2d137f6ebee0237b6535a5f1b9ba3">tommy_list_foreach_arg</a> (<a class="el" href="structtommy__node__struct.html">tommy_list</a> *list, <a class="el" href="tommytypes_8h.html#ae0aea577584dfbe750f078b3801d0ee6">tommy_foreach_arg_func</a> *func, void *arg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the specified function with an argument for each element in the list.  <a href="#a1ee2d137f6ebee0237b6535a5f1b9ba3"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Double linked list for collisions into hashtables. </p>
<p>This list is a double linked list mainly targetted for handling collisions into an hashtables, but useable also as a generic list.</p>
<p>The main feature of this list is to require only one pointer to represent the list, compared to a classic implementation requiring a head an a tail pointers. This reduces the memory usage in hashtables.</p>
<p>Another feature is to support the insertion at the end of the list. This allow to store collisions in a stable order. Where for stable order we mean that equal elements keep their insertion order.</p>
<p>To initialize the list, you have to call <a class="el" href="tommylist_8h.html#a2fc05289c0e8797ffe45e28b9d3671ff" title="Initializes the list.">tommy_list_init()</a>, or to simply assign to it NULL, as an empty list is represented by the NULL value.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_list</a> list;

 <a class="code" href="tommylist_8h.html#a2fc05289c0e8797ffe45e28b9d3671ff" title="Initializes the list.">tommy_list_init</a>(&amp;list); <span class="comment">// initializes the list</span>
</pre></div><p>To insert elements in the list you have to call <a class="el" href="tommylist_8h.html#a98e34efdc68731f3e6da976e4d54ef63" title="Inserts an element at the tail of a list.">tommy_list_insert_tail()</a> or <a class="el" href="tommylist_8h.html#a34f45481430a2dab5034b3bc49a6a711" title="Inserts an element at the head of a list.">tommy_list_insert_head()</a> for each element. In the insertion call you have to specify the address of the node and the address of the object. The address of the object is used to initialize the <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer to the object containing the node.">tommy_node::data</a> field of the node.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>object {
     <span class="keywordtype">int</span> value;
     <span class="comment">// other fields</span>
     <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_node</a> node;
 };

 <span class="keyword">struct </span>object* obj = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="keywordtype">object</span>)); <span class="comment">// creates the object</span>

 obj-&gt;value = ...; <span class="comment">// initializes the object</span>

 <a class="code" href="tommylist_8h.html#a98e34efdc68731f3e6da976e4d54ef63" title="Inserts an element at the tail of a list.">tommy_list_insert_tail</a>(&amp;list, &amp;obj-&gt;node, obj); <span class="comment">// inserts the object</span>
</pre></div><p>To iterate over all the elements in the list you have to call <a class="el" href="tommylist_8h.html#aa9e7b5d591c265d71d518e27f7589d47" title="Gets the head of the list.">tommy_list_head()</a> to get the head of the list and follow the <a class="el" href="structtommy__node__struct.html#a53338f3f5366866598ed9ac7e46e64a2" title="Next node.">tommy_node::next</a> pointer until NULL.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_node</a>* i = <a class="code" href="tommylist_8h.html#aa9e7b5d591c265d71d518e27f7589d47" title="Gets the head of the list.">tommy_list_head</a>(&amp;list);
 <span class="keywordflow">while</span> (i) {
     <span class="keyword">struct </span>object* obj = i-&gt;<a class="code" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer to the object containing the node.">data</a>; <span class="comment">// gets the object pointer</span>

     printf(<span class="stringliteral">&quot;%d\n&quot;</span>, obj-&gt;value); <span class="comment">// process the object</span>

     i = i-&gt;<a class="code" href="structtommy__node__struct.html#a53338f3f5366866598ed9ac7e46e64a2" title="Next node.">next</a>; <span class="comment">// go to the next element</span>
 }
</pre></div><p>To destroy the list you have to remove all the elements, as the list is completely inplace and it doesn't allocate memory. This can be done with the <a class="el" href="tommylist_8h.html#aff0d5bf37382622516d889faac501b61" title="Calls the specified function for each element in the list.">tommy_list_foreach()</a> function.</p>
<div class="fragment"><pre class="fragment"> <span class="comment">// deallocates all the objects iterating the list</span>
 <a class="code" href="tommylist_8h.html#aff0d5bf37382622516d889faac501b61" title="Calls the specified function for each element in the list.">tommy_list_foreach</a>(&amp;list, free);
</pre></div> </div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a45d098412d5f0be21113b252caee491b"></a><!-- doxytag: member="tommylist.h::tommy_list" ref="a45d098412d5f0be21113b252caee491b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtommy__node__struct.html">tommy_node</a>* <a class="el" href="structtommy__node__struct.html">tommy_list</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Double linked list type. </p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a2fc05289c0e8797ffe45e28b9d3671ff"></a><!-- doxytag: member="tommylist.h::tommy_list_init" ref="a2fc05289c0e8797ffe45e28b9d3671ff" args="(tommy_list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_list_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the list. </p>
<p>The list is completely inplace, so it doesn't need to be deinitialized. </p>

</div>
</div>
<a class="anchor" id="aa9e7b5d591c265d71d518e27f7589d47"></a><!-- doxytag: member="tommylist.h::tommy_list_head" ref="aa9e7b5d591c265d71d518e27f7589d47" args="(tommy_list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtommy__node__struct.html">tommy_node</a>* tommy_list_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the head of the list. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The head node. For empty lists 0 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0c26b19b90a829fa72fae178b3fd9d1"></a><!-- doxytag: member="tommylist.h::tommy_list_tail" ref="ad0c26b19b90a829fa72fae178b3fd9d1" args="(tommy_list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtommy__node__struct.html">tommy_node</a>* tommy_list_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the tail of the list. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The tail node. For empty lists 0 is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="a34f45481430a2dab5034b3bc49a6a711"></a><!-- doxytag: member="tommylist.h::tommy_list_insert_head" ref="a34f45481430a2dab5034b3bc49a6a711" args="(tommy_list *list, tommy_node *node, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_list_insert_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_list</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts an element at the head of a list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to insert. </td></tr>
    <tr><td class="paramname">data</td><td>The object containing the node. It's used to set the <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer to the object containing the node.">tommy_node::data</a> field of the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a98e34efdc68731f3e6da976e4d54ef63"></a><!-- doxytag: member="tommylist.h::tommy_list_insert_tail" ref="a98e34efdc68731f3e6da976e4d54ef63" args="(tommy_list *list, tommy_node *node, void *data)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_list_insert_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_list</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts an element at the tail of a list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to insert. </td></tr>
    <tr><td class="paramname">data</td><td>The object containing the node. It's used to set the <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer to the object containing the node.">tommy_node::data</a> field of the node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad2dfbf52d6cd1a3f55d0822e90386905"></a><!-- doxytag: member="tommylist.h::tommy_list_remove_existing" ref="ad2dfbf52d6cd1a3f55d0822e90386905" args="(tommy_list *list, tommy_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tommy_list_remove_existing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_list</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes an element from the list. </p>
<p>You must already have the address of the element to remove. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>The node content is left unchanged, including the <a class="el" href="structtommy__node__struct.html#a53338f3f5366866598ed9ac7e46e64a2" title="Next node.">tommy_node::next</a> and <a class="el" href="structtommy__node__struct.html#a5f5ffba676428636553612ddd809443c" title="Previous node.">tommy_node::prev</a> fields that still contain pointers at the list. </dd></dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node to remove. The node must be in the list. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer to the object containing the node.">tommy_node::data</a> field of the node removed. </dd></dl>

</div>
</div>
<a class="anchor" id="aa23d4cbad2a1b0c9015de64dee8a95f6"></a><!-- doxytag: member="tommylist.h::tommy_list_concat" ref="aa23d4cbad2a1b0c9015de64dee8a95f6" args="(tommy_list *first, tommy_list *second)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_list_concat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_list</a> *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_list</a> *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Concats two lists. </p>
<p>The second list is concatenated at the first list. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>The first list. </td></tr>
    <tr><td class="paramname">second</td><td>The second list. After this call the list content is undefined, and you should not use it anymore. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0edd81ae314ffaccc527945a68df1165"></a><!-- doxytag: member="tommylist.h::tommy_list_sort" ref="a0edd81ae314ffaccc527945a68df1165" args="(tommy_list *list, tommy_compare_func *cmp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_list_sort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_list</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#a2e56e0b56065d3200e65f2a5518651d0">tommy_compare_func</a> *&#160;</td>
          <td class="paramname"><em>cmp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Sorts a list. </p>
<p>It's a stable merge sort with O(N*log(N)) worst complexity. It's faster on degenerated cases like partially ordered lists. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cmp</td><td>Compare function called with two elements. The function should return &lt;0 if the first element is less than the second, ==0 if equal, and &gt;0 if greather. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa5c92e5869f68dc5c55c55336e01ba6f"></a><!-- doxytag: member="tommylist.h::tommy_list_empty" ref="aa5c92e5869f68dc5c55c55336e01ba6f" args="(tommy_list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tommytypes_8h.html#afa577fad20a7ce79f14522a0d202bc96">tommy_bool_t</a> tommy_list_empty </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Checks if empty. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>If the list is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a931501223fc80c9c8a5998e21afc5c64"></a><!-- doxytag: member="tommylist.h::tommy_list_count" ref="a931501223fc80c9c8a5998e21afc5c64" args="(tommy_list *list)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tommytypes_8h.html#a802a296e9903e3bc098432b9bdad03ab">tommy_count_t</a> tommy_list_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_list</a> *&#160;</td>
          <td class="paramname"><em>list</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of elements. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>This operation is O(n). </dd></dl>

</div>
</div>
<a class="anchor" id="aff0d5bf37382622516d889faac501b61"></a><!-- doxytag: member="tommylist.h::tommy_list_foreach" ref="aff0d5bf37382622516d889faac501b61" args="(tommy_list *list, tommy_foreach_func *func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_list_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_list</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#a8caf78c4fb7706a85093f99598d61b5d">tommy_foreach_func</a> *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls the specified function for each element in the list. </p>
<p>You cannot add or remove elements from the inside of the callback, but can use it to deallocate them.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_list</a> list;

 <span class="comment">// initializes the list</span>
 <a class="code" href="tommylist_8h.html#a2fc05289c0e8797ffe45e28b9d3671ff" title="Initializes the list.">tommy_list_init</a>(&amp;list);

 ...

 <span class="comment">// creates an object</span>
 <span class="keyword">struct </span>object* obj = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="keywordtype">object</span>));

 ...

 <span class="comment">// insert it in the list</span>
 <a class="code" href="tommylist_8h.html#a98e34efdc68731f3e6da976e4d54ef63" title="Inserts an element at the tail of a list.">tommy_list_insert_tail</a>(&amp;list, &amp;obj-&gt;node, obj);

 ...

 <span class="comment">// deallocates all the objects iterating the list</span>
 <a class="code" href="tommylist_8h.html#aff0d5bf37382622516d889faac501b61" title="Calls the specified function for each element in the list.">tommy_list_foreach</a>(&amp;list, free);
</pre></div> 
</div>
</div>
<a class="anchor" id="a1ee2d137f6ebee0237b6535a5f1b9ba3"></a><!-- doxytag: member="tommylist.h::tommy_list_foreach_arg" ref="a1ee2d137f6ebee0237b6535a5f1b9ba3" args="(tommy_list *list, tommy_foreach_arg_func *func, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_list_foreach_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_list</a> *&#160;</td>
          <td class="paramname"><em>list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#ae0aea577584dfbe750f078b3801d0ee6">tommy_foreach_arg_func</a> *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls the specified function with an argument for each element in the list. </p>

</div>
</div>
</div>
</body>
</html>
