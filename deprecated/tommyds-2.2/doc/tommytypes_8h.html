<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TommyDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="tommy.css" rel="stylesheet" type="text/css">
</head>
<body>

<!-- Generated by Doxygen 1.7.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Defines</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>tommyds/tommytypes.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Generic types.  
<a href="#_details">More...</a></p>

<p><a href="tommytypes_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtommy__node__struct.html">tommy_node_struct</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure node.  <a href="structtommy__node__struct.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="define-members"></a>
Defines</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#a65b1af0882a87cf7c9c82577ab058356">tommy_malloc</a>&#160;&#160;&#160;malloc</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic malloc(), calloc(), realloc() and free() functions.  <a href="#a65b1af0882a87cf7c9c82577ab058356"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#a26948e6a182e70129c3c0063e1c8fd17">TOMMY_KEY_BIT</a>&#160;&#160;&#160;(sizeof(<a class="el" href="tommytypes_8h.html#a8812c3379df4aaf65a3605a22faf4787">tommy_key_t</a>) * 8)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bits into the <a class="el" href="tommytypes_8h.html#a8812c3379df4aaf65a3605a22faf4787" title="Key type used in indexed data structures to store the key or the hash value.">tommy_key_t</a> type.  <a href="#a26948e6a182e70129c3c0063e1c8fd17"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic uint32_t type.  <a href="#a21bc1d926c6dcd89e5c10fb201ee03a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#a169e7168a1f2b4c01cbd525204c3be63">tommy_uint64_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic uint64_t type.  <a href="#a169e7168a1f2b4c01cbd525204c3be63"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#aec28849bb6cfba7c9e7ad8b510cfe711">tommy_uintptr_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic uintptr_t type.  <a href="#aec28849bb6cfba7c9e7ad8b510cfe711"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#a32aad870b975610a257f9c2d14b0825e">tommy_size_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic size_t type.  <a href="#a32aad870b975610a257f9c2d14b0825e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef ptrdiff_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#a7816a8ccfb095cf113e49dcedebf9389">tommy_ptrdiff_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic ptrdiff_t type.  <a href="#a7816a8ccfb095cf113e49dcedebf9389"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#afa577fad20a7ce79f14522a0d202bc96">tommy_bool_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic boolean type.  <a href="#afa577fad20a7ce79f14522a0d202bc96"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#aeb21ea228f19971e47c8fba1023a598d">tommy_uint_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic unsigned integer type.  <a href="#aeb21ea228f19971e47c8fba1023a598d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#a802a296e9903e3bc098432b9bdad03ab">tommy_count_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic unsigned integer for counting objects.  <a href="#a802a296e9903e3bc098432b9bdad03ab"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#a8812c3379df4aaf65a3605a22faf4787">tommy_key_t</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Key type used in indexed data structures to store the key or the hash value.  <a href="#a8812c3379df4aaf65a3605a22faf4787"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structtommy__node__struct.html">tommy_node_struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#a56a5b6211015e83fd69c4f990ac5612b">tommy_node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure node.  <a href="#a56a5b6211015e83fd69c4f990ac5612b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#a2e56e0b56065d3200e65f2a5518651d0">tommy_compare_func</a> (const void *obj_a, const void *obj_b)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare function for elements.  <a href="#a2e56e0b56065d3200e65f2a5518651d0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#a9008971cd09a3f9c4f9da45cffb4627d">tommy_search_func</a> (const void *arg, const void *obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Search function for elements.  <a href="#a9008971cd09a3f9c4f9da45cffb4627d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#a8caf78c4fb7706a85093f99598d61b5d">tommy_foreach_func</a> (void *obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Foreach function.  <a href="#a8caf78c4fb7706a85093f99598d61b5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#ae0aea577584dfbe750f078b3801d0ee6">tommy_foreach_arg_func</a> (void *arg, void *obj)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Foreach function with an argument.  <a href="#ae0aea577584dfbe750f078b3801d0ee6"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="tommytypes_8h.html#aeb21ea228f19971e47c8fba1023a598d">tommy_uint_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#ac175ae124fdc23cf0ffa7bb8e4f09f45">tommy_ilog2_u32</a> (<a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a> value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit scan reverse or integer log2.  <a href="#ac175ae124fdc23cf0ffa7bb8e4f09f45"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="tommytypes_8h.html#aeb21ea228f19971e47c8fba1023a598d">tommy_uint_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#a3a147d59b268e82f25cf70f3d6ab45e4">tommy_ctz_u32</a> (<a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a> value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit scan forward or trailing zero count.  <a href="#a3a147d59b268e82f25cf70f3d6ab45e4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#aba7650ee6d157e30528da979408a5af9">tommy_roundup_pow2_u32</a> (<a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a> value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Rounds up to the next power of 2.  <a href="#aba7650ee6d157e30528da979408a5af9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommytypes_8h.html#a36e826cdcc0c9957d3541de4d10a787e">tommy_haszero_u32</a> (<a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a> value)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the specified word has a byte at 0.  <a href="#a36e826cdcc0c9957d3541de4d10a787e"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Generic types. </p>
</div><hr/><h2>Define Documentation</h2>
<a class="anchor" id="a65b1af0882a87cf7c9c82577ab058356"></a><!-- doxytag: member="tommytypes.h::tommy_malloc" ref="a65b1af0882a87cf7c9c82577ab058356" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define tommy_malloc&#160;&#160;&#160;malloc</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic malloc(), calloc(), realloc() and free() functions. </p>
<p>Redefine them to what you need. By default they map to the C malloc(), calloc(), realloc() and free(). </p>

</div>
</div>
<a class="anchor" id="a26948e6a182e70129c3c0063e1c8fd17"></a><!-- doxytag: member="tommytypes.h::TOMMY_KEY_BIT" ref="a26948e6a182e70129c3c0063e1c8fd17" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TOMMY_KEY_BIT&#160;&#160;&#160;(sizeof(<a class="el" href="tommytypes_8h.html#a8812c3379df4aaf65a3605a22faf4787">tommy_key_t</a>) * 8)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bits into the <a class="el" href="tommytypes_8h.html#a8812c3379df4aaf65a3605a22faf4787" title="Key type used in indexed data structures to store the key or the hash value.">tommy_key_t</a> type. </p>

</div>
</div>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="a21bc1d926c6dcd89e5c10fb201ee03a4"></a><!-- doxytag: member="tommytypes.h::tommy_uint32_t" ref="a21bc1d926c6dcd89e5c10fb201ee03a4" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint32_t <a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic uint32_t type. </p>

</div>
</div>
<a class="anchor" id="a169e7168a1f2b4c01cbd525204c3be63"></a><!-- doxytag: member="tommytypes.h::tommy_uint64_t" ref="a169e7168a1f2b4c01cbd525204c3be63" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uint64_t <a class="el" href="tommytypes_8h.html#a169e7168a1f2b4c01cbd525204c3be63">tommy_uint64_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic uint64_t type. </p>

</div>
</div>
<a class="anchor" id="aec28849bb6cfba7c9e7ad8b510cfe711"></a><!-- doxytag: member="tommytypes.h::tommy_uintptr_t" ref="aec28849bb6cfba7c9e7ad8b510cfe711" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef uintptr_t <a class="el" href="tommytypes_8h.html#aec28849bb6cfba7c9e7ad8b510cfe711">tommy_uintptr_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic uintptr_t type. </p>

</div>
</div>
<a class="anchor" id="a32aad870b975610a257f9c2d14b0825e"></a><!-- doxytag: member="tommytypes.h::tommy_size_t" ref="a32aad870b975610a257f9c2d14b0825e" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="tommytypes_8h.html#a32aad870b975610a257f9c2d14b0825e">tommy_size_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic size_t type. </p>

</div>
</div>
<a class="anchor" id="a7816a8ccfb095cf113e49dcedebf9389"></a><!-- doxytag: member="tommytypes.h::tommy_ptrdiff_t" ref="a7816a8ccfb095cf113e49dcedebf9389" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ptrdiff_t <a class="el" href="tommytypes_8h.html#a7816a8ccfb095cf113e49dcedebf9389">tommy_ptrdiff_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic ptrdiff_t type. </p>

</div>
</div>
<a class="anchor" id="afa577fad20a7ce79f14522a0d202bc96"></a><!-- doxytag: member="tommytypes.h::tommy_bool_t" ref="afa577fad20a7ce79f14522a0d202bc96" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="tommytypes_8h.html#afa577fad20a7ce79f14522a0d202bc96">tommy_bool_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic boolean type. </p>

</div>
</div>
<a class="anchor" id="aeb21ea228f19971e47c8fba1023a598d"></a><!-- doxytag: member="tommytypes.h::tommy_uint_t" ref="aeb21ea228f19971e47c8fba1023a598d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a> <a class="el" href="tommytypes_8h.html#aeb21ea228f19971e47c8fba1023a598d">tommy_uint_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic unsigned integer type. </p>
<p>It has no specific size, as is used to store only small values. To make the code more efficient, a full 32 bit integer is used. </p>

</div>
</div>
<a class="anchor" id="a802a296e9903e3bc098432b9bdad03ab"></a><!-- doxytag: member="tommytypes.h::tommy_count_t" ref="a802a296e9903e3bc098432b9bdad03ab" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a> <a class="el" href="tommytypes_8h.html#a802a296e9903e3bc098432b9bdad03ab">tommy_count_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Generic unsigned integer for counting objects. </p>
<p>TommyDS doesn't support more than 2^32-1 objects. </p>

</div>
</div>
<a class="anchor" id="a8812c3379df4aaf65a3605a22faf4787"></a><!-- doxytag: member="tommytypes.h::tommy_key_t" ref="a8812c3379df4aaf65a3605a22faf4787" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a> <a class="el" href="tommytypes_8h.html#a8812c3379df4aaf65a3605a22faf4787">tommy_key_t</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Key type used in indexed data structures to store the key or the hash value. </p>

</div>
</div>
<a class="anchor" id="a56a5b6211015e83fd69c4f990ac5612b"></a><!-- doxytag: member="tommytypes.h::tommy_node" ref="a56a5b6211015e83fd69c4f990ac5612b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structtommy__node__struct.html">tommy_node_struct</a>  <a class="el" href="structtommy__node__struct.html">tommy_node</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Data structure node. </p>
<p>This node type is shared between all the data structures and used to store some info directly into the objects you want to store.</p>
<p>A typical declaration is: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>object {
     <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_node</a> node;
     <span class="comment">// other fields</span>
 };
</pre></div> 
</div>
</div>
<a class="anchor" id="a2e56e0b56065d3200e65f2a5518651d0"></a><!-- doxytag: member="tommytypes.h::tommy_compare_func" ref="a2e56e0b56065d3200e65f2a5518651d0" args="(const void *obj_a, const void *obj_b)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="tommytypes_8h.html#a2e56e0b56065d3200e65f2a5518651d0">tommy_compare_func</a>(const void *obj_a, const void *obj_b)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Compare function for elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj_a</td><td>Pointer to the first object to compare. </td></tr>
    <tr><td class="paramname">obj_b</td><td>Pointer to the second object to compare. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>&lt;0 if the first element is less than the second, ==0 equal, &gt;0 if greather.</dd></dl>
<p>This function is like the C strcmp().</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>object {
     <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_node</a> node;
     <span class="keywordtype">int</span> value;
 };

 <span class="keywordtype">int</span> compare(<span class="keyword">const</span> <span class="keywordtype">void</span>* obj_a, <span class="keyword">const</span> <span class="keywordtype">void</span>* obj_b)
 {
     <span class="keywordflow">if</span> (((<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keywordtype">object</span>*)obj_a)-&gt;value &lt; ((<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keywordtype">object</span>*)obj_b)-&gt;value)
         <span class="keywordflow">return</span> -1;
     <span class="keywordflow">if</span> (((<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keywordtype">object</span>*)obj_a)-&gt;value &gt; ((<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keywordtype">object</span>*)obj_b)-&gt;value)
         <span class="keywordflow">return</span> 1;
     <span class="keywordflow">return</span> 0;
 }

 <a class="code" href="tommylist_8h.html#a0edd81ae314ffaccc527945a68df1165" title="Sorts a list.">tommy_list_sort</a>(&amp;list, compare);
</pre></div> 
</div>
</div>
<a class="anchor" id="a9008971cd09a3f9c4f9da45cffb4627d"></a><!-- doxytag: member="tommytypes.h::tommy_search_func" ref="a9008971cd09a3f9c4f9da45cffb4627d" args="(const void *arg, const void *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="tommytypes_8h.html#a9008971cd09a3f9c4f9da45cffb4627d">tommy_search_func</a>(const void *arg, const void *obj)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Search function for elements. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Pointer to the value to search as passed at the search function. </td></tr>
    <tr><td class="paramname">obj</td><td>Pointer to the object to compare to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>==0 if the value matches the element. !=0 if different.</dd></dl>
<p>The first argument is a pointer to the value to search exactly as it's passed at the search function called. The second argument is a pointer to the object inside the hashtable to compare.</p>
<p>The return value has to be 0 if the values are equal. != 0 if they are different.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>object {
     <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_node</a> node;
     <span class="keywordtype">int</span> value;
 };

 <span class="keywordtype">int</span> compare(<span class="keyword">const</span> <span class="keywordtype">void</span>* arg, <span class="keyword">const</span> <span class="keywordtype">void</span>* obj)
 {
     <span class="keyword">const</span> <span class="keywordtype">int</span>* value_to_find = arg;
     <span class="keyword">const</span> <span class="keyword">struct </span>object* object_to_compare = obj;

     <span class="keywordflow">return</span> *value_to_find != object_to_compare-&gt;value;
 }

 <span class="keywordtype">int</span> value_to_find = 1;
 <span class="keyword">struct </span>object* obj = <a class="code" href="tommyhashtbl_8h.html#a9a2455500c2ed927005ca7d222aa60ff" title="Searches an element in the hashtable.">tommy_hashtable_search</a>(&amp;hashtable, compare, &amp;value_to_find, <a class="code" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71" title="Integer reversible hash function for 32 bits.">tommy_inthash_u32</a>(value_to_find));
 <span class="keywordflow">if</span> (!obj) {
     <span class="comment">// not found</span>
 } <span class="keywordflow">else</span> {
     <span class="comment">// found</span>
 }
</pre></div> 
</div>
</div>
<a class="anchor" id="a8caf78c4fb7706a85093f99598d61b5d"></a><!-- doxytag: member="tommytypes.h::tommy_foreach_func" ref="a8caf78c4fb7706a85093f99598d61b5d" args="(void *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="tommytypes_8h.html#a8caf78c4fb7706a85093f99598d61b5d">tommy_foreach_func</a>(void *obj)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Foreach function. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">obj</td><td>Pointer to the object to iterate.</td></tr>
  </table>
  </dd>
</dl>
<p>A typical example is to use free() to deallocate all the objects in a list. </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="tommylist_8h.html#aff0d5bf37382622516d889faac501b61" title="Calls the specified function for each element in the list.">tommy_list_foreach</a>(&amp;list, (<a class="code" href="tommytypes_8h.html#a8caf78c4fb7706a85093f99598d61b5d" title="Foreach function.">tommy_foreach_func</a>*)free);
</pre></div> 
</div>
</div>
<a class="anchor" id="ae0aea577584dfbe750f078b3801d0ee6"></a><!-- doxytag: member="tommytypes.h::tommy_foreach_arg_func" ref="ae0aea577584dfbe750f078b3801d0ee6" args="(void *arg, void *obj)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void <a class="el" href="tommytypes_8h.html#ae0aea577584dfbe750f078b3801d0ee6">tommy_foreach_arg_func</a>(void *arg, void *obj)</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Foreach function with an argument. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">arg</td><td>Pointer to a generic argument. </td></tr>
    <tr><td class="paramname">obj</td><td>Pointer to the object to iterate. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ac175ae124fdc23cf0ffa7bb8e4f09f45"></a><!-- doxytag: member="tommytypes.h::tommy_ilog2_u32" ref="ac175ae124fdc23cf0ffa7bb8e4f09f45" args="(tommy_uint32_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tommytypes_8h.html#aeb21ea228f19971e47c8fba1023a598d">tommy_uint_t</a> tommy_ilog2_u32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit scan reverse or integer log2. </p>
<p>Return the bit index of the most significant 1 bit.</p>
<p>If no bit is set, the result is undefined. To force a return 0 in this case, you can use tommy_ilog2_u32(value | 1).</p>
<p>Other interesting ways for bitscan are at:</p>
<p>Bit Twiddling Hacks <a href="http://graphics.stanford.edu/~seander/bithacks.html">http://graphics.stanford.edu/~seander/bithacks.html</a></p>
<p>Chess Programming BitScan <a href="http://chessprogramming.wikispaces.com/BitScan">http://chessprogramming.wikispaces.com/BitScan</a></p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to scan. 0 is not allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The index of the most significant bit set. </dd></dl>

</div>
</div>
<a class="anchor" id="a3a147d59b268e82f25cf70f3d6ab45e4"></a><!-- doxytag: member="tommytypes.h::tommy_ctz_u32" ref="a3a147d59b268e82f25cf70f3d6ab45e4" args="(tommy_uint32_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tommytypes_8h.html#aeb21ea228f19971e47c8fba1023a598d">tommy_uint_t</a> tommy_ctz_u32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Bit scan forward or trailing zero count. </p>
<p>Return the bit index of the least significant 1 bit.</p>
<p>If no bit is set, the result is undefined. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td>Value to scan. 0 is not allowed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The index of the least significant bit set. </dd></dl>

</div>
</div>
<a class="anchor" id="aba7650ee6d157e30528da979408a5af9"></a><!-- doxytag: member="tommytypes.h::tommy_roundup_pow2_u32" ref="aba7650ee6d157e30528da979408a5af9" args="(tommy_uint32_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a> tommy_roundup_pow2_u32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Rounds up to the next power of 2. </p>
<p>For the value 0, the result is undefined. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The smallest power of 2 not less than the specified value. </dd></dl>

</div>
</div>
<a class="anchor" id="a36e826cdcc0c9957d3541de4d10a787e"></a><!-- doxytag: member="tommytypes.h::tommy_haszero_u32" ref="a36e826cdcc0c9957d3541de4d10a787e" args="(tommy_uint32_t value)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int tommy_haszero_u32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#a21bc1d926c6dcd89e5c10fb201ee03a4">tommy_uint32_t</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Check if the specified word has a byte at 0. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>0 or 1. </dd></dl>

</div>
</div>
</div>
</body>
</html>
