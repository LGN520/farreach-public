<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TommyDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="tommy.css" rel="stylesheet" type="text/css">
</head>
<body>

<!-- Generated by Doxygen 1.7.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Tommy Documentation</h1>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="Introduction"></a>
Introduction</h2>
<p>Tommy is a C library of array, hashtables and tries data structures, designed for high performance and providing an easy to use interface.</p>
<p>It's <b>faster</b> than all the similar libraries like <a href="http://www.canonware.com/rb/">rbtree</a>, <a href="http://judy.sourceforge.net/">judy</a>, <a href="http://code.google.com/p/cpp-btree/">googlebtree</a>, <a href="http://panthema.net/2007/stx-btree/">stxbtree</a>, <a href="http://attractivechaos.awardspace.com/">khash</a>, <a href="http://uthash.sourceforge.net/">uthash</a>, <a href="http://www.nedprod.com/programs/portable/nedtries/">nedtrie</a>, <a href="http://code.google.com/p/judyarray/">judyarray</a>, <a href="http://concurrencykit.org/">concurrencykit</a> and others. Only <a href="http://code.google.com/p/google-sparsehash/">googledensehash</a> is a real competitor for Tommy.</p>
<p>The data structures provided are:</p>
<ul>
<li><a class="el" href="tommylist_8h.html#a45d098412d5f0be21113b252caee491b" title="Double linked list type.">tommy_list</a> - A double linked list.</li>
<li><a class="el" href="tommyarray_8h.html#a0f2ab5f891aee3ba7aae019ac74cb5eb" title="Array container type.">tommy_array</a>, <a class="el" href="tommyarrayof_8h.html#a265cf9d9d06c31d6835a3a2d4e2b70a8" title="Array container type.">tommy_arrayof</a> - A linear array. It doesn't fragment the heap.</li>
<li><a class="el" href="tommyarrayblk_8h.html#a773ff562ec3bdc01196b5bb3fdf4adbf" title="Array container type.">tommy_arrayblk</a>, <a class="el" href="tommyarrayblkof_8h.html#abee2c871ff786fd2d0e8df1496b24e4d" title="Array container type.">tommy_arrayblkof</a> - A blocked linear array. It doesn't fragment the heap and it minimizes the space occupation.</li>
<li><a class="el" href="tommyhashtbl_8h.html#a506978bdee7fd24f76a0ba7547206513" title="Hashtable container type.">tommy_hashtable</a> - A fixed size chained hashtable.</li>
<li><a class="el" href="tommyhashdyn_8h.html#a00c8b944d273f38f9eef91417a1e8991" title="Hashtable container type.">tommy_hashdyn</a> - A dynamic chained hashtable.</li>
<li><a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904" title="Hashtable container type.">tommy_hashlin</a> - A linear chained hashtable. It doesn't have the problem of the delay when resizing and it doesn't fragment the heap.</li>
<li><a class="el" href="tommytrie_8h.html#a05c17b0ace098768808aa9effcaa9559" title="Trie container type.">tommy_trie</a> - A trie optimized for cache utilization.</li>
<li><a class="el" href="tommytrieinp_8h.html#aa375bb131f3d221a24774aef08b27a0a" title="Trie container type.">tommy_trie_inplace</a> - A trie completely inplace.</li>
<li><a class="el" href="tommytree_8h.html#adc6c9a39a18bbcffc29f045e15206b65" title="Tree container type.">tommy_tree</a> - A tree to keep elements in order.</li>
</ul>
<p>The most interesting are <a class="el" href="tommyarray_8h.html#a0f2ab5f891aee3ba7aae019ac74cb5eb" title="Array container type.">tommy_array</a>, <a class="el" href="tommyhashdyn_8h.html#a00c8b944d273f38f9eef91417a1e8991" title="Hashtable container type.">tommy_hashdyn</a>, <a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904" title="Hashtable container type.">tommy_hashlin</a>, <a class="el" href="tommytrie_8h.html#a05c17b0ace098768808aa9effcaa9559" title="Trie container type.">tommy_trie</a> and <a class="el" href="tommytrieinp_8h.html#aa375bb131f3d221a24774aef08b27a0a" title="Trie container type.">tommy_trie_inplace</a>.</p>
<p>The official site of TommyDS is <a href="http://www.tommyds.it/">http://www.tommyds.it/</a>,</p>
<h2><a class="anchor" id="Use"></a>
Use</h2>
<p>All the Tommy containers are used to store pointers to generic objects, associated to an integer value, that could be a key or a hash value.</p>
<p>They are semantically equivalent at the C++ <a href="http://www.cplusplus.com/reference/map/multimap/">multimap&lt;unsigned,void*&gt;</a> and <a href="http://www.cplusplus.com/reference/unordered_map/unordered_multimap/">unordered_multimap&lt;unsigned,void*&gt;</a>.</p>
<p>An object, to be inserted in a container, should contain a node of type <a class="el" href="tommytypes_8h.html#a56a5b6211015e83fd69c4f990ac5612b" title="Data structure node.">tommy_node</a>. Inside this node is present a pointer to the object itself in the <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer to the object containing the node.">tommy_node::data</a> field, the key used to identify the object in the <a class="el" href="structtommy__node__struct.html#a124aaecab9e5d3d1fbb9239dac779d23" title="Key used to store the node.">tommy_node::key</a> field, and other fields used by the containers.</p>
<p>This is a typical object declaration: </p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>object {
     <span class="comment">// other fields</span>
     <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_node</a> node;
 };
</pre></div><p>To insert an object in a container, you have to provide the address of the embedded node, the address of the object and the value of the key. </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> key_to_insert = 1;
 <span class="keyword">struct </span>object* obj = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="keywordtype">object</span>));
 ...
 <a class="code" href="tommytrie_8h.html#a7f48a4942d6b607c24b7236ab257b7d7" title="Inserts an element in the trie.">tommy_trie_insert</a>(..., &amp;obj-&gt;node, obj, key_to_insert);
</pre></div><p>To search an object you have to provide the key and call the search function. </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> key_to_find = 1;
 <span class="keyword">struct </span>object* obj = <a class="code" href="tommytrie_8h.html#a1170abedabdc9d919db8728d238c50db" title="Searches an element in the trie.">tommy_trie_search</a>(..., key_to_find);
 <span class="keywordflow">if</span> (obj) {
   <span class="comment">// found</span>
 }
</pre></div><p>To access all the objects with the same keys you have to iterate over the bucket assigned at the specified key. </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> key_to_find = 1;
 <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_trie_node</a>* i = <a class="code" href="tommytrie_8h.html#a0ab11f26139ff2a1d405ace4a1af0e6a" title="Gets the bucket of the specified key.">tommy_trie_bucket</a>(..., key_to_find);

 <span class="keywordflow">while</span> (i) {
     <span class="keyword">struct </span>object* obj = i-&gt;<a class="code" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer to the object containing the node.">data</a>; <span class="comment">// gets the object pointer</span>

     printf(<span class="stringliteral">&quot;%d\n&quot;</span>, obj-&gt;value); <span class="comment">// process the object</span>

     i = i-&gt;<a class="code" href="structtommy__node__struct.html#a53338f3f5366866598ed9ac7e46e64a2" title="Next node.">next</a>; <span class="comment">// goes to the next element</span>
 }
</pre></div><p>To remove an object you have to provide the key and call the remove function. </p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> key_to_remove = 1;
 <span class="keyword">struct </span>object* obj = <a class="code" href="tommytrie_8h.html#a47ed46af4087783c351172280d03ed6b" title="Searches and removes the first element with the specified key.">tommy_trie_remove</a>(..., key_to_remove);
 <span class="keywordflow">if</span> (obj) {
     <span class="comment">// found</span>
     free(obj); <span class="comment">// frees the object allocated memory</span>
 }
</pre></div><p>Dealing with hashtables, instead of the key, you have to provide the hash value of the object, and a compare function able to differentiate objects with the same hash value. To compute the hash value, you can use the generic <a class="el" href="tommyhash_8h.html#ab020046d7799cda5b440bd49b4e282d8" title="Hash function with a 32 bits result.">tommy_hash_u32()</a> function, or the specialized integer hash function <a class="el" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71" title="Integer reversible hash function for 32 bits.">tommy_inthash_u32()</a>.</p>
<h2><a class="anchor" id="Features"></a>
Features</h2>
<p>Tommy is fast and easy to use.</p>
<p>Tommy is portable to all platforms and operating systems.</p>
<p>Tommy containers support multiple elements with the same key.</p>
<p>Tommy containers keep the original insertion order of elements with equal keys.</p>
<p>Tommy is released with the <a class="el" href="license.html">2-clause BSD license</a>.</p>
<p>See the <a class="el" href="design.html">Tommy Design</a> page for more details and limitations.</p>
<h2><a class="anchor" id="Performance"></a>
Performance</h2>
<p>Here you can see some timings comparing with other notable implementations. The <em>Hit</em> graph shows the time required for searching random objects with a key. The <em>Change</em> graph shows the time required for searching, removing and reinsert random objects with a different key value.</p>
<p>Times are expressed in nanoseconds for each element, and <b>lower is better</b>.</p>
<p>To have some reference numbers, you can check <a href="https://gist.github.com/jboner/2841832">Latency numbers every programmer should know</a>.</p>
<p>A complete analysis is available in the <a class="el" href="benchmark.html">Tommy Benchmarks</a> page.</p>
<div align="center">
<img src="def/img_random_hit.png" alt="img_random_hit.png"/>
</div>
<div align="center">
<img src="def/img_random_change.png" alt="img_random_change.png"/>
</div>
 </div></div>
</body>
</html>
