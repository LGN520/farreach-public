#
# Autogenerated by Thrift Compiler (0.9.2)
#
# DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
#
#  options string: py
#

from thrift.Thrift import TType, TMessageType, TException, TApplicationException
import res_pd_rpc.ttypes


from thrift.transport import TTransport
from thrift.protocol import TBinaryProtocol, TProtocol
try:
  from thrift.protocol import fastbinary
except:
  fastbinary = None


class netbufferv4_lpf_type:
  TYPE_RATE = 0
  TYPE_SAMPLE = 1

  _VALUES_TO_NAMES = {
    0: "TYPE_RATE",
    1: "TYPE_SAMPLE",
  }

  _NAMES_TO_VALUES = {
    "TYPE_RATE": 0,
    "TYPE_SAMPLE": 1,
  }

class netbufferv4_idle_time_mode:
  POLL_MODE = 0
  NOTIFY_MODE = 1
  INVALID_MODE = 2

  _VALUES_TO_NAMES = {
    0: "POLL_MODE",
    1: "NOTIFY_MODE",
    2: "INVALID_MODE",
  }

  _NAMES_TO_VALUES = {
    "POLL_MODE": 0,
    "NOTIFY_MODE": 1,
    "INVALID_MODE": 2,
  }

class netbufferv4_idle_time_hit_state:
  ENTRY_IDLE = 0
  ENTRY_ACTIVE = 1

  _VALUES_TO_NAMES = {
    0: "ENTRY_IDLE",
    1: "ENTRY_ACTIVE",
  }

  _NAMES_TO_VALUES = {
    "ENTRY_IDLE": 0,
    "ENTRY_ACTIVE": 1,
  }

class netbufferv4_grp_mbr_state:
  MBR_ACTIVE = 0
  MBR_INACTIVE = 1

  _VALUES_TO_NAMES = {
    0: "MBR_ACTIVE",
    1: "MBR_INACTIVE",
  }

  _NAMES_TO_VALUES = {
    "MBR_ACTIVE": 0,
    "MBR_INACTIVE": 1,
  }

class tbl_property_t:
  TBL_PROP_TBL_ENTRY_SCOPE = 1
  TBL_PROP_TERN_TABLE_ENTRY_PLACEMENT = 2
  TBL_PROP_DUPLICATE_ENTRY_CHECK = 3
  TBL_PROP_IDLETIME_REPEATED_NOTIFICATION = 4

  _VALUES_TO_NAMES = {
    1: "TBL_PROP_TBL_ENTRY_SCOPE",
    2: "TBL_PROP_TERN_TABLE_ENTRY_PLACEMENT",
    3: "TBL_PROP_DUPLICATE_ENTRY_CHECK",
    4: "TBL_PROP_IDLETIME_REPEATED_NOTIFICATION",
  }

  _NAMES_TO_VALUES = {
    "TBL_PROP_TBL_ENTRY_SCOPE": 1,
    "TBL_PROP_TERN_TABLE_ENTRY_PLACEMENT": 2,
    "TBL_PROP_DUPLICATE_ENTRY_CHECK": 3,
    "TBL_PROP_IDLETIME_REPEATED_NOTIFICATION": 4,
  }

class tbl_property_value_t:
  ENTRY_SCOPE_ALL_PIPELINES = 0
  ENTRY_SCOPE_SINGLE_PIPELINE = 1
  ENTRY_SCOPE_USER_DEFINED = 2
  TERN_ENTRY_PLACEMENT_DRV_MANAGED = 0
  TERN_ENTRY_PLACEMENT_APP_MANAGED = 1
  DUPLICATE_ENTRY_CHECK_DISABLE = 0
  DUPLICATE_ENTRY_CHECK_ENABLE = 1
  IDLETIME_REPEATED_NOTIFICATION_DISABLE = 0
  IDLETIME_REPEATED_NOTIFICATION_ENABLE = 1

  _VALUES_TO_NAMES = {
    0: "ENTRY_SCOPE_ALL_PIPELINES",
    1: "ENTRY_SCOPE_SINGLE_PIPELINE",
    2: "ENTRY_SCOPE_USER_DEFINED",
    0: "TERN_ENTRY_PLACEMENT_DRV_MANAGED",
    1: "TERN_ENTRY_PLACEMENT_APP_MANAGED",
    0: "DUPLICATE_ENTRY_CHECK_DISABLE",
    1: "DUPLICATE_ENTRY_CHECK_ENABLE",
    0: "IDLETIME_REPEATED_NOTIFICATION_DISABLE",
    1: "IDLETIME_REPEATED_NOTIFICATION_ENABLE",
  }

  _NAMES_TO_VALUES = {
    "ENTRY_SCOPE_ALL_PIPELINES": 0,
    "ENTRY_SCOPE_SINGLE_PIPELINE": 1,
    "ENTRY_SCOPE_USER_DEFINED": 2,
    "TERN_ENTRY_PLACEMENT_DRV_MANAGED": 0,
    "TERN_ENTRY_PLACEMENT_APP_MANAGED": 1,
    "DUPLICATE_ENTRY_CHECK_DISABLE": 0,
    "DUPLICATE_ENTRY_CHECK_ENABLE": 1,
    "IDLETIME_REPEATED_NOTIFICATION_DISABLE": 0,
    "IDLETIME_REPEATED_NOTIFICATION_ENABLE": 1,
  }

class pvs_gress_t:
  PVS_GRESS_INGRESS = 0
  PVS_GRESS_EGRESS = 1
  PVS_GRESS_ALL = 255

  _VALUES_TO_NAMES = {
    0: "PVS_GRESS_INGRESS",
    1: "PVS_GRESS_EGRESS",
    255: "PVS_GRESS_ALL",
  }

  _NAMES_TO_VALUES = {
    "PVS_GRESS_INGRESS": 0,
    "PVS_GRESS_EGRESS": 1,
    "PVS_GRESS_ALL": 255,
  }

class pvs_property_t:
  PVS_PROP_NONE = 0
  PVS_GRESS_SCOPE = 1
  PVS_PIPE_SCOPE = 2
  PVS_PARSER_SCOPE = 3

  _VALUES_TO_NAMES = {
    0: "PVS_PROP_NONE",
    1: "PVS_GRESS_SCOPE",
    2: "PVS_PIPE_SCOPE",
    3: "PVS_PARSER_SCOPE",
  }

  _NAMES_TO_VALUES = {
    "PVS_PROP_NONE": 0,
    "PVS_GRESS_SCOPE": 1,
    "PVS_PIPE_SCOPE": 2,
    "PVS_PARSER_SCOPE": 3,
  }

class pvs_property_value_t:
  PVS_SCOPE_ALL_GRESS = 0
  PVS_SCOPE_SINGLE_GRESS = 1
  PVS_SCOPE_ALL_PIPELINES = 0
  PVS_SCOPE_SINGLE_PIPELINE = 1
  PVS_SCOPE_ALL_PARSERS = 0
  PVS_SCOPE_SINGLE_PARSER = 1

  _VALUES_TO_NAMES = {
    0: "PVS_SCOPE_ALL_GRESS",
    1: "PVS_SCOPE_SINGLE_GRESS",
    0: "PVS_SCOPE_ALL_PIPELINES",
    1: "PVS_SCOPE_SINGLE_PIPELINE",
    0: "PVS_SCOPE_ALL_PARSERS",
    1: "PVS_SCOPE_SINGLE_PARSER",
  }

  _NAMES_TO_VALUES = {
    "PVS_SCOPE_ALL_GRESS": 0,
    "PVS_SCOPE_SINGLE_GRESS": 1,
    "PVS_SCOPE_ALL_PIPELINES": 0,
    "PVS_SCOPE_SINGLE_PIPELINE": 1,
    "PVS_SCOPE_ALL_PARSERS": 0,
    "PVS_SCOPE_SINGLE_PARSER": 1,
  }

class tbl_dbg_counter_type_t:
  TBL_DBG_CNTR_DISABLED = 0
  TBL_DBG_CNTR_LOG_TBL_MISS = 1
  TBL_DBG_CNTR_LOG_TBL_HIT = 2
  TBL_DBG_CNTR_GW_TBL_MISS = 3
  TBL_DBG_CNTR_GW_TBL_HIT = 4
  TBL_DBG_CNTR_GW_TBL_INHIBIT = 5
  TBL_DBG_CNTR_MAX = 6

  _VALUES_TO_NAMES = {
    0: "TBL_DBG_CNTR_DISABLED",
    1: "TBL_DBG_CNTR_LOG_TBL_MISS",
    2: "TBL_DBG_CNTR_LOG_TBL_HIT",
    3: "TBL_DBG_CNTR_GW_TBL_MISS",
    4: "TBL_DBG_CNTR_GW_TBL_HIT",
    5: "TBL_DBG_CNTR_GW_TBL_INHIBIT",
    6: "TBL_DBG_CNTR_MAX",
  }

  _NAMES_TO_VALUES = {
    "TBL_DBG_CNTR_DISABLED": 0,
    "TBL_DBG_CNTR_LOG_TBL_MISS": 1,
    "TBL_DBG_CNTR_LOG_TBL_HIT": 2,
    "TBL_DBG_CNTR_GW_TBL_MISS": 3,
    "TBL_DBG_CNTR_GW_TBL_HIT": 4,
    "TBL_DBG_CNTR_GW_TBL_INHIBIT": 5,
    "TBL_DBG_CNTR_MAX": 6,
  }

class netbufferv4_input_field_attr_type_t:
  INPUT_FIELD_ATTR_TYPE_MASK = 0

  _VALUES_TO_NAMES = {
    0: "INPUT_FIELD_ATTR_TYPE_MASK",
  }

  _NAMES_TO_VALUES = {
    "INPUT_FIELD_ATTR_TYPE_MASK": 0,
  }

class netbufferv4_input_field_attr_value_mask_t:
  INPUT_FIELD_EXCLUDED = 0
  INPUT_FIELD_INCLUDED = 1

  _VALUES_TO_NAMES = {
    0: "INPUT_FIELD_EXCLUDED",
    1: "INPUT_FIELD_INCLUDED",
  }

  _NAMES_TO_VALUES = {
    "INPUT_FIELD_EXCLUDED": 0,
    "INPUT_FIELD_INCLUDED": 1,
  }


class netbufferv4_counter_value_t:
  """
  Attributes:
   - packets
   - bytes
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'packets', None, None, ), # 1
    (2, TType.I64, 'bytes', None, None, ), # 2
  )

  def __init__(self, packets=None, bytes=None,):
    self.packets = packets
    self.bytes = bytes

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.packets = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.bytes = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_counter_value_t')
    if self.packets is not None:
      oprot.writeFieldBegin('packets', TType.I64, 1)
      oprot.writeI64(self.packets)
      oprot.writeFieldEnd()
    if self.bytes is not None:
      oprot.writeFieldBegin('bytes', TType.I64, 2)
      oprot.writeI64(self.bytes)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.packets is None:
      raise TProtocol.TProtocolException(message='Required field packets is unset!')
    if self.bytes is None:
      raise TProtocol.TProtocolException(message='Required field bytes is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.packets)
    value = (value * 31) ^ hash(self.bytes)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_packets_meter_spec_t:
  """
  Attributes:
   - cir_pps
   - cburst_pkts
   - pir_pps
   - pburst_pkts
   - color_aware
   - is_set
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'cir_pps', None, None, ), # 1
    (2, TType.I64, 'cburst_pkts', None, None, ), # 2
    (3, TType.I64, 'pir_pps', None, None, ), # 3
    (4, TType.I64, 'pburst_pkts', None, None, ), # 4
    (5, TType.BOOL, 'color_aware', None, None, ), # 5
    (6, TType.BOOL, 'is_set', None, True, ), # 6
  )

  def __init__(self, cir_pps=None, cburst_pkts=None, pir_pps=None, pburst_pkts=None, color_aware=None, is_set=thrift_spec[6][4],):
    self.cir_pps = cir_pps
    self.cburst_pkts = cburst_pkts
    self.pir_pps = pir_pps
    self.pburst_pkts = pburst_pkts
    self.color_aware = color_aware
    self.is_set = is_set

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.cir_pps = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.cburst_pkts = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.pir_pps = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.pburst_pkts = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.color_aware = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.is_set = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_packets_meter_spec_t')
    if self.cir_pps is not None:
      oprot.writeFieldBegin('cir_pps', TType.I64, 1)
      oprot.writeI64(self.cir_pps)
      oprot.writeFieldEnd()
    if self.cburst_pkts is not None:
      oprot.writeFieldBegin('cburst_pkts', TType.I64, 2)
      oprot.writeI64(self.cburst_pkts)
      oprot.writeFieldEnd()
    if self.pir_pps is not None:
      oprot.writeFieldBegin('pir_pps', TType.I64, 3)
      oprot.writeI64(self.pir_pps)
      oprot.writeFieldEnd()
    if self.pburst_pkts is not None:
      oprot.writeFieldBegin('pburst_pkts', TType.I64, 4)
      oprot.writeI64(self.pburst_pkts)
      oprot.writeFieldEnd()
    if self.color_aware is not None:
      oprot.writeFieldBegin('color_aware', TType.BOOL, 5)
      oprot.writeBool(self.color_aware)
      oprot.writeFieldEnd()
    if self.is_set is not None:
      oprot.writeFieldBegin('is_set', TType.BOOL, 6)
      oprot.writeBool(self.is_set)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.cir_pps is None:
      raise TProtocol.TProtocolException(message='Required field cir_pps is unset!')
    if self.cburst_pkts is None:
      raise TProtocol.TProtocolException(message='Required field cburst_pkts is unset!')
    if self.pir_pps is None:
      raise TProtocol.TProtocolException(message='Required field pir_pps is unset!')
    if self.pburst_pkts is None:
      raise TProtocol.TProtocolException(message='Required field pburst_pkts is unset!')
    if self.color_aware is None:
      raise TProtocol.TProtocolException(message='Required field color_aware is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cir_pps)
    value = (value * 31) ^ hash(self.cburst_pkts)
    value = (value * 31) ^ hash(self.pir_pps)
    value = (value * 31) ^ hash(self.pburst_pkts)
    value = (value * 31) ^ hash(self.color_aware)
    value = (value * 31) ^ hash(self.is_set)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_bytes_meter_spec_t:
  """
  Attributes:
   - cir_kbps
   - cburst_kbits
   - pir_kbps
   - pburst_kbits
   - color_aware
   - is_set
  """

  thrift_spec = (
    None, # 0
    (1, TType.I64, 'cir_kbps', None, None, ), # 1
    (2, TType.I64, 'cburst_kbits', None, None, ), # 2
    (3, TType.I64, 'pir_kbps', None, None, ), # 3
    (4, TType.I64, 'pburst_kbits', None, None, ), # 4
    (5, TType.BOOL, 'color_aware', None, None, ), # 5
    (6, TType.BOOL, 'is_set', None, True, ), # 6
  )

  def __init__(self, cir_kbps=None, cburst_kbits=None, pir_kbps=None, pburst_kbits=None, color_aware=None, is_set=thrift_spec[6][4],):
    self.cir_kbps = cir_kbps
    self.cburst_kbits = cburst_kbits
    self.pir_kbps = pir_kbps
    self.pburst_kbits = pburst_kbits
    self.color_aware = color_aware
    self.is_set = is_set

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I64:
          self.cir_kbps = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.cburst_kbits = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.pir_kbps = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I64:
          self.pburst_kbits = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.color_aware = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BOOL:
          self.is_set = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_bytes_meter_spec_t')
    if self.cir_kbps is not None:
      oprot.writeFieldBegin('cir_kbps', TType.I64, 1)
      oprot.writeI64(self.cir_kbps)
      oprot.writeFieldEnd()
    if self.cburst_kbits is not None:
      oprot.writeFieldBegin('cburst_kbits', TType.I64, 2)
      oprot.writeI64(self.cburst_kbits)
      oprot.writeFieldEnd()
    if self.pir_kbps is not None:
      oprot.writeFieldBegin('pir_kbps', TType.I64, 3)
      oprot.writeI64(self.pir_kbps)
      oprot.writeFieldEnd()
    if self.pburst_kbits is not None:
      oprot.writeFieldBegin('pburst_kbits', TType.I64, 4)
      oprot.writeI64(self.pburst_kbits)
      oprot.writeFieldEnd()
    if self.color_aware is not None:
      oprot.writeFieldBegin('color_aware', TType.BOOL, 5)
      oprot.writeBool(self.color_aware)
      oprot.writeFieldEnd()
    if self.is_set is not None:
      oprot.writeFieldBegin('is_set', TType.BOOL, 6)
      oprot.writeBool(self.is_set)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.cir_kbps is None:
      raise TProtocol.TProtocolException(message='Required field cir_kbps is unset!')
    if self.cburst_kbits is None:
      raise TProtocol.TProtocolException(message='Required field cburst_kbits is unset!')
    if self.pir_kbps is None:
      raise TProtocol.TProtocolException(message='Required field pir_kbps is unset!')
    if self.pburst_kbits is None:
      raise TProtocol.TProtocolException(message='Required field pburst_kbits is unset!')
    if self.color_aware is None:
      raise TProtocol.TProtocolException(message='Required field color_aware is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.cir_kbps)
    value = (value * 31) ^ hash(self.cburst_kbits)
    value = (value * 31) ^ hash(self.pir_kbps)
    value = (value * 31) ^ hash(self.pburst_kbits)
    value = (value * 31) ^ hash(self.color_aware)
    value = (value * 31) ^ hash(self.is_set)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_lpf_spec_t:
  """
  Attributes:
   - gain_decay_separate_time_constant
   - gain_time_constant
   - decay_time_constant
   - time_constant
   - output_scale_down_factor
   - lpf_type
   - is_set
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'gain_decay_separate_time_constant', None, None, ), # 1
    (2, TType.DOUBLE, 'gain_time_constant', None, None, ), # 2
    (3, TType.DOUBLE, 'decay_time_constant', None, None, ), # 3
    (4, TType.DOUBLE, 'time_constant', None, None, ), # 4
    (5, TType.I32, 'output_scale_down_factor', None, None, ), # 5
    (6, TType.I32, 'lpf_type', None, None, ), # 6
    (7, TType.BOOL, 'is_set', None, True, ), # 7
  )

  def __init__(self, gain_decay_separate_time_constant=None, gain_time_constant=None, decay_time_constant=None, time_constant=None, output_scale_down_factor=None, lpf_type=None, is_set=thrift_spec[7][4],):
    self.gain_decay_separate_time_constant = gain_decay_separate_time_constant
    self.gain_time_constant = gain_time_constant
    self.decay_time_constant = decay_time_constant
    self.time_constant = time_constant
    self.output_scale_down_factor = output_scale_down_factor
    self.lpf_type = lpf_type
    self.is_set = is_set

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.gain_decay_separate_time_constant = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.DOUBLE:
          self.gain_time_constant = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.DOUBLE:
          self.decay_time_constant = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.time_constant = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.output_scale_down_factor = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.lpf_type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.is_set = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_lpf_spec_t')
    if self.gain_decay_separate_time_constant is not None:
      oprot.writeFieldBegin('gain_decay_separate_time_constant', TType.BOOL, 1)
      oprot.writeBool(self.gain_decay_separate_time_constant)
      oprot.writeFieldEnd()
    if self.gain_time_constant is not None:
      oprot.writeFieldBegin('gain_time_constant', TType.DOUBLE, 2)
      oprot.writeDouble(self.gain_time_constant)
      oprot.writeFieldEnd()
    if self.decay_time_constant is not None:
      oprot.writeFieldBegin('decay_time_constant', TType.DOUBLE, 3)
      oprot.writeDouble(self.decay_time_constant)
      oprot.writeFieldEnd()
    if self.time_constant is not None:
      oprot.writeFieldBegin('time_constant', TType.DOUBLE, 4)
      oprot.writeDouble(self.time_constant)
      oprot.writeFieldEnd()
    if self.output_scale_down_factor is not None:
      oprot.writeFieldBegin('output_scale_down_factor', TType.I32, 5)
      oprot.writeI32(self.output_scale_down_factor)
      oprot.writeFieldEnd()
    if self.lpf_type is not None:
      oprot.writeFieldBegin('lpf_type', TType.I32, 6)
      oprot.writeI32(self.lpf_type)
      oprot.writeFieldEnd()
    if self.is_set is not None:
      oprot.writeFieldBegin('is_set', TType.BOOL, 7)
      oprot.writeBool(self.is_set)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.gain_decay_separate_time_constant is None:
      raise TProtocol.TProtocolException(message='Required field gain_decay_separate_time_constant is unset!')
    if self.gain_time_constant is None:
      raise TProtocol.TProtocolException(message='Required field gain_time_constant is unset!')
    if self.decay_time_constant is None:
      raise TProtocol.TProtocolException(message='Required field decay_time_constant is unset!')
    if self.time_constant is None:
      raise TProtocol.TProtocolException(message='Required field time_constant is unset!')
    if self.output_scale_down_factor is None:
      raise TProtocol.TProtocolException(message='Required field output_scale_down_factor is unset!')
    if self.lpf_type is None:
      raise TProtocol.TProtocolException(message='Required field lpf_type is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.gain_decay_separate_time_constant)
    value = (value * 31) ^ hash(self.gain_time_constant)
    value = (value * 31) ^ hash(self.decay_time_constant)
    value = (value * 31) ^ hash(self.time_constant)
    value = (value * 31) ^ hash(self.output_scale_down_factor)
    value = (value * 31) ^ hash(self.lpf_type)
    value = (value * 31) ^ hash(self.is_set)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_wred_spec_t:
  """
  Attributes:
   - time_constant
   - red_min_threshold
   - red_max_threshold
   - max_probability
   - is_set
  """

  thrift_spec = (
    None, # 0
    (1, TType.DOUBLE, 'time_constant', None, None, ), # 1
    (2, TType.I32, 'red_min_threshold', None, None, ), # 2
    (3, TType.I32, 'red_max_threshold', None, None, ), # 3
    (4, TType.DOUBLE, 'max_probability', None, None, ), # 4
    (5, TType.BOOL, 'is_set', None, True, ), # 5
  )

  def __init__(self, time_constant=None, red_min_threshold=None, red_max_threshold=None, max_probability=None, is_set=thrift_spec[5][4],):
    self.time_constant = time_constant
    self.red_min_threshold = red_min_threshold
    self.red_max_threshold = red_max_threshold
    self.max_probability = max_probability
    self.is_set = is_set

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.DOUBLE:
          self.time_constant = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.red_min_threshold = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.red_max_threshold = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.DOUBLE:
          self.max_probability = iprot.readDouble();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BOOL:
          self.is_set = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_wred_spec_t')
    if self.time_constant is not None:
      oprot.writeFieldBegin('time_constant', TType.DOUBLE, 1)
      oprot.writeDouble(self.time_constant)
      oprot.writeFieldEnd()
    if self.red_min_threshold is not None:
      oprot.writeFieldBegin('red_min_threshold', TType.I32, 2)
      oprot.writeI32(self.red_min_threshold)
      oprot.writeFieldEnd()
    if self.red_max_threshold is not None:
      oprot.writeFieldBegin('red_max_threshold', TType.I32, 3)
      oprot.writeI32(self.red_max_threshold)
      oprot.writeFieldEnd()
    if self.max_probability is not None:
      oprot.writeFieldBegin('max_probability', TType.DOUBLE, 4)
      oprot.writeDouble(self.max_probability)
      oprot.writeFieldEnd()
    if self.is_set is not None:
      oprot.writeFieldBegin('is_set', TType.BOOL, 5)
      oprot.writeBool(self.is_set)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.time_constant is None:
      raise TProtocol.TProtocolException(message='Required field time_constant is unset!')
    if self.red_min_threshold is None:
      raise TProtocol.TProtocolException(message='Required field red_min_threshold is unset!')
    if self.red_max_threshold is None:
      raise TProtocol.TProtocolException(message='Required field red_max_threshold is unset!')
    if self.max_probability is None:
      raise TProtocol.TProtocolException(message='Required field max_probability is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.time_constant)
    value = (value * 31) ^ hash(self.red_min_threshold)
    value = (value * 31) ^ hash(self.red_max_threshold)
    value = (value * 31) ^ hash(self.max_probability)
    value = (value * 31) ^ hash(self.is_set)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_idle_time_params_t:
  """
  Attributes:
   - mode
   - ttl_query_interval
   - max_ttl
   - min_ttl
   - cookie
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'mode', None, None, ), # 1
    (2, TType.I32, 'ttl_query_interval', None, None, ), # 2
    (3, TType.I32, 'max_ttl', None, None, ), # 3
    (4, TType.I32, 'min_ttl', None, None, ), # 4
    (5, TType.I32, 'cookie', None, None, ), # 5
  )

  def __init__(self, mode=None, ttl_query_interval=None, max_ttl=None, min_ttl=None, cookie=None,):
    self.mode = mode
    self.ttl_query_interval = ttl_query_interval
    self.max_ttl = max_ttl
    self.min_ttl = min_ttl
    self.cookie = cookie

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.mode = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ttl_query_interval = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.max_ttl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.min_ttl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.cookie = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_idle_time_params_t')
    if self.mode is not None:
      oprot.writeFieldBegin('mode', TType.I32, 1)
      oprot.writeI32(self.mode)
      oprot.writeFieldEnd()
    if self.ttl_query_interval is not None:
      oprot.writeFieldBegin('ttl_query_interval', TType.I32, 2)
      oprot.writeI32(self.ttl_query_interval)
      oprot.writeFieldEnd()
    if self.max_ttl is not None:
      oprot.writeFieldBegin('max_ttl', TType.I32, 3)
      oprot.writeI32(self.max_ttl)
      oprot.writeFieldEnd()
    if self.min_ttl is not None:
      oprot.writeFieldBegin('min_ttl', TType.I32, 4)
      oprot.writeI32(self.min_ttl)
      oprot.writeFieldEnd()
    if self.cookie is not None:
      oprot.writeFieldBegin('cookie', TType.I32, 5)
      oprot.writeI32(self.cookie)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.mode is None:
      raise TProtocol.TProtocolException(message='Required field mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.mode)
    value = (value * 31) ^ hash(self.ttl_query_interval)
    value = (value * 31) ^ hash(self.max_ttl)
    value = (value * 31) ^ hash(self.min_ttl)
    value = (value * 31) ^ hash(self.cookie)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_idle_tmo_expired_t:
  """
  Attributes:
   - dev_id
   - entry
   - cookie
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'dev_id', None, None, ), # 1
    (2, TType.I32, 'entry', None, None, ), # 2
    (3, TType.I32, 'cookie', None, None, ), # 3
  )

  def __init__(self, dev_id=None, entry=None, cookie=None,):
    self.dev_id = dev_id
    self.entry = entry
    self.cookie = cookie

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.dev_id = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.entry = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cookie = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_idle_tmo_expired_t')
    if self.dev_id is not None:
      oprot.writeFieldBegin('dev_id', TType.I32, 1)
      oprot.writeI32(self.dev_id)
      oprot.writeFieldEnd()
    if self.entry is not None:
      oprot.writeFieldBegin('entry', TType.I32, 2)
      oprot.writeI32(self.entry)
      oprot.writeFieldEnd()
    if self.cookie is not None:
      oprot.writeFieldBegin('cookie', TType.I32, 3)
      oprot.writeI32(self.cookie)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.dev_id is None:
      raise TProtocol.TProtocolException(message='Required field dev_id is unset!')
    if self.entry is None:
      raise TProtocol.TProtocolException(message='Required field entry is unset!')
    if self.cookie is None:
      raise TProtocol.TProtocolException(message='Required field cookie is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.dev_id)
    value = (value * 31) ^ hash(self.entry)
    value = (value * 31) ^ hash(self.cookie)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_sel_update_t:
  """
  Attributes:
   - sess_hdl
   - dev_tgt
   - cookie
   - grp_hdl
   - mbr_hdl
   - index
   - is_add
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'sess_hdl', None, None, ), # 1
    (2, TType.STRUCT, 'dev_tgt', (res_pd_rpc.ttypes.DevTarget_t, res_pd_rpc.ttypes.DevTarget_t.thrift_spec), None, ), # 2
    (3, TType.I32, 'cookie', None, None, ), # 3
    (4, TType.I32, 'grp_hdl', None, None, ), # 4
    (5, TType.I32, 'mbr_hdl', None, None, ), # 5
    (6, TType.I32, 'index', None, None, ), # 6
    (7, TType.BOOL, 'is_add', None, None, ), # 7
  )

  def __init__(self, sess_hdl=None, dev_tgt=None, cookie=None, grp_hdl=None, mbr_hdl=None, index=None, is_add=None,):
    self.sess_hdl = sess_hdl
    self.dev_tgt = dev_tgt
    self.cookie = cookie
    self.grp_hdl = grp_hdl
    self.mbr_hdl = mbr_hdl
    self.index = index
    self.is_add = is_add

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.sess_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.dev_tgt = res_pd_rpc.ttypes.DevTarget_t()
          self.dev_tgt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.cookie = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.index = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.BOOL:
          self.is_add = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_sel_update_t')
    if self.sess_hdl is not None:
      oprot.writeFieldBegin('sess_hdl', TType.I32, 1)
      oprot.writeI32(self.sess_hdl)
      oprot.writeFieldEnd()
    if self.dev_tgt is not None:
      oprot.writeFieldBegin('dev_tgt', TType.STRUCT, 2)
      self.dev_tgt.write(oprot)
      oprot.writeFieldEnd()
    if self.cookie is not None:
      oprot.writeFieldBegin('cookie', TType.I32, 3)
      oprot.writeI32(self.cookie)
      oprot.writeFieldEnd()
    if self.grp_hdl is not None:
      oprot.writeFieldBegin('grp_hdl', TType.I32, 4)
      oprot.writeI32(self.grp_hdl)
      oprot.writeFieldEnd()
    if self.mbr_hdl is not None:
      oprot.writeFieldBegin('mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.mbr_hdl)
      oprot.writeFieldEnd()
    if self.index is not None:
      oprot.writeFieldBegin('index', TType.I32, 6)
      oprot.writeI32(self.index)
      oprot.writeFieldEnd()
    if self.is_add is not None:
      oprot.writeFieldBegin('is_add', TType.BOOL, 7)
      oprot.writeBool(self.is_add)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.sess_hdl is None:
      raise TProtocol.TProtocolException(message='Required field sess_hdl is unset!')
    if self.dev_tgt is None:
      raise TProtocol.TProtocolException(message='Required field dev_tgt is unset!')
    if self.cookie is None:
      raise TProtocol.TProtocolException(message='Required field cookie is unset!')
    if self.grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field grp_hdl is unset!')
    if self.mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field mbr_hdl is unset!')
    if self.index is None:
      raise TProtocol.TProtocolException(message='Required field index is unset!')
    if self.is_add is None:
      raise TProtocol.TProtocolException(message='Required field is_add is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.sess_hdl)
    value = (value * 31) ^ hash(self.dev_tgt)
    value = (value * 31) ^ hash(self.cookie)
    value = (value * 31) ^ hash(self.grp_hdl)
    value = (value * 31) ^ hash(self.mbr_hdl)
    value = (value * 31) ^ hash(self.index)
    value = (value * 31) ^ hash(self.is_add)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class tbl_property_value_args_t:
  """
  Attributes:
   - value
   - scope_args
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'value', None, None, ), # 1
    (2, TType.I32, 'scope_args', None, None, ), # 2
  )

  def __init__(self, value=None, scope_args=None,):
    self.value = value
    self.scope_args = scope_args

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.scope_args = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('tbl_property_value_args_t')
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 1)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    if self.scope_args is not None:
      oprot.writeFieldBegin('scope_args', TType.I32, 2)
      oprot.writeI32(self.scope_args)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.value is None:
      raise TProtocol.TProtocolException(message='Required field value is unset!')
    if self.scope_args is None:
      raise TProtocol.TProtocolException(message='Required field scope_args is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.value)
    value = (value * 31) ^ hash(self.scope_args)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class PVSSpec_t:
  """
  Attributes:
   - parser_value
   - parser_value_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'parser_value', None, None, ), # 1
    (2, TType.I32, 'parser_value_mask', None, None, ), # 2
  )

  def __init__(self, parser_value=None, parser_value_mask=None,):
    self.parser_value = parser_value
    self.parser_value_mask = parser_value_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.parser_value = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.parser_value_mask = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('PVSSpec_t')
    if self.parser_value is not None:
      oprot.writeFieldBegin('parser_value', TType.I32, 1)
      oprot.writeI32(self.parser_value)
      oprot.writeFieldEnd()
    if self.parser_value_mask is not None:
      oprot.writeFieldBegin('parser_value_mask', TType.I32, 2)
      oprot.writeI32(self.parser_value_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.parser_value is None:
      raise TProtocol.TProtocolException(message='Required field parser_value is unset!')
    if self.parser_value_mask is None:
      raise TProtocol.TProtocolException(message='Required field parser_value_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.parser_value)
    value = (value * 31) ^ hash(self.parser_value_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TblCntrInfo_t:
  """
  Attributes:
   - type
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'type', None, None, ), # 1
    (2, TType.I32, 'value', None, None, ), # 2
  )

  def __init__(self, type=None, value=None,):
    self.type = type
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.type = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.value = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TblCntrInfo_t')
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.I32, 1)
      oprot.writeI32(self.type)
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.I32, 2)
      oprot.writeI32(self.value)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    if self.value is None:
      raise TProtocol.TProtocolException(message='Required field value is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class TblDbgStageInfo_t:
  """
  Attributes:
   - num_counters
   - tbl_name
   - type
   - value
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'num_counters', None, None, ), # 1
    (2, TType.LIST, 'tbl_name', (TType.STRING,None), None, ), # 2
    (3, TType.LIST, 'type', (TType.I32,None), None, ), # 3
    (4, TType.LIST, 'value', (TType.I32,None), None, ), # 4
  )

  def __init__(self, num_counters=None, tbl_name=None, type=None, value=None,):
    self.num_counters = num_counters
    self.tbl_name = tbl_name
    self.type = type
    self.value = value

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.num_counters = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.LIST:
          self.tbl_name = []
          (_etype3, _size0) = iprot.readListBegin()
          for _i4 in xrange(_size0):
            _elem5 = iprot.readString();
            self.tbl_name.append(_elem5)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.LIST:
          self.type = []
          (_etype9, _size6) = iprot.readListBegin()
          for _i10 in xrange(_size6):
            _elem11 = iprot.readI32();
            self.type.append(_elem11)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.LIST:
          self.value = []
          (_etype15, _size12) = iprot.readListBegin()
          for _i16 in xrange(_size12):
            _elem17 = iprot.readI32();
            self.value.append(_elem17)
          iprot.readListEnd()
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('TblDbgStageInfo_t')
    if self.num_counters is not None:
      oprot.writeFieldBegin('num_counters', TType.I32, 1)
      oprot.writeI32(self.num_counters)
      oprot.writeFieldEnd()
    if self.tbl_name is not None:
      oprot.writeFieldBegin('tbl_name', TType.LIST, 2)
      oprot.writeListBegin(TType.STRING, len(self.tbl_name))
      for iter18 in self.tbl_name:
        oprot.writeString(iter18)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.type is not None:
      oprot.writeFieldBegin('type', TType.LIST, 3)
      oprot.writeListBegin(TType.I32, len(self.type))
      for iter19 in self.type:
        oprot.writeI32(iter19)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    if self.value is not None:
      oprot.writeFieldBegin('value', TType.LIST, 4)
      oprot.writeListBegin(TType.I32, len(self.value))
      for iter20 in self.value:
        oprot.writeI32(iter20)
      oprot.writeListEnd()
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.num_counters is None:
      raise TProtocol.TProtocolException(message='Required field num_counters is unset!')
    if self.tbl_name is None:
      raise TProtocol.TProtocolException(message='Required field tbl_name is unset!')
    if self.type is None:
      raise TProtocol.TProtocolException(message='Required field type is unset!')
    if self.value is None:
      raise TProtocol.TProtocolException(message='Required field value is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.num_counters)
    value = (value * 31) ^ hash(self.tbl_name)
    value = (value * 31) ^ hash(self.type)
    value = (value * 31) ^ hash(self.value)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_counter_flags_t:
  """
  Attributes:
   - read_hw_sync
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'read_hw_sync', None, None, ), # 1
  )

  def __init__(self, read_hw_sync=None,):
    self.read_hw_sync = read_hw_sync

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.read_hw_sync = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_counter_flags_t')
    if self.read_hw_sync is not None:
      oprot.writeFieldBegin('read_hw_sync', TType.BOOL, 1)
      oprot.writeBool(self.read_hw_sync)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.read_hw_sync is None:
      raise TProtocol.TProtocolException(message='Required field read_hw_sync is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.read_hw_sync)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_register_flags_t:
  """
  Attributes:
   - read_hw_sync
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'read_hw_sync', None, None, ), # 1
  )

  def __init__(self, read_hw_sync=None,):
    self.read_hw_sync = read_hw_sync

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.read_hw_sync = iprot.readBool();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_register_flags_t')
    if self.read_hw_sync is not None:
      oprot.writeFieldBegin('read_hw_sync', TType.BOOL, 1)
      oprot.writeBool(self.read_hw_sync)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.read_hw_sync is None:
      raise TProtocol.TProtocolException(message='Required field read_hw_sync is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.read_hw_sync)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_snapshot_trig_spec_t:
  """
  Attributes:
   - field_name
   - field_value
   - field_mask
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'field_name', None, None, ), # 1
    (2, TType.I64, 'field_value', None, None, ), # 2
    (3, TType.I64, 'field_mask', None, None, ), # 3
  )

  def __init__(self, field_name=None, field_value=None, field_mask=None,):
    self.field_name = field_name
    self.field_value = field_value
    self.field_mask = field_mask

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.field_name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I64:
          self.field_value = iprot.readI64();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I64:
          self.field_mask = iprot.readI64();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_snapshot_trig_spec_t')
    if self.field_name is not None:
      oprot.writeFieldBegin('field_name', TType.STRING, 1)
      oprot.writeString(self.field_name)
      oprot.writeFieldEnd()
    if self.field_value is not None:
      oprot.writeFieldBegin('field_value', TType.I64, 2)
      oprot.writeI64(self.field_value)
      oprot.writeFieldEnd()
    if self.field_mask is not None:
      oprot.writeFieldBegin('field_mask', TType.I64, 3)
      oprot.writeI64(self.field_mask)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.field_name is None:
      raise TProtocol.TProtocolException(message='Required field field_name is unset!')
    if self.field_value is None:
      raise TProtocol.TProtocolException(message='Required field field_value is unset!')
    if self.field_mask is None:
      raise TProtocol.TProtocolException(message='Required field field_mask is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.field_name)
    value = (value * 31) ^ hash(self.field_value)
    value = (value * 31) ^ hash(self.field_mask)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_snapshot_tbl_data_t:
  """
  Attributes:
   - hit
   - inhibited
   - executed
   - hit_entry_handle
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'hit', None, None, ), # 1
    (2, TType.BOOL, 'inhibited', None, None, ), # 2
    (3, TType.BOOL, 'executed', None, None, ), # 3
    (4, TType.I32, 'hit_entry_handle', None, None, ), # 4
  )

  def __init__(self, hit=None, inhibited=None, executed=None, hit_entry_handle=None,):
    self.hit = hit
    self.inhibited = inhibited
    self.executed = executed
    self.hit_entry_handle = hit_entry_handle

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.hit = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.inhibited = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.executed = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.hit_entry_handle = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_snapshot_tbl_data_t')
    if self.hit is not None:
      oprot.writeFieldBegin('hit', TType.BOOL, 1)
      oprot.writeBool(self.hit)
      oprot.writeFieldEnd()
    if self.inhibited is not None:
      oprot.writeFieldBegin('inhibited', TType.BOOL, 2)
      oprot.writeBool(self.inhibited)
      oprot.writeFieldEnd()
    if self.executed is not None:
      oprot.writeFieldBegin('executed', TType.BOOL, 3)
      oprot.writeBool(self.executed)
      oprot.writeFieldEnd()
    if self.hit_entry_handle is not None:
      oprot.writeFieldBegin('hit_entry_handle', TType.I32, 4)
      oprot.writeI32(self.hit_entry_handle)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.hit is None:
      raise TProtocol.TProtocolException(message='Required field hit is unset!')
    if self.inhibited is None:
      raise TProtocol.TProtocolException(message='Required field inhibited is unset!')
    if self.executed is None:
      raise TProtocol.TProtocolException(message='Required field executed is unset!')
    if self.hit_entry_handle is None:
      raise TProtocol.TProtocolException(message='Required field hit_entry_handle is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.hit)
    value = (value * 31) ^ hash(self.inhibited)
    value = (value * 31) ^ hash(self.executed)
    value = (value * 31) ^ hash(self.hit_entry_handle)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_cache_frequency_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - inswitch_hdr_is_sampled
   - inswitch_hdr_is_cached
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'inswitch_hdr_is_sampled', None, None, ), # 2
    (3, TType.BYTE, 'inswitch_hdr_is_cached', None, None, ), # 3
  )

  def __init__(self, op_hdr_optype=None, inswitch_hdr_is_sampled=None, inswitch_hdr_is_cached=None,):
    self.op_hdr_optype = op_hdr_optype
    self.inswitch_hdr_is_sampled = inswitch_hdr_is_sampled
    self.inswitch_hdr_is_cached = inswitch_hdr_is_cached

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_sampled = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_cached = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_cache_frequency_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_sampled is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_sampled', TType.BYTE, 2)
      oprot.writeByte(self.inswitch_hdr_is_sampled)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_cached is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_cached', TType.BYTE, 3)
      oprot.writeByte(self.inswitch_hdr_is_cached)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.inswitch_hdr_is_sampled is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_sampled is unset!')
    if self.inswitch_hdr_is_cached is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_cached is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_sampled)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_cached)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_case1_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - inswitch_hdr_is_cached
   - validvalue_hdr_validvalue
   - meta_is_latest
   - inswitch_hdr_snapshot_flag
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'inswitch_hdr_is_cached', None, None, ), # 2
    (3, TType.BYTE, 'validvalue_hdr_validvalue', None, None, ), # 3
    (4, TType.BYTE, 'meta_is_latest', None, None, ), # 4
    (5, TType.BYTE, 'inswitch_hdr_snapshot_flag', None, None, ), # 5
  )

  def __init__(self, op_hdr_optype=None, inswitch_hdr_is_cached=None, validvalue_hdr_validvalue=None, meta_is_latest=None, inswitch_hdr_snapshot_flag=None,):
    self.op_hdr_optype = op_hdr_optype
    self.inswitch_hdr_is_cached = inswitch_hdr_is_cached
    self.validvalue_hdr_validvalue = validvalue_hdr_validvalue
    self.meta_is_latest = meta_is_latest
    self.inswitch_hdr_snapshot_flag = inswitch_hdr_snapshot_flag

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_cached = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.validvalue_hdr_validvalue = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.meta_is_latest = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.inswitch_hdr_snapshot_flag = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_case1_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_cached is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_cached', TType.BYTE, 2)
      oprot.writeByte(self.inswitch_hdr_is_cached)
      oprot.writeFieldEnd()
    if self.validvalue_hdr_validvalue is not None:
      oprot.writeFieldBegin('validvalue_hdr_validvalue', TType.BYTE, 3)
      oprot.writeByte(self.validvalue_hdr_validvalue)
      oprot.writeFieldEnd()
    if self.meta_is_latest is not None:
      oprot.writeFieldBegin('meta_is_latest', TType.BYTE, 4)
      oprot.writeByte(self.meta_is_latest)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_snapshot_flag is not None:
      oprot.writeFieldBegin('inswitch_hdr_snapshot_flag', TType.BYTE, 5)
      oprot.writeByte(self.inswitch_hdr_snapshot_flag)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.inswitch_hdr_is_cached is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_cached is unset!')
    if self.validvalue_hdr_validvalue is None:
      raise TProtocol.TProtocolException(message='Required field validvalue_hdr_validvalue is unset!')
    if self.meta_is_latest is None:
      raise TProtocol.TProtocolException(message='Required field meta_is_latest is unset!')
    if self.inswitch_hdr_snapshot_flag is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_snapshot_flag is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_cached)
    value = (value * 31) ^ hash(self.validvalue_hdr_validvalue)
    value = (value * 31) ^ hash(self.meta_is_latest)
    value = (value * 31) ^ hash(self.inswitch_hdr_snapshot_flag)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_cm1_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - inswitch_hdr_is_sampled
   - inswitch_hdr_is_cached
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'inswitch_hdr_is_sampled', None, None, ), # 2
    (3, TType.BYTE, 'inswitch_hdr_is_cached', None, None, ), # 3
  )

  def __init__(self, op_hdr_optype=None, inswitch_hdr_is_sampled=None, inswitch_hdr_is_cached=None,):
    self.op_hdr_optype = op_hdr_optype
    self.inswitch_hdr_is_sampled = inswitch_hdr_is_sampled
    self.inswitch_hdr_is_cached = inswitch_hdr_is_cached

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_sampled = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_cached = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_cm1_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_sampled is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_sampled', TType.BYTE, 2)
      oprot.writeByte(self.inswitch_hdr_is_sampled)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_cached is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_cached', TType.BYTE, 3)
      oprot.writeByte(self.inswitch_hdr_is_cached)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.inswitch_hdr_is_sampled is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_sampled is unset!')
    if self.inswitch_hdr_is_cached is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_cached is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_sampled)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_cached)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_cm2_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - inswitch_hdr_is_sampled
   - inswitch_hdr_is_cached
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'inswitch_hdr_is_sampled', None, None, ), # 2
    (3, TType.BYTE, 'inswitch_hdr_is_cached', None, None, ), # 3
  )

  def __init__(self, op_hdr_optype=None, inswitch_hdr_is_sampled=None, inswitch_hdr_is_cached=None,):
    self.op_hdr_optype = op_hdr_optype
    self.inswitch_hdr_is_sampled = inswitch_hdr_is_sampled
    self.inswitch_hdr_is_cached = inswitch_hdr_is_cached

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_sampled = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_cached = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_cm2_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_sampled is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_sampled', TType.BYTE, 2)
      oprot.writeByte(self.inswitch_hdr_is_sampled)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_cached is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_cached', TType.BYTE, 3)
      oprot.writeByte(self.inswitch_hdr_is_cached)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.inswitch_hdr_is_sampled is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_sampled is unset!')
    if self.inswitch_hdr_is_cached is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_cached is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_sampled)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_cached)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_cm3_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - inswitch_hdr_is_sampled
   - inswitch_hdr_is_cached
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'inswitch_hdr_is_sampled', None, None, ), # 2
    (3, TType.BYTE, 'inswitch_hdr_is_cached', None, None, ), # 3
  )

  def __init__(self, op_hdr_optype=None, inswitch_hdr_is_sampled=None, inswitch_hdr_is_cached=None,):
    self.op_hdr_optype = op_hdr_optype
    self.inswitch_hdr_is_sampled = inswitch_hdr_is_sampled
    self.inswitch_hdr_is_cached = inswitch_hdr_is_cached

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_sampled = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_cached = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_cm3_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_sampled is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_sampled', TType.BYTE, 2)
      oprot.writeByte(self.inswitch_hdr_is_sampled)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_cached is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_cached', TType.BYTE, 3)
      oprot.writeByte(self.inswitch_hdr_is_cached)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.inswitch_hdr_is_sampled is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_sampled is unset!')
    if self.inswitch_hdr_is_cached is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_cached is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_sampled)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_cached)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_cm4_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - inswitch_hdr_is_sampled
   - inswitch_hdr_is_cached
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'inswitch_hdr_is_sampled', None, None, ), # 2
    (3, TType.BYTE, 'inswitch_hdr_is_cached', None, None, ), # 3
  )

  def __init__(self, op_hdr_optype=None, inswitch_hdr_is_sampled=None, inswitch_hdr_is_cached=None,):
    self.op_hdr_optype = op_hdr_optype
    self.inswitch_hdr_is_sampled = inswitch_hdr_is_sampled
    self.inswitch_hdr_is_cached = inswitch_hdr_is_cached

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_sampled = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_cached = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_cm4_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_sampled is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_sampled', TType.BYTE, 2)
      oprot.writeByte(self.inswitch_hdr_is_sampled)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_cached is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_cached', TType.BYTE, 3)
      oprot.writeByte(self.inswitch_hdr_is_cached)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.inswitch_hdr_is_sampled is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_sampled is unset!')
    if self.inswitch_hdr_is_cached is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_cached is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_sampled)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_cached)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_deleted_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - inswitch_hdr_is_cached
   - validvalue_hdr_validvalue
   - meta_is_latest
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'inswitch_hdr_is_cached', None, None, ), # 2
    (3, TType.BYTE, 'validvalue_hdr_validvalue', None, None, ), # 3
    (4, TType.BYTE, 'meta_is_latest', None, None, ), # 4
  )

  def __init__(self, op_hdr_optype=None, inswitch_hdr_is_cached=None, validvalue_hdr_validvalue=None, meta_is_latest=None,):
    self.op_hdr_optype = op_hdr_optype
    self.inswitch_hdr_is_cached = inswitch_hdr_is_cached
    self.validvalue_hdr_validvalue = validvalue_hdr_validvalue
    self.meta_is_latest = meta_is_latest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_cached = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.validvalue_hdr_validvalue = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.meta_is_latest = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_deleted_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_cached is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_cached', TType.BYTE, 2)
      oprot.writeByte(self.inswitch_hdr_is_cached)
      oprot.writeFieldEnd()
    if self.validvalue_hdr_validvalue is not None:
      oprot.writeFieldBegin('validvalue_hdr_validvalue', TType.BYTE, 3)
      oprot.writeByte(self.validvalue_hdr_validvalue)
      oprot.writeFieldEnd()
    if self.meta_is_latest is not None:
      oprot.writeFieldBegin('meta_is_latest', TType.BYTE, 4)
      oprot.writeByte(self.meta_is_latest)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.inswitch_hdr_is_cached is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_cached is unset!')
    if self.validvalue_hdr_validvalue is None:
      raise TProtocol.TProtocolException(message='Required field validvalue_hdr_validvalue is unset!')
    if self.meta_is_latest is None:
      raise TProtocol.TProtocolException(message='Required field meta_is_latest is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_cached)
    value = (value * 31) ^ hash(self.validvalue_hdr_validvalue)
    value = (value * 31) ^ hash(self.meta_is_latest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_latest_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - inswitch_hdr_is_cached
   - validvalue_hdr_validvalue
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'inswitch_hdr_is_cached', None, None, ), # 2
    (3, TType.BYTE, 'validvalue_hdr_validvalue', None, None, ), # 3
  )

  def __init__(self, op_hdr_optype=None, inswitch_hdr_is_cached=None, validvalue_hdr_validvalue=None,):
    self.op_hdr_optype = op_hdr_optype
    self.inswitch_hdr_is_cached = inswitch_hdr_is_cached
    self.validvalue_hdr_validvalue = validvalue_hdr_validvalue

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_cached = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.validvalue_hdr_validvalue = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_latest_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_cached is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_cached', TType.BYTE, 2)
      oprot.writeByte(self.inswitch_hdr_is_cached)
      oprot.writeFieldEnd()
    if self.validvalue_hdr_validvalue is not None:
      oprot.writeFieldBegin('validvalue_hdr_validvalue', TType.BYTE, 3)
      oprot.writeByte(self.validvalue_hdr_validvalue)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.inswitch_hdr_is_cached is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_cached is unset!')
    if self.validvalue_hdr_validvalue is None:
      raise TProtocol.TProtocolException(message='Required field validvalue_hdr_validvalue is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_cached)
    value = (value * 31) ^ hash(self.validvalue_hdr_validvalue)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_savedseq_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - inswitch_hdr_is_cached
   - validvalue_hdr_validvalue
   - meta_is_latest
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'inswitch_hdr_is_cached', None, None, ), # 2
    (3, TType.BYTE, 'validvalue_hdr_validvalue', None, None, ), # 3
    (4, TType.BYTE, 'meta_is_latest', None, None, ), # 4
  )

  def __init__(self, op_hdr_optype=None, inswitch_hdr_is_cached=None, validvalue_hdr_validvalue=None, meta_is_latest=None,):
    self.op_hdr_optype = op_hdr_optype
    self.inswitch_hdr_is_cached = inswitch_hdr_is_cached
    self.validvalue_hdr_validvalue = validvalue_hdr_validvalue
    self.meta_is_latest = meta_is_latest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_cached = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.validvalue_hdr_validvalue = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.meta_is_latest = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_savedseq_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_cached is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_cached', TType.BYTE, 2)
      oprot.writeByte(self.inswitch_hdr_is_cached)
      oprot.writeFieldEnd()
    if self.validvalue_hdr_validvalue is not None:
      oprot.writeFieldBegin('validvalue_hdr_validvalue', TType.BYTE, 3)
      oprot.writeByte(self.validvalue_hdr_validvalue)
      oprot.writeFieldEnd()
    if self.meta_is_latest is not None:
      oprot.writeFieldBegin('meta_is_latest', TType.BYTE, 4)
      oprot.writeByte(self.meta_is_latest)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.inswitch_hdr_is_cached is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_cached is unset!')
    if self.validvalue_hdr_validvalue is None:
      raise TProtocol.TProtocolException(message='Required field validvalue_hdr_validvalue is unset!')
    if self.meta_is_latest is None:
      raise TProtocol.TProtocolException(message='Required field meta_is_latest is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_cached)
    value = (value * 31) ^ hash(self.validvalue_hdr_validvalue)
    value = (value * 31) ^ hash(self.meta_is_latest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_seq_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
  )

  def __init__(self, op_hdr_optype=None,):
    self.op_hdr_optype = op_hdr_optype

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_seq_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_validvalue_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - inswitch_hdr_is_cached
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'inswitch_hdr_is_cached', None, None, ), # 2
  )

  def __init__(self, op_hdr_optype=None, inswitch_hdr_is_cached=None,):
    self.op_hdr_optype = op_hdr_optype
    self.inswitch_hdr_is_cached = inswitch_hdr_is_cached

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_cached = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_validvalue_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_cached is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_cached', TType.BYTE, 2)
      oprot.writeByte(self.inswitch_hdr_is_cached)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.inswitch_hdr_is_cached is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_cached is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_cached)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_add_and_remove_value_header_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - vallen_hdr_vallen_start
   - vallen_hdr_vallen_end
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.I16, 'vallen_hdr_vallen_start', None, None, ), # 2
    (3, TType.I16, 'vallen_hdr_vallen_end', None, None, ), # 3
  )

  def __init__(self, op_hdr_optype=None, vallen_hdr_vallen_start=None, vallen_hdr_vallen_end=None,):
    self.op_hdr_optype = op_hdr_optype
    self.vallen_hdr_vallen_start = vallen_hdr_vallen_start
    self.vallen_hdr_vallen_end = vallen_hdr_vallen_end

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.vallen_hdr_vallen_start = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.vallen_hdr_vallen_end = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_add_and_remove_value_header_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.vallen_hdr_vallen_start is not None:
      oprot.writeFieldBegin('vallen_hdr_vallen_start', TType.I16, 2)
      oprot.writeI16(self.vallen_hdr_vallen_start)
      oprot.writeFieldEnd()
    if self.vallen_hdr_vallen_end is not None:
      oprot.writeFieldBegin('vallen_hdr_vallen_end', TType.I16, 3)
      oprot.writeI16(self.vallen_hdr_vallen_end)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.vallen_hdr_vallen_start is None:
      raise TProtocol.TProtocolException(message='Required field vallen_hdr_vallen_start is unset!')
    if self.vallen_hdr_vallen_end is None:
      raise TProtocol.TProtocolException(message='Required field vallen_hdr_vallen_end is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.vallen_hdr_vallen_start)
    value = (value * 31) ^ hash(self.vallen_hdr_vallen_end)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_cache_lookup_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_keylolo
   - op_hdr_keylohi
   - op_hdr_keyhilo
   - op_hdr_keyhihilo
   - op_hdr_keyhihihi
   - meta_need_recirculate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'op_hdr_keylolo', None, None, ), # 1
    (2, TType.I32, 'op_hdr_keylohi', None, None, ), # 2
    (3, TType.I32, 'op_hdr_keyhilo', None, None, ), # 3
    (4, TType.I16, 'op_hdr_keyhihilo', None, None, ), # 4
    (5, TType.I16, 'op_hdr_keyhihihi', None, None, ), # 5
    (6, TType.BYTE, 'meta_need_recirculate', None, None, ), # 6
  )

  def __init__(self, op_hdr_keylolo=None, op_hdr_keylohi=None, op_hdr_keyhilo=None, op_hdr_keyhihilo=None, op_hdr_keyhihihi=None, meta_need_recirculate=None,):
    self.op_hdr_keylolo = op_hdr_keylolo
    self.op_hdr_keylohi = op_hdr_keylohi
    self.op_hdr_keyhilo = op_hdr_keyhilo
    self.op_hdr_keyhihilo = op_hdr_keyhihilo
    self.op_hdr_keyhihihi = op_hdr_keyhihihi
    self.meta_need_recirculate = meta_need_recirculate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.op_hdr_keylolo = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.op_hdr_keylohi = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.op_hdr_keyhilo = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I16:
          self.op_hdr_keyhihilo = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.op_hdr_keyhihihi = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.meta_need_recirculate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_cache_lookup_tbl_match_spec_t')
    if self.op_hdr_keylolo is not None:
      oprot.writeFieldBegin('op_hdr_keylolo', TType.I32, 1)
      oprot.writeI32(self.op_hdr_keylolo)
      oprot.writeFieldEnd()
    if self.op_hdr_keylohi is not None:
      oprot.writeFieldBegin('op_hdr_keylohi', TType.I32, 2)
      oprot.writeI32(self.op_hdr_keylohi)
      oprot.writeFieldEnd()
    if self.op_hdr_keyhilo is not None:
      oprot.writeFieldBegin('op_hdr_keyhilo', TType.I32, 3)
      oprot.writeI32(self.op_hdr_keyhilo)
      oprot.writeFieldEnd()
    if self.op_hdr_keyhihilo is not None:
      oprot.writeFieldBegin('op_hdr_keyhihilo', TType.I16, 4)
      oprot.writeI16(self.op_hdr_keyhihilo)
      oprot.writeFieldEnd()
    if self.op_hdr_keyhihihi is not None:
      oprot.writeFieldBegin('op_hdr_keyhihihi', TType.I16, 5)
      oprot.writeI16(self.op_hdr_keyhihihi)
      oprot.writeFieldEnd()
    if self.meta_need_recirculate is not None:
      oprot.writeFieldBegin('meta_need_recirculate', TType.BYTE, 6)
      oprot.writeByte(self.meta_need_recirculate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_keylolo is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_keylolo is unset!')
    if self.op_hdr_keylohi is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_keylohi is unset!')
    if self.op_hdr_keyhilo is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_keyhilo is unset!')
    if self.op_hdr_keyhihilo is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_keyhihilo is unset!')
    if self.op_hdr_keyhihihi is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_keyhihihi is unset!')
    if self.meta_need_recirculate is None:
      raise TProtocol.TProtocolException(message='Required field meta_need_recirculate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_keylolo)
    value = (value * 31) ^ hash(self.op_hdr_keylohi)
    value = (value * 31) ^ hash(self.op_hdr_keyhilo)
    value = (value * 31) ^ hash(self.op_hdr_keyhihilo)
    value = (value * 31) ^ hash(self.op_hdr_keyhihihi)
    value = (value * 31) ^ hash(self.meta_need_recirculate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_drop_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
  )

  def __init__(self, op_hdr_optype=None,):
    self.op_hdr_optype = op_hdr_optype

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_drop_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_eg_port_forward_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - inswitch_hdr_is_cached
   - meta_is_hot
   - validvalue_hdr_validvalue
   - meta_is_latest
   - meta_is_deleted
   - inswitch_hdr_client_sid
   - meta_is_lastclone_for_pktloss
   - inswitch_hdr_snapshot_flag
   - meta_is_case1
   - meta_is_last_scansplit
   - meta_server_sid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'inswitch_hdr_is_cached', None, None, ), # 2
    (3, TType.BYTE, 'meta_is_hot', None, None, ), # 3
    (4, TType.BYTE, 'validvalue_hdr_validvalue', None, None, ), # 4
    (5, TType.BYTE, 'meta_is_latest', None, None, ), # 5
    (6, TType.BYTE, 'meta_is_deleted', None, None, ), # 6
    (7, TType.I16, 'inswitch_hdr_client_sid', None, None, ), # 7
    (8, TType.BYTE, 'meta_is_lastclone_for_pktloss', None, None, ), # 8
    (9, TType.BYTE, 'inswitch_hdr_snapshot_flag', None, None, ), # 9
    (10, TType.BYTE, 'meta_is_case1', None, None, ), # 10
    (11, TType.BYTE, 'meta_is_last_scansplit', None, None, ), # 11
    (12, TType.I16, 'meta_server_sid', None, None, ), # 12
  )

  def __init__(self, op_hdr_optype=None, inswitch_hdr_is_cached=None, meta_is_hot=None, validvalue_hdr_validvalue=None, meta_is_latest=None, meta_is_deleted=None, inswitch_hdr_client_sid=None, meta_is_lastclone_for_pktloss=None, inswitch_hdr_snapshot_flag=None, meta_is_case1=None, meta_is_last_scansplit=None, meta_server_sid=None,):
    self.op_hdr_optype = op_hdr_optype
    self.inswitch_hdr_is_cached = inswitch_hdr_is_cached
    self.meta_is_hot = meta_is_hot
    self.validvalue_hdr_validvalue = validvalue_hdr_validvalue
    self.meta_is_latest = meta_is_latest
    self.meta_is_deleted = meta_is_deleted
    self.inswitch_hdr_client_sid = inswitch_hdr_client_sid
    self.meta_is_lastclone_for_pktloss = meta_is_lastclone_for_pktloss
    self.inswitch_hdr_snapshot_flag = inswitch_hdr_snapshot_flag
    self.meta_is_case1 = meta_is_case1
    self.meta_is_last_scansplit = meta_is_last_scansplit
    self.meta_server_sid = meta_server_sid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_cached = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.meta_is_hot = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.validvalue_hdr_validvalue = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.BYTE:
          self.meta_is_latest = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.BYTE:
          self.meta_is_deleted = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.I16:
          self.inswitch_hdr_client_sid = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.BYTE:
          self.meta_is_lastclone_for_pktloss = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.BYTE:
          self.inswitch_hdr_snapshot_flag = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.BYTE:
          self.meta_is_case1 = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.BYTE:
          self.meta_is_last_scansplit = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.I16:
          self.meta_server_sid = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_eg_port_forward_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_cached is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_cached', TType.BYTE, 2)
      oprot.writeByte(self.inswitch_hdr_is_cached)
      oprot.writeFieldEnd()
    if self.meta_is_hot is not None:
      oprot.writeFieldBegin('meta_is_hot', TType.BYTE, 3)
      oprot.writeByte(self.meta_is_hot)
      oprot.writeFieldEnd()
    if self.validvalue_hdr_validvalue is not None:
      oprot.writeFieldBegin('validvalue_hdr_validvalue', TType.BYTE, 4)
      oprot.writeByte(self.validvalue_hdr_validvalue)
      oprot.writeFieldEnd()
    if self.meta_is_latest is not None:
      oprot.writeFieldBegin('meta_is_latest', TType.BYTE, 5)
      oprot.writeByte(self.meta_is_latest)
      oprot.writeFieldEnd()
    if self.meta_is_deleted is not None:
      oprot.writeFieldBegin('meta_is_deleted', TType.BYTE, 6)
      oprot.writeByte(self.meta_is_deleted)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_client_sid is not None:
      oprot.writeFieldBegin('inswitch_hdr_client_sid', TType.I16, 7)
      oprot.writeI16(self.inswitch_hdr_client_sid)
      oprot.writeFieldEnd()
    if self.meta_is_lastclone_for_pktloss is not None:
      oprot.writeFieldBegin('meta_is_lastclone_for_pktloss', TType.BYTE, 8)
      oprot.writeByte(self.meta_is_lastclone_for_pktloss)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_snapshot_flag is not None:
      oprot.writeFieldBegin('inswitch_hdr_snapshot_flag', TType.BYTE, 9)
      oprot.writeByte(self.inswitch_hdr_snapshot_flag)
      oprot.writeFieldEnd()
    if self.meta_is_case1 is not None:
      oprot.writeFieldBegin('meta_is_case1', TType.BYTE, 10)
      oprot.writeByte(self.meta_is_case1)
      oprot.writeFieldEnd()
    if self.meta_is_last_scansplit is not None:
      oprot.writeFieldBegin('meta_is_last_scansplit', TType.BYTE, 11)
      oprot.writeByte(self.meta_is_last_scansplit)
      oprot.writeFieldEnd()
    if self.meta_server_sid is not None:
      oprot.writeFieldBegin('meta_server_sid', TType.I16, 12)
      oprot.writeI16(self.meta_server_sid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.inswitch_hdr_is_cached is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_cached is unset!')
    if self.meta_is_hot is None:
      raise TProtocol.TProtocolException(message='Required field meta_is_hot is unset!')
    if self.validvalue_hdr_validvalue is None:
      raise TProtocol.TProtocolException(message='Required field validvalue_hdr_validvalue is unset!')
    if self.meta_is_latest is None:
      raise TProtocol.TProtocolException(message='Required field meta_is_latest is unset!')
    if self.meta_is_deleted is None:
      raise TProtocol.TProtocolException(message='Required field meta_is_deleted is unset!')
    if self.inswitch_hdr_client_sid is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_client_sid is unset!')
    if self.meta_is_lastclone_for_pktloss is None:
      raise TProtocol.TProtocolException(message='Required field meta_is_lastclone_for_pktloss is unset!')
    if self.inswitch_hdr_snapshot_flag is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_snapshot_flag is unset!')
    if self.meta_is_case1 is None:
      raise TProtocol.TProtocolException(message='Required field meta_is_case1 is unset!')
    if self.meta_is_last_scansplit is None:
      raise TProtocol.TProtocolException(message='Required field meta_is_last_scansplit is unset!')
    if self.meta_server_sid is None:
      raise TProtocol.TProtocolException(message='Required field meta_server_sid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_cached)
    value = (value * 31) ^ hash(self.meta_is_hot)
    value = (value * 31) ^ hash(self.validvalue_hdr_validvalue)
    value = (value * 31) ^ hash(self.meta_is_latest)
    value = (value * 31) ^ hash(self.meta_is_deleted)
    value = (value * 31) ^ hash(self.inswitch_hdr_client_sid)
    value = (value * 31) ^ hash(self.meta_is_lastclone_for_pktloss)
    value = (value * 31) ^ hash(self.inswitch_hdr_snapshot_flag)
    value = (value * 31) ^ hash(self.meta_is_case1)
    value = (value * 31) ^ hash(self.meta_is_last_scansplit)
    value = (value * 31) ^ hash(self.meta_server_sid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_hash_for_cm1_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - meta_need_recirculate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'meta_need_recirculate', None, None, ), # 2
  )

  def __init__(self, op_hdr_optype=None, meta_need_recirculate=None,):
    self.op_hdr_optype = op_hdr_optype
    self.meta_need_recirculate = meta_need_recirculate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.meta_need_recirculate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_hash_for_cm1_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.meta_need_recirculate is not None:
      oprot.writeFieldBegin('meta_need_recirculate', TType.BYTE, 2)
      oprot.writeByte(self.meta_need_recirculate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.meta_need_recirculate is None:
      raise TProtocol.TProtocolException(message='Required field meta_need_recirculate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.meta_need_recirculate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_hash_for_cm2_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - meta_need_recirculate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'meta_need_recirculate', None, None, ), # 2
  )

  def __init__(self, op_hdr_optype=None, meta_need_recirculate=None,):
    self.op_hdr_optype = op_hdr_optype
    self.meta_need_recirculate = meta_need_recirculate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.meta_need_recirculate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_hash_for_cm2_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.meta_need_recirculate is not None:
      oprot.writeFieldBegin('meta_need_recirculate', TType.BYTE, 2)
      oprot.writeByte(self.meta_need_recirculate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.meta_need_recirculate is None:
      raise TProtocol.TProtocolException(message='Required field meta_need_recirculate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.meta_need_recirculate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_hash_for_cm3_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - meta_need_recirculate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'meta_need_recirculate', None, None, ), # 2
  )

  def __init__(self, op_hdr_optype=None, meta_need_recirculate=None,):
    self.op_hdr_optype = op_hdr_optype
    self.meta_need_recirculate = meta_need_recirculate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.meta_need_recirculate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_hash_for_cm3_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.meta_need_recirculate is not None:
      oprot.writeFieldBegin('meta_need_recirculate', TType.BYTE, 2)
      oprot.writeByte(self.meta_need_recirculate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.meta_need_recirculate is None:
      raise TProtocol.TProtocolException(message='Required field meta_need_recirculate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.meta_need_recirculate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_hash_for_cm4_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - meta_need_recirculate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'meta_need_recirculate', None, None, ), # 2
  )

  def __init__(self, op_hdr_optype=None, meta_need_recirculate=None,):
    self.op_hdr_optype = op_hdr_optype
    self.meta_need_recirculate = meta_need_recirculate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.meta_need_recirculate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_hash_for_cm4_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.meta_need_recirculate is not None:
      oprot.writeFieldBegin('meta_need_recirculate', TType.BYTE, 2)
      oprot.writeByte(self.meta_need_recirculate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.meta_need_recirculate is None:
      raise TProtocol.TProtocolException(message='Required field meta_need_recirculate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.meta_need_recirculate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_hash_for_seq_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - meta_need_recirculate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'meta_need_recirculate', None, None, ), # 2
  )

  def __init__(self, op_hdr_optype=None, meta_need_recirculate=None,):
    self.op_hdr_optype = op_hdr_optype
    self.meta_need_recirculate = meta_need_recirculate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.meta_need_recirculate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_hash_for_seq_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.meta_need_recirculate is not None:
      oprot.writeFieldBegin('meta_need_recirculate', TType.BYTE, 2)
      oprot.writeByte(self.meta_need_recirculate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.meta_need_recirculate is None:
      raise TProtocol.TProtocolException(message='Required field meta_need_recirculate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.meta_need_recirculate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_ig_port_forward_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - meta_need_recirculate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'meta_need_recirculate', None, None, ), # 2
  )

  def __init__(self, op_hdr_optype=None, meta_need_recirculate=None,):
    self.op_hdr_optype = op_hdr_optype
    self.meta_need_recirculate = meta_need_recirculate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.meta_need_recirculate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_ig_port_forward_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.meta_need_recirculate is not None:
      oprot.writeFieldBegin('meta_need_recirculate', TType.BYTE, 2)
      oprot.writeByte(self.meta_need_recirculate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.meta_need_recirculate is None:
      raise TProtocol.TProtocolException(message='Required field meta_need_recirculate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.meta_need_recirculate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_ipv4_forward_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - ipv4_hdr_dstAddr
   - ipv4_hdr_dstAddr_prefix_length
   - meta_need_recirculate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.I32, 'ipv4_hdr_dstAddr', None, None, ), # 2
    (3, TType.I16, 'ipv4_hdr_dstAddr_prefix_length', None, None, ), # 3
    (4, TType.BYTE, 'meta_need_recirculate', None, None, ), # 4
  )

  def __init__(self, op_hdr_optype=None, ipv4_hdr_dstAddr=None, ipv4_hdr_dstAddr_prefix_length=None, meta_need_recirculate=None,):
    self.op_hdr_optype = op_hdr_optype
    self.ipv4_hdr_dstAddr = ipv4_hdr_dstAddr
    self.ipv4_hdr_dstAddr_prefix_length = ipv4_hdr_dstAddr_prefix_length
    self.meta_need_recirculate = meta_need_recirculate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.ipv4_hdr_dstAddr = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.ipv4_hdr_dstAddr_prefix_length = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.meta_need_recirculate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_ipv4_forward_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.ipv4_hdr_dstAddr is not None:
      oprot.writeFieldBegin('ipv4_hdr_dstAddr', TType.I32, 2)
      oprot.writeI32(self.ipv4_hdr_dstAddr)
      oprot.writeFieldEnd()
    if self.ipv4_hdr_dstAddr_prefix_length is not None:
      oprot.writeFieldBegin('ipv4_hdr_dstAddr_prefix_length', TType.I16, 3)
      oprot.writeI16(self.ipv4_hdr_dstAddr_prefix_length)
      oprot.writeFieldEnd()
    if self.meta_need_recirculate is not None:
      oprot.writeFieldBegin('meta_need_recirculate', TType.BYTE, 4)
      oprot.writeByte(self.meta_need_recirculate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.ipv4_hdr_dstAddr is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_hdr_dstAddr is unset!')
    if self.ipv4_hdr_dstAddr_prefix_length is None:
      raise TProtocol.TProtocolException(message='Required field ipv4_hdr_dstAddr_prefix_length is unset!')
    if self.meta_need_recirculate is None:
      raise TProtocol.TProtocolException(message='Required field meta_need_recirculate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.ipv4_hdr_dstAddr)
    value = (value * 31) ^ hash(self.ipv4_hdr_dstAddr_prefix_length)
    value = (value * 31) ^ hash(self.meta_need_recirculate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_is_hot_tbl_match_spec_t:
  """
  Attributes:
   - meta_cm1_predicate
   - meta_cm2_predicate
   - meta_cm3_predicate
   - meta_cm4_predicate
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_cm1_predicate', None, None, ), # 1
    (2, TType.BYTE, 'meta_cm2_predicate', None, None, ), # 2
    (3, TType.BYTE, 'meta_cm3_predicate', None, None, ), # 3
    (4, TType.BYTE, 'meta_cm4_predicate', None, None, ), # 4
  )

  def __init__(self, meta_cm1_predicate=None, meta_cm2_predicate=None, meta_cm3_predicate=None, meta_cm4_predicate=None,):
    self.meta_cm1_predicate = meta_cm1_predicate
    self.meta_cm2_predicate = meta_cm2_predicate
    self.meta_cm3_predicate = meta_cm3_predicate
    self.meta_cm4_predicate = meta_cm4_predicate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_cm1_predicate = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.meta_cm2_predicate = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.meta_cm3_predicate = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.meta_cm4_predicate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_is_hot_tbl_match_spec_t')
    if self.meta_cm1_predicate is not None:
      oprot.writeFieldBegin('meta_cm1_predicate', TType.BYTE, 1)
      oprot.writeByte(self.meta_cm1_predicate)
      oprot.writeFieldEnd()
    if self.meta_cm2_predicate is not None:
      oprot.writeFieldBegin('meta_cm2_predicate', TType.BYTE, 2)
      oprot.writeByte(self.meta_cm2_predicate)
      oprot.writeFieldEnd()
    if self.meta_cm3_predicate is not None:
      oprot.writeFieldBegin('meta_cm3_predicate', TType.BYTE, 3)
      oprot.writeByte(self.meta_cm3_predicate)
      oprot.writeFieldEnd()
    if self.meta_cm4_predicate is not None:
      oprot.writeFieldBegin('meta_cm4_predicate', TType.BYTE, 4)
      oprot.writeByte(self.meta_cm4_predicate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_cm1_predicate is None:
      raise TProtocol.TProtocolException(message='Required field meta_cm1_predicate is unset!')
    if self.meta_cm2_predicate is None:
      raise TProtocol.TProtocolException(message='Required field meta_cm2_predicate is unset!')
    if self.meta_cm3_predicate is None:
      raise TProtocol.TProtocolException(message='Required field meta_cm3_predicate is unset!')
    if self.meta_cm4_predicate is None:
      raise TProtocol.TProtocolException(message='Required field meta_cm4_predicate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_cm1_predicate)
    value = (value * 31) ^ hash(self.meta_cm2_predicate)
    value = (value * 31) ^ hash(self.meta_cm3_predicate)
    value = (value * 31) ^ hash(self.meta_cm4_predicate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_lastclone_lastscansplit_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - clone_hdr_clonenum_for_pktloss
   - meta_remain_scannum
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'clone_hdr_clonenum_for_pktloss', None, None, ), # 2
    (3, TType.I16, 'meta_remain_scannum', None, None, ), # 3
  )

  def __init__(self, op_hdr_optype=None, clone_hdr_clonenum_for_pktloss=None, meta_remain_scannum=None,):
    self.op_hdr_optype = op_hdr_optype
    self.clone_hdr_clonenum_for_pktloss = clone_hdr_clonenum_for_pktloss
    self.meta_remain_scannum = meta_remain_scannum

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.clone_hdr_clonenum_for_pktloss = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.meta_remain_scannum = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_lastclone_lastscansplit_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.clone_hdr_clonenum_for_pktloss is not None:
      oprot.writeFieldBegin('clone_hdr_clonenum_for_pktloss', TType.BYTE, 2)
      oprot.writeByte(self.clone_hdr_clonenum_for_pktloss)
      oprot.writeFieldEnd()
    if self.meta_remain_scannum is not None:
      oprot.writeFieldBegin('meta_remain_scannum', TType.I16, 3)
      oprot.writeI16(self.meta_remain_scannum)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.clone_hdr_clonenum_for_pktloss is None:
      raise TProtocol.TProtocolException(message='Required field clone_hdr_clonenum_for_pktloss is unset!')
    if self.meta_remain_scannum is None:
      raise TProtocol.TProtocolException(message='Required field meta_remain_scannum is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.clone_hdr_clonenum_for_pktloss)
    value = (value * 31) ^ hash(self.meta_remain_scannum)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_need_recirculate_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - ig_intr_md_ingress_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.I16, 'ig_intr_md_ingress_port', None, None, ), # 2
  )

  def __init__(self, op_hdr_optype=None, ig_intr_md_ingress_port=None,):
    self.op_hdr_optype = op_hdr_optype
    self.ig_intr_md_ingress_port = ig_intr_md_ingress_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.ig_intr_md_ingress_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_need_recirculate_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.ig_intr_md_ingress_port is not None:
      oprot.writeFieldBegin('ig_intr_md_ingress_port', TType.I16, 2)
      oprot.writeI16(self.ig_intr_md_ingress_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.ig_intr_md_ingress_port is None:
      raise TProtocol.TProtocolException(message='Required field ig_intr_md_ingress_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.ig_intr_md_ingress_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_prepare_for_cachehit_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - ig_intr_md_ingress_port
   - meta_need_recirculate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.I16, 'ig_intr_md_ingress_port', None, None, ), # 2
    (3, TType.BYTE, 'meta_need_recirculate', None, None, ), # 3
  )

  def __init__(self, op_hdr_optype=None, ig_intr_md_ingress_port=None, meta_need_recirculate=None,):
    self.op_hdr_optype = op_hdr_optype
    self.ig_intr_md_ingress_port = ig_intr_md_ingress_port
    self.meta_need_recirculate = meta_need_recirculate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.ig_intr_md_ingress_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.meta_need_recirculate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_prepare_for_cachehit_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.ig_intr_md_ingress_port is not None:
      oprot.writeFieldBegin('ig_intr_md_ingress_port', TType.I16, 2)
      oprot.writeI16(self.ig_intr_md_ingress_port)
      oprot.writeFieldEnd()
    if self.meta_need_recirculate is not None:
      oprot.writeFieldBegin('meta_need_recirculate', TType.BYTE, 3)
      oprot.writeByte(self.meta_need_recirculate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.ig_intr_md_ingress_port is None:
      raise TProtocol.TProtocolException(message='Required field ig_intr_md_ingress_port is unset!')
    if self.meta_need_recirculate is None:
      raise TProtocol.TProtocolException(message='Required field meta_need_recirculate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.ig_intr_md_ingress_port)
    value = (value * 31) ^ hash(self.meta_need_recirculate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_process_scanreq_split_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - udp_hdr_dstPort
   - split_hdr_is_clone
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.I16, 'udp_hdr_dstPort', None, None, ), # 2
    (3, TType.BYTE, 'split_hdr_is_clone', None, None, ), # 3
  )

  def __init__(self, op_hdr_optype=None, udp_hdr_dstPort=None, split_hdr_is_clone=None,):
    self.op_hdr_optype = op_hdr_optype
    self.udp_hdr_dstPort = udp_hdr_dstPort
    self.split_hdr_is_clone = split_hdr_is_clone

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.udp_hdr_dstPort = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.split_hdr_is_clone = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_process_scanreq_split_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.udp_hdr_dstPort is not None:
      oprot.writeFieldBegin('udp_hdr_dstPort', TType.I16, 2)
      oprot.writeI16(self.udp_hdr_dstPort)
      oprot.writeFieldEnd()
    if self.split_hdr_is_clone is not None:
      oprot.writeFieldBegin('split_hdr_is_clone', TType.BYTE, 3)
      oprot.writeByte(self.split_hdr_is_clone)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.udp_hdr_dstPort is None:
      raise TProtocol.TProtocolException(message='Required field udp_hdr_dstPort is unset!')
    if self.split_hdr_is_clone is None:
      raise TProtocol.TProtocolException(message='Required field split_hdr_is_clone is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.udp_hdr_dstPort)
    value = (value * 31) ^ hash(self.split_hdr_is_clone)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_range_partition_for_scan_endkey_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - scan_hdr_keyhihihi_start
   - scan_hdr_keyhihihi_end
   - meta_need_recirculate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.I16, 'scan_hdr_keyhihihi_start', None, None, ), # 2
    (3, TType.I16, 'scan_hdr_keyhihihi_end', None, None, ), # 3
    (4, TType.BYTE, 'meta_need_recirculate', None, None, ), # 4
  )

  def __init__(self, op_hdr_optype=None, scan_hdr_keyhihihi_start=None, scan_hdr_keyhihihi_end=None, meta_need_recirculate=None,):
    self.op_hdr_optype = op_hdr_optype
    self.scan_hdr_keyhihihi_start = scan_hdr_keyhihihi_start
    self.scan_hdr_keyhihihi_end = scan_hdr_keyhihihi_end
    self.meta_need_recirculate = meta_need_recirculate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.scan_hdr_keyhihihi_start = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.scan_hdr_keyhihihi_end = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.meta_need_recirculate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_range_partition_for_scan_endkey_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.scan_hdr_keyhihihi_start is not None:
      oprot.writeFieldBegin('scan_hdr_keyhihihi_start', TType.I16, 2)
      oprot.writeI16(self.scan_hdr_keyhihihi_start)
      oprot.writeFieldEnd()
    if self.scan_hdr_keyhihihi_end is not None:
      oprot.writeFieldBegin('scan_hdr_keyhihihi_end', TType.I16, 3)
      oprot.writeI16(self.scan_hdr_keyhihihi_end)
      oprot.writeFieldEnd()
    if self.meta_need_recirculate is not None:
      oprot.writeFieldBegin('meta_need_recirculate', TType.BYTE, 4)
      oprot.writeByte(self.meta_need_recirculate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.scan_hdr_keyhihihi_start is None:
      raise TProtocol.TProtocolException(message='Required field scan_hdr_keyhihihi_start is unset!')
    if self.scan_hdr_keyhihihi_end is None:
      raise TProtocol.TProtocolException(message='Required field scan_hdr_keyhihihi_end is unset!')
    if self.meta_need_recirculate is None:
      raise TProtocol.TProtocolException(message='Required field meta_need_recirculate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.scan_hdr_keyhihihi_start)
    value = (value * 31) ^ hash(self.scan_hdr_keyhihihi_end)
    value = (value * 31) ^ hash(self.meta_need_recirculate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_range_partition_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - op_hdr_keyhihihi_start
   - op_hdr_keyhihihi_end
   - meta_need_recirculate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.I16, 'op_hdr_keyhihihi_start', None, None, ), # 2
    (3, TType.I16, 'op_hdr_keyhihihi_end', None, None, ), # 3
    (4, TType.BYTE, 'meta_need_recirculate', None, None, ), # 4
  )

  def __init__(self, op_hdr_optype=None, op_hdr_keyhihihi_start=None, op_hdr_keyhihihi_end=None, meta_need_recirculate=None,):
    self.op_hdr_optype = op_hdr_optype
    self.op_hdr_keyhihihi_start = op_hdr_keyhihihi_start
    self.op_hdr_keyhihihi_end = op_hdr_keyhihihi_end
    self.meta_need_recirculate = meta_need_recirculate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.op_hdr_keyhihihi_start = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.op_hdr_keyhihihi_end = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.meta_need_recirculate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_range_partition_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.op_hdr_keyhihihi_start is not None:
      oprot.writeFieldBegin('op_hdr_keyhihihi_start', TType.I16, 2)
      oprot.writeI16(self.op_hdr_keyhihihi_start)
      oprot.writeFieldEnd()
    if self.op_hdr_keyhihihi_end is not None:
      oprot.writeFieldBegin('op_hdr_keyhihihi_end', TType.I16, 3)
      oprot.writeI16(self.op_hdr_keyhihihi_end)
      oprot.writeFieldEnd()
    if self.meta_need_recirculate is not None:
      oprot.writeFieldBegin('meta_need_recirculate', TType.BYTE, 4)
      oprot.writeByte(self.meta_need_recirculate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.op_hdr_keyhihihi_start is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_keyhihihi_start is unset!')
    if self.op_hdr_keyhihihi_end is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_keyhihihi_end is unset!')
    if self.meta_need_recirculate is None:
      raise TProtocol.TProtocolException(message='Required field meta_need_recirculate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.op_hdr_keyhihihi_start)
    value = (value * 31) ^ hash(self.op_hdr_keyhihihi_end)
    value = (value * 31) ^ hash(self.meta_need_recirculate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_recirculate_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - meta_need_recirculate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'meta_need_recirculate', None, None, ), # 2
  )

  def __init__(self, op_hdr_optype=None, meta_need_recirculate=None,):
    self.op_hdr_optype = op_hdr_optype
    self.meta_need_recirculate = meta_need_recirculate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.meta_need_recirculate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_recirculate_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.meta_need_recirculate is not None:
      oprot.writeFieldBegin('meta_need_recirculate', TType.BYTE, 2)
      oprot.writeByte(self.meta_need_recirculate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.meta_need_recirculate is None:
      raise TProtocol.TProtocolException(message='Required field meta_need_recirculate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.meta_need_recirculate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_sample_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - meta_need_recirculate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'meta_need_recirculate', None, None, ), # 2
  )

  def __init__(self, op_hdr_optype=None, meta_need_recirculate=None,):
    self.op_hdr_optype = op_hdr_optype
    self.meta_need_recirculate = meta_need_recirculate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.meta_need_recirculate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_sample_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.meta_need_recirculate is not None:
      oprot.writeFieldBegin('meta_need_recirculate', TType.BYTE, 2)
      oprot.writeByte(self.meta_need_recirculate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.meta_need_recirculate is None:
      raise TProtocol.TProtocolException(message='Required field meta_need_recirculate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.meta_need_recirculate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_save_client_udpport_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
  )

  def __init__(self, op_hdr_optype=None,):
    self.op_hdr_optype = op_hdr_optype

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_save_client_udpport_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_snapshot_flag_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - meta_need_recirculate
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'meta_need_recirculate', None, None, ), # 2
  )

  def __init__(self, op_hdr_optype=None, meta_need_recirculate=None,):
    self.op_hdr_optype = op_hdr_optype
    self.meta_need_recirculate = meta_need_recirculate

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.meta_need_recirculate = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_snapshot_flag_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.meta_need_recirculate is not None:
      oprot.writeFieldBegin('meta_need_recirculate', TType.BYTE, 2)
      oprot.writeByte(self.meta_need_recirculate)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.meta_need_recirculate is None:
      raise TProtocol.TProtocolException(message='Required field meta_need_recirculate is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.meta_need_recirculate)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_ipmac_srcport_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - eg_intr_md_egress_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.I16, 'eg_intr_md_egress_port', None, None, ), # 2
  )

  def __init__(self, op_hdr_optype=None, eg_intr_md_egress_port=None,):
    self.op_hdr_optype = op_hdr_optype
    self.eg_intr_md_egress_port = eg_intr_md_egress_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.eg_intr_md_egress_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_ipmac_srcport_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.eg_intr_md_egress_port is not None:
      oprot.writeFieldBegin('eg_intr_md_egress_port', TType.I16, 2)
      oprot.writeI16(self.eg_intr_md_egress_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.eg_intr_md_egress_port is None:
      raise TProtocol.TProtocolException(message='Required field eg_intr_md_egress_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.eg_intr_md_egress_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_pktlen_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - vallen_hdr_vallen_start
   - vallen_hdr_vallen_end
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.I16, 'vallen_hdr_vallen_start', None, None, ), # 2
    (3, TType.I16, 'vallen_hdr_vallen_end', None, None, ), # 3
  )

  def __init__(self, op_hdr_optype=None, vallen_hdr_vallen_start=None, vallen_hdr_vallen_end=None,):
    self.op_hdr_optype = op_hdr_optype
    self.vallen_hdr_vallen_start = vallen_hdr_vallen_start
    self.vallen_hdr_vallen_end = vallen_hdr_vallen_end

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.vallen_hdr_vallen_start = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.vallen_hdr_vallen_end = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_pktlen_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.vallen_hdr_vallen_start is not None:
      oprot.writeFieldBegin('vallen_hdr_vallen_start', TType.I16, 2)
      oprot.writeI16(self.vallen_hdr_vallen_start)
      oprot.writeFieldEnd()
    if self.vallen_hdr_vallen_end is not None:
      oprot.writeFieldBegin('vallen_hdr_vallen_end', TType.I16, 3)
      oprot.writeI16(self.vallen_hdr_vallen_end)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.vallen_hdr_vallen_start is None:
      raise TProtocol.TProtocolException(message='Required field vallen_hdr_vallen_start is unset!')
    if self.vallen_hdr_vallen_end is None:
      raise TProtocol.TProtocolException(message='Required field vallen_hdr_vallen_end is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.vallen_hdr_vallen_start)
    value = (value * 31) ^ hash(self.vallen_hdr_vallen_end)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi10_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi10_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi11_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi11_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi12_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi12_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi13_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi13_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi14_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi14_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi15_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi15_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi16_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi16_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi1_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi1_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi2_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi2_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi3_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi3_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi4_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi4_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi5_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi5_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi6_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi6_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi7_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi7_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi8_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi8_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi9_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi9_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallen_tbl_match_spec_t:
  """
  Attributes:
   - op_hdr_optype
   - inswitch_hdr_is_cached
   - validvalue_hdr_validvalue
   - meta_is_latest
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'op_hdr_optype', None, None, ), # 1
    (2, TType.BYTE, 'inswitch_hdr_is_cached', None, None, ), # 2
    (3, TType.BYTE, 'validvalue_hdr_validvalue', None, None, ), # 3
    (4, TType.BYTE, 'meta_is_latest', None, None, ), # 4
  )

  def __init__(self, op_hdr_optype=None, inswitch_hdr_is_cached=None, validvalue_hdr_validvalue=None, meta_is_latest=None,):
    self.op_hdr_optype = op_hdr_optype
    self.inswitch_hdr_is_cached = inswitch_hdr_is_cached
    self.validvalue_hdr_validvalue = validvalue_hdr_validvalue
    self.meta_is_latest = meta_is_latest

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.op_hdr_optype = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.inswitch_hdr_is_cached = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.validvalue_hdr_validvalue = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.BYTE:
          self.meta_is_latest = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallen_tbl_match_spec_t')
    if self.op_hdr_optype is not None:
      oprot.writeFieldBegin('op_hdr_optype', TType.I16, 1)
      oprot.writeI16(self.op_hdr_optype)
      oprot.writeFieldEnd()
    if self.inswitch_hdr_is_cached is not None:
      oprot.writeFieldBegin('inswitch_hdr_is_cached', TType.BYTE, 2)
      oprot.writeByte(self.inswitch_hdr_is_cached)
      oprot.writeFieldEnd()
    if self.validvalue_hdr_validvalue is not None:
      oprot.writeFieldBegin('validvalue_hdr_validvalue', TType.BYTE, 3)
      oprot.writeByte(self.validvalue_hdr_validvalue)
      oprot.writeFieldEnd()
    if self.meta_is_latest is not None:
      oprot.writeFieldBegin('meta_is_latest', TType.BYTE, 4)
      oprot.writeByte(self.meta_is_latest)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.op_hdr_optype is None:
      raise TProtocol.TProtocolException(message='Required field op_hdr_optype is unset!')
    if self.inswitch_hdr_is_cached is None:
      raise TProtocol.TProtocolException(message='Required field inswitch_hdr_is_cached is unset!')
    if self.validvalue_hdr_validvalue is None:
      raise TProtocol.TProtocolException(message='Required field validvalue_hdr_validvalue is unset!')
    if self.meta_is_latest is None:
      raise TProtocol.TProtocolException(message='Required field meta_is_latest is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.op_hdr_optype)
    value = (value * 31) ^ hash(self.inswitch_hdr_is_cached)
    value = (value * 31) ^ hash(self.validvalue_hdr_validvalue)
    value = (value * 31) ^ hash(self.meta_is_latest)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo10_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo10_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo11_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo11_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo12_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo12_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo13_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo13_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo14_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo14_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo15_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo15_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo16_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo16_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo1_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo1_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo2_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo2_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo3_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo3_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo4_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo4_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo5_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo5_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo6_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo6_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo7_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo7_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo8_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo8_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo9_tbl_match_spec_t:
  """
  Attributes:
   - meta_access_val_mode
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'meta_access_val_mode', None, None, ), # 1
  )

  def __init__(self, meta_access_val_mode=None,):
    self.meta_access_val_mode = meta_access_val_mode

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.meta_access_val_mode = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo9_tbl_match_spec_t')
    if self.meta_access_val_mode is not None:
      oprot.writeFieldBegin('meta_access_val_mode', TType.BYTE, 1)
      oprot.writeByte(self.meta_access_val_mode)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.meta_access_val_mode is None:
      raise TProtocol.TProtocolException(message='Required field meta_access_val_mode is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.meta_access_val_mode)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_cached_action_action_spec_t:
  """
  Attributes:
   - action_idx
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_idx', None, None, ), # 1
  )

  def __init__(self, action_idx=None,):
    self.action_idx = action_idx

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_idx = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_cached_action_action_spec_t')
    if self.action_idx is not None:
      oprot.writeFieldBegin('action_idx', TType.I16, 1)
      oprot.writeI16(self.action_idx)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_idx is None:
      raise TProtocol.TProtocolException(message='Required field action_idx is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_idx)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_getreq_inswitch_to_getres_by_mirroring_action_spec_t:
  """
  Attributes:
   - action_client_sid
   - action_server_port
   - action_stat
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_client_sid', None, None, ), # 1
    (2, TType.I16, 'action_server_port', None, None, ), # 2
    (3, TType.BYTE, 'action_stat', None, None, ), # 3
  )

  def __init__(self, action_client_sid=None, action_server_port=None, action_stat=None,):
    self.action_client_sid = action_client_sid
    self.action_server_port = action_server_port
    self.action_stat = action_stat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_client_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_server_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.action_stat = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_getreq_inswitch_to_getres_by_mirroring_action_spec_t')
    if self.action_client_sid is not None:
      oprot.writeFieldBegin('action_client_sid', TType.I32, 1)
      oprot.writeI32(self.action_client_sid)
      oprot.writeFieldEnd()
    if self.action_server_port is not None:
      oprot.writeFieldBegin('action_server_port', TType.I16, 2)
      oprot.writeI16(self.action_server_port)
      oprot.writeFieldEnd()
    if self.action_stat is not None:
      oprot.writeFieldBegin('action_stat', TType.BYTE, 3)
      oprot.writeByte(self.action_stat)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_client_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_client_sid is unset!')
    if self.action_server_port is None:
      raise TProtocol.TProtocolException(message='Required field action_server_port is unset!')
    if self.action_stat is None:
      raise TProtocol.TProtocolException(message='Required field action_stat is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_client_sid)
    value = (value * 31) ^ hash(self.action_server_port)
    value = (value * 31) ^ hash(self.action_stat)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss_action_spec_t:
  """
  Attributes:
   - action_switchos_sid
   - action_stat
   - action_reflector_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_switchos_sid', None, None, ), # 1
    (2, TType.BYTE, 'action_stat', None, None, ), # 2
    (3, TType.I16, 'action_reflector_port', None, None, ), # 3
  )

  def __init__(self, action_switchos_sid=None, action_stat=None, action_reflector_port=None,):
    self.action_switchos_sid = action_switchos_sid
    self.action_stat = action_stat
    self.action_reflector_port = action_reflector_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_switchos_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_stat = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.action_reflector_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss_action_spec_t')
    if self.action_switchos_sid is not None:
      oprot.writeFieldBegin('action_switchos_sid', TType.I32, 1)
      oprot.writeI32(self.action_switchos_sid)
      oprot.writeFieldEnd()
    if self.action_stat is not None:
      oprot.writeFieldBegin('action_stat', TType.BYTE, 2)
      oprot.writeByte(self.action_stat)
      oprot.writeFieldEnd()
    if self.action_reflector_port is not None:
      oprot.writeFieldBegin('action_reflector_port', TType.I16, 3)
      oprot.writeI16(self.action_reflector_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_switchos_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_switchos_sid is unset!')
    if self.action_stat is None:
      raise TProtocol.TProtocolException(message='Required field action_stat is unset!')
    if self.action_reflector_port is None:
      raise TProtocol.TProtocolException(message='Required field action_reflector_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_switchos_sid)
    value = (value * 31) ^ hash(self.action_stat)
    value = (value * 31) ^ hash(self.action_reflector_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss_action_spec_t:
  """
  Attributes:
   - action_switchos_sid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_switchos_sid', None, None, ), # 1
  )

  def __init__(self, action_switchos_sid=None,):
    self.action_switchos_sid = action_switchos_sid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_switchos_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss_action_spec_t')
    if self.action_switchos_sid is not None:
      oprot.writeFieldBegin('action_switchos_sid', TType.I32, 1)
      oprot.writeI32(self.action_switchos_sid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_switchos_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_switchos_sid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_switchos_sid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss_action_spec_t:
  """
  Attributes:
   - action_switchos_sid
   - action_stat
   - action_reflector_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_switchos_sid', None, None, ), # 1
    (2, TType.BYTE, 'action_stat', None, None, ), # 2
    (3, TType.I16, 'action_reflector_port', None, None, ), # 3
  )

  def __init__(self, action_switchos_sid=None, action_stat=None, action_reflector_port=None,):
    self.action_switchos_sid = action_switchos_sid
    self.action_stat = action_stat
    self.action_reflector_port = action_reflector_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_switchos_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_stat = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.action_reflector_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss_action_spec_t')
    if self.action_switchos_sid is not None:
      oprot.writeFieldBegin('action_switchos_sid', TType.I32, 1)
      oprot.writeI32(self.action_switchos_sid)
      oprot.writeFieldEnd()
    if self.action_stat is not None:
      oprot.writeFieldBegin('action_stat', TType.BYTE, 2)
      oprot.writeByte(self.action_stat)
      oprot.writeFieldEnd()
    if self.action_reflector_port is not None:
      oprot.writeFieldBegin('action_reflector_port', TType.I16, 3)
      oprot.writeI16(self.action_reflector_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_switchos_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_switchos_sid is unset!')
    if self.action_stat is None:
      raise TProtocol.TProtocolException(message='Required field action_stat is unset!')
    if self.action_reflector_port is None:
      raise TProtocol.TProtocolException(message='Required field action_reflector_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_switchos_sid)
    value = (value * 31) ^ hash(self.action_stat)
    value = (value * 31) ^ hash(self.action_reflector_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss_action_spec_t:
  """
  Attributes:
   - action_switchos_sid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_switchos_sid', None, None, ), # 1
  )

  def __init__(self, action_switchos_sid=None,):
    self.action_switchos_sid = action_switchos_sid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_switchos_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss_action_spec_t')
    if self.action_switchos_sid is not None:
      oprot.writeFieldBegin('action_switchos_sid', TType.I32, 1)
      oprot.writeI32(self.action_switchos_sid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_switchos_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_switchos_sid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_switchos_sid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone_action_spec_t:
  """
  Attributes:
   - action_switchos_sid
   - action_reflector_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_switchos_sid', None, None, ), # 1
    (2, TType.I16, 'action_reflector_port', None, None, ), # 2
  )

  def __init__(self, action_switchos_sid=None, action_reflector_port=None,):
    self.action_switchos_sid = action_switchos_sid
    self.action_reflector_port = action_reflector_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_switchos_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_reflector_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone_action_spec_t')
    if self.action_switchos_sid is not None:
      oprot.writeFieldBegin('action_switchos_sid', TType.I32, 1)
      oprot.writeI32(self.action_switchos_sid)
      oprot.writeFieldEnd()
    if self.action_reflector_port is not None:
      oprot.writeFieldBegin('action_reflector_port', TType.I16, 2)
      oprot.writeI16(self.action_reflector_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_switchos_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_switchos_sid is unset!')
    if self.action_reflector_port is None:
      raise TProtocol.TProtocolException(message='Required field action_reflector_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_switchos_sid)
    value = (value * 31) ^ hash(self.action_reflector_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_putreq_inswitch_to_putres_by_mirroring_action_spec_t:
  """
  Attributes:
   - action_client_sid
   - action_server_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_client_sid', None, None, ), # 1
    (2, TType.I16, 'action_server_port', None, None, ), # 2
  )

  def __init__(self, action_client_sid=None, action_server_port=None,):
    self.action_client_sid = action_client_sid
    self.action_server_port = action_server_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_client_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_server_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_putreq_inswitch_to_putres_by_mirroring_action_spec_t')
    if self.action_client_sid is not None:
      oprot.writeFieldBegin('action_client_sid', TType.I32, 1)
      oprot.writeI32(self.action_client_sid)
      oprot.writeFieldEnd()
    if self.action_server_port is not None:
      oprot.writeFieldBegin('action_server_port', TType.I16, 2)
      oprot.writeI16(self.action_server_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_client_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_client_sid is unset!')
    if self.action_server_port is None:
      raise TProtocol.TProtocolException(message='Required field action_server_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_client_sid)
    value = (value * 31) ^ hash(self.action_server_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres_action_spec_t:
  """
  Attributes:
   - action_switchos_sid
   - action_stat
   - action_reflector_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_switchos_sid', None, None, ), # 1
    (2, TType.BYTE, 'action_stat', None, None, ), # 2
    (3, TType.I16, 'action_reflector_port', None, None, ), # 3
  )

  def __init__(self, action_switchos_sid=None, action_stat=None, action_reflector_port=None,):
    self.action_switchos_sid = action_switchos_sid
    self.action_stat = action_stat
    self.action_reflector_port = action_reflector_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_switchos_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_stat = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.action_reflector_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres_action_spec_t')
    if self.action_switchos_sid is not None:
      oprot.writeFieldBegin('action_switchos_sid', TType.I32, 1)
      oprot.writeI32(self.action_switchos_sid)
      oprot.writeFieldEnd()
    if self.action_stat is not None:
      oprot.writeFieldBegin('action_stat', TType.BYTE, 2)
      oprot.writeByte(self.action_stat)
      oprot.writeFieldEnd()
    if self.action_reflector_port is not None:
      oprot.writeFieldBegin('action_reflector_port', TType.I16, 3)
      oprot.writeI16(self.action_reflector_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_switchos_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_switchos_sid is unset!')
    if self.action_stat is None:
      raise TProtocol.TProtocolException(message='Required field action_stat is unset!')
    if self.action_reflector_port is None:
      raise TProtocol.TProtocolException(message='Required field action_reflector_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_switchos_sid)
    value = (value * 31) ^ hash(self.action_stat)
    value = (value * 31) ^ hash(self.action_reflector_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres_action_spec_t:
  """
  Attributes:
   - action_switchos_sid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_switchos_sid', None, None, ), # 1
  )

  def __init__(self, action_switchos_sid=None,):
    self.action_switchos_sid = action_switchos_sid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_switchos_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres_action_spec_t')
    if self.action_switchos_sid is not None:
      oprot.writeFieldBegin('action_switchos_sid', TType.I32, 1)
      oprot.writeI32(self.action_switchos_sid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_switchos_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_switchos_sid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_switchos_sid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring_action_spec_t:
  """
  Attributes:
   - action_client_sid
   - action_server_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_client_sid', None, None, ), # 1
    (2, TType.I16, 'action_server_port', None, None, ), # 2
  )

  def __init__(self, action_client_sid=None, action_server_port=None,):
    self.action_client_sid = action_client_sid
    self.action_server_port = action_server_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_client_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_server_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring_action_spec_t')
    if self.action_client_sid is not None:
      oprot.writeFieldBegin('action_client_sid', TType.I32, 1)
      oprot.writeI32(self.action_client_sid)
      oprot.writeFieldEnd()
    if self.action_server_port is not None:
      oprot.writeFieldBegin('action_server_port', TType.I16, 2)
      oprot.writeI16(self.action_server_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_client_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_client_sid is unset!')
    if self.action_server_port is None:
      raise TProtocol.TProtocolException(message='Required field action_server_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_client_sid)
    value = (value * 31) ^ hash(self.action_server_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_delreq_inswitch_to_delres_by_mirroring_action_spec_t:
  """
  Attributes:
   - action_client_sid
   - action_server_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_client_sid', None, None, ), # 1
    (2, TType.I16, 'action_server_port', None, None, ), # 2
  )

  def __init__(self, action_client_sid=None, action_server_port=None,):
    self.action_client_sid = action_client_sid
    self.action_server_port = action_server_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_client_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_server_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_delreq_inswitch_to_delres_by_mirroring_action_spec_t')
    if self.action_client_sid is not None:
      oprot.writeFieldBegin('action_client_sid', TType.I32, 1)
      oprot.writeI32(self.action_client_sid)
      oprot.writeFieldEnd()
    if self.action_server_port is not None:
      oprot.writeFieldBegin('action_server_port', TType.I16, 2)
      oprot.writeI16(self.action_server_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_client_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_client_sid is unset!')
    if self.action_server_port is None:
      raise TProtocol.TProtocolException(message='Required field action_server_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_client_sid)
    value = (value * 31) ^ hash(self.action_server_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres_action_spec_t:
  """
  Attributes:
   - action_switchos_sid
   - action_stat
   - action_reflector_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_switchos_sid', None, None, ), # 1
    (2, TType.BYTE, 'action_stat', None, None, ), # 2
    (3, TType.I16, 'action_reflector_port', None, None, ), # 3
  )

  def __init__(self, action_switchos_sid=None, action_stat=None, action_reflector_port=None,):
    self.action_switchos_sid = action_switchos_sid
    self.action_stat = action_stat
    self.action_reflector_port = action_reflector_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_switchos_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BYTE:
          self.action_stat = iprot.readByte();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I16:
          self.action_reflector_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres_action_spec_t')
    if self.action_switchos_sid is not None:
      oprot.writeFieldBegin('action_switchos_sid', TType.I32, 1)
      oprot.writeI32(self.action_switchos_sid)
      oprot.writeFieldEnd()
    if self.action_stat is not None:
      oprot.writeFieldBegin('action_stat', TType.BYTE, 2)
      oprot.writeByte(self.action_stat)
      oprot.writeFieldEnd()
    if self.action_reflector_port is not None:
      oprot.writeFieldBegin('action_reflector_port', TType.I16, 3)
      oprot.writeI16(self.action_reflector_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_switchos_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_switchos_sid is unset!')
    if self.action_stat is None:
      raise TProtocol.TProtocolException(message='Required field action_stat is unset!')
    if self.action_reflector_port is None:
      raise TProtocol.TProtocolException(message='Required field action_reflector_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_switchos_sid)
    value = (value * 31) ^ hash(self.action_stat)
    value = (value * 31) ^ hash(self.action_reflector_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres_action_spec_t:
  """
  Attributes:
   - action_switchos_sid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_switchos_sid', None, None, ), # 1
  )

  def __init__(self, action_switchos_sid=None,):
    self.action_switchos_sid = action_switchos_sid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_switchos_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres_action_spec_t')
    if self.action_switchos_sid is not None:
      oprot.writeFieldBegin('action_switchos_sid', TType.I32, 1)
      oprot.writeI32(self.action_switchos_sid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_switchos_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_switchos_sid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_switchos_sid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring_action_spec_t:
  """
  Attributes:
   - action_client_sid
   - action_server_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_client_sid', None, None, ), # 1
    (2, TType.I16, 'action_server_port', None, None, ), # 2
  )

  def __init__(self, action_client_sid=None, action_server_port=None,):
    self.action_client_sid = action_client_sid
    self.action_server_port = action_server_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_client_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_server_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring_action_spec_t')
    if self.action_client_sid is not None:
      oprot.writeFieldBegin('action_client_sid', TType.I32, 1)
      oprot.writeI32(self.action_client_sid)
      oprot.writeFieldEnd()
    if self.action_server_port is not None:
      oprot.writeFieldBegin('action_server_port', TType.I16, 2)
      oprot.writeI16(self.action_server_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_client_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_client_sid is unset!')
    if self.action_server_port is None:
      raise TProtocol.TProtocolException(message='Required field action_server_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_client_sid)
    value = (value * 31) ^ hash(self.action_server_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_forward_scanreq_split_and_clone_action_spec_t:
  """
  Attributes:
   - action_server_sid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_server_sid', None, None, ), # 1
  )

  def __init__(self, action_server_sid=None,):
    self.action_server_sid = action_server_sid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_server_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_forward_scanreq_split_and_clone_action_spec_t')
    if self.action_server_sid is not None:
      oprot.writeFieldBegin('action_server_sid', TType.I32, 1)
      oprot.writeI32(self.action_server_sid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_server_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_server_sid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_server_sid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone_action_spec_t:
  """
  Attributes:
   - action_switchos_sid
   - action_reflector_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_switchos_sid', None, None, ), # 1
    (2, TType.I16, 'action_reflector_port', None, None, ), # 2
  )

  def __init__(self, action_switchos_sid=None, action_reflector_port=None,):
    self.action_switchos_sid = action_switchos_sid
    self.action_reflector_port = action_reflector_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_switchos_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_reflector_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone_action_spec_t')
    if self.action_switchos_sid is not None:
      oprot.writeFieldBegin('action_switchos_sid', TType.I32, 1)
      oprot.writeI32(self.action_switchos_sid)
      oprot.writeFieldEnd()
    if self.action_reflector_port is not None:
      oprot.writeFieldBegin('action_reflector_port', TType.I16, 2)
      oprot.writeI16(self.action_reflector_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_switchos_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_switchos_sid is unset!')
    if self.action_reflector_port is None:
      raise TProtocol.TProtocolException(message='Required field action_reflector_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_switchos_sid)
    value = (value * 31) ^ hash(self.action_reflector_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone_action_spec_t:
  """
  Attributes:
   - action_switchos_sid
   - action_reflector_port
   - action_stat
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_switchos_sid', None, None, ), # 1
    (2, TType.I16, 'action_reflector_port', None, None, ), # 2
    (3, TType.BYTE, 'action_stat', None, None, ), # 3
  )

  def __init__(self, action_switchos_sid=None, action_reflector_port=None, action_stat=None,):
    self.action_switchos_sid = action_switchos_sid
    self.action_reflector_port = action_reflector_port
    self.action_stat = action_stat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_switchos_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_reflector_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BYTE:
          self.action_stat = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone_action_spec_t')
    if self.action_switchos_sid is not None:
      oprot.writeFieldBegin('action_switchos_sid', TType.I32, 1)
      oprot.writeI32(self.action_switchos_sid)
      oprot.writeFieldEnd()
    if self.action_reflector_port is not None:
      oprot.writeFieldBegin('action_reflector_port', TType.I16, 2)
      oprot.writeI16(self.action_reflector_port)
      oprot.writeFieldEnd()
    if self.action_stat is not None:
      oprot.writeFieldBegin('action_stat', TType.BYTE, 3)
      oprot.writeByte(self.action_stat)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_switchos_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_switchos_sid is unset!')
    if self.action_reflector_port is None:
      raise TProtocol.TProtocolException(message='Required field action_reflector_port is unset!')
    if self.action_stat is None:
      raise TProtocol.TProtocolException(message='Required field action_stat is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_switchos_sid)
    value = (value * 31) ^ hash(self.action_reflector_port)
    value = (value * 31) ^ hash(self.action_stat)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone_action_spec_t:
  """
  Attributes:
   - action_switchos_sid
   - action_reflector_port
   - action_stat
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_switchos_sid', None, None, ), # 1
    (2, TType.I16, 'action_reflector_port', None, None, ), # 2
    (3, TType.I32, 'action_stat', None, None, ), # 3
  )

  def __init__(self, action_switchos_sid=None, action_reflector_port=None, action_stat=None,):
    self.action_switchos_sid = action_switchos_sid
    self.action_reflector_port = action_reflector_port
    self.action_stat = action_stat

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_switchos_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_reflector_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.action_stat = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone_action_spec_t')
    if self.action_switchos_sid is not None:
      oprot.writeFieldBegin('action_switchos_sid', TType.I32, 1)
      oprot.writeI32(self.action_switchos_sid)
      oprot.writeFieldEnd()
    if self.action_reflector_port is not None:
      oprot.writeFieldBegin('action_reflector_port', TType.I16, 2)
      oprot.writeI16(self.action_reflector_port)
      oprot.writeFieldEnd()
    if self.action_stat is not None:
      oprot.writeFieldBegin('action_stat', TType.I32, 3)
      oprot.writeI32(self.action_stat)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_switchos_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_switchos_sid is unset!')
    if self.action_reflector_port is None:
      raise TProtocol.TProtocolException(message='Required field action_reflector_port is unset!')
    if self.action_stat is None:
      raise TProtocol.TProtocolException(message='Required field action_stat is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_switchos_sid)
    value = (value * 31) ^ hash(self.action_reflector_port)
    value = (value * 31) ^ hash(self.action_stat)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone_action_spec_t:
  """
  Attributes:
   - action_switchos_sid
   - action_reflector_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_switchos_sid', None, None, ), # 1
    (2, TType.I16, 'action_reflector_port', None, None, ), # 2
  )

  def __init__(self, action_switchos_sid=None, action_reflector_port=None,):
    self.action_switchos_sid = action_switchos_sid
    self.action_reflector_port = action_reflector_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_switchos_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_reflector_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone_action_spec_t')
    if self.action_switchos_sid is not None:
      oprot.writeFieldBegin('action_switchos_sid', TType.I32, 1)
      oprot.writeI32(self.action_switchos_sid)
      oprot.writeFieldEnd()
    if self.action_reflector_port is not None:
      oprot.writeFieldBegin('action_reflector_port', TType.I16, 2)
      oprot.writeI16(self.action_reflector_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_switchos_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_switchos_sid is unset!')
    if self.action_reflector_port is None:
      raise TProtocol.TProtocolException(message='Required field action_reflector_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_switchos_sid)
    value = (value * 31) ^ hash(self.action_reflector_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_forward_normal_response_action_spec_t:
  """
  Attributes:
   - action_eport
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_eport', None, None, ), # 1
  )

  def __init__(self, action_eport=None,):
    self.action_eport = action_eport

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_eport = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_forward_normal_response_action_spec_t')
    if self.action_eport is not None:
      oprot.writeFieldBegin('action_eport', TType.I16, 1)
      oprot.writeI16(self.action_eport)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_eport is None:
      raise TProtocol.TProtocolException(message='Required field action_eport is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_eport)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_forward_special_get_response_action_spec_t:
  """
  Attributes:
   - action_client_sid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'action_client_sid', None, None, ), # 1
  )

  def __init__(self, action_client_sid=None,):
    self.action_client_sid = action_client_sid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.action_client_sid = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_forward_special_get_response_action_spec_t')
    if self.action_client_sid is not None:
      oprot.writeFieldBegin('action_client_sid', TType.I32, 1)
      oprot.writeI32(self.action_client_sid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_client_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_client_sid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_client_sid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_set_client_sid_action_spec_t:
  """
  Attributes:
   - action_client_sid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_client_sid', None, None, ), # 1
  )

  def __init__(self, action_client_sid=None,):
    self.action_client_sid = action_client_sid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_client_sid = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_set_client_sid_action_spec_t')
    if self.action_client_sid is not None:
      oprot.writeFieldBegin('action_client_sid', TType.I16, 1)
      oprot.writeI16(self.action_client_sid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_client_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_client_sid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_client_sid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_process_scanreq_split_action_spec_t:
  """
  Attributes:
   - action_server_sid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_server_sid', None, None, ), # 1
  )

  def __init__(self, action_server_sid=None,):
    self.action_server_sid = action_server_sid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_server_sid = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_process_scanreq_split_action_spec_t')
    if self.action_server_sid is not None:
      oprot.writeFieldBegin('action_server_sid', TType.I16, 1)
      oprot.writeI16(self.action_server_sid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_server_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_server_sid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_server_sid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_process_cloned_scanreq_split_action_spec_t:
  """
  Attributes:
   - action_server_sid
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_server_sid', None, None, ), # 1
  )

  def __init__(self, action_server_sid=None,):
    self.action_server_sid = action_server_sid

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_server_sid = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_process_cloned_scanreq_split_action_spec_t')
    if self.action_server_sid is not None:
      oprot.writeFieldBegin('action_server_sid', TType.I16, 1)
      oprot.writeI16(self.action_server_sid)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_server_sid is None:
      raise TProtocol.TProtocolException(message='Required field action_server_sid is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_server_sid)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_range_partition_for_scan_endkey_action_spec_t:
  """
  Attributes:
   - action_last_udpport_plus_one
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_last_udpport_plus_one', None, None, ), # 1
  )

  def __init__(self, action_last_udpport_plus_one=None,):
    self.action_last_udpport_plus_one = action_last_udpport_plus_one

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_last_udpport_plus_one = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_range_partition_for_scan_endkey_action_spec_t')
    if self.action_last_udpport_plus_one is not None:
      oprot.writeFieldBegin('action_last_udpport_plus_one', TType.I16, 1)
      oprot.writeI16(self.action_last_udpport_plus_one)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_last_udpport_plus_one is None:
      raise TProtocol.TProtocolException(message='Required field action_last_udpport_plus_one is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_last_udpport_plus_one)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_range_partition_action_spec_t:
  """
  Attributes:
   - action_udpport
   - action_eport
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_udpport', None, None, ), # 1
    (2, TType.I16, 'action_eport', None, None, ), # 2
  )

  def __init__(self, action_udpport=None, action_eport=None,):
    self.action_udpport = action_udpport
    self.action_eport = action_eport

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_udpport = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_eport = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_range_partition_action_spec_t')
    if self.action_udpport is not None:
      oprot.writeFieldBegin('action_udpport', TType.I16, 1)
      oprot.writeI16(self.action_udpport)
      oprot.writeFieldEnd()
    if self.action_eport is not None:
      oprot.writeFieldBegin('action_eport', TType.I16, 2)
      oprot.writeI16(self.action_eport)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_udpport is None:
      raise TProtocol.TProtocolException(message='Required field action_udpport is unset!')
    if self.action_eport is None:
      raise TProtocol.TProtocolException(message='Required field action_eport is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_udpport)
    value = (value * 31) ^ hash(self.action_eport)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_recirculate_pkt_action_spec_t:
  """
  Attributes:
   - action_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.BYTE, 'action_port', None, None, ), # 1
  )

  def __init__(self, action_port=None,):
    self.action_port = action_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BYTE:
          self.action_port = iprot.readByte();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_recirculate_pkt_action_spec_t')
    if self.action_port is not None:
      oprot.writeFieldBegin('action_port', TType.BYTE, 1)
      oprot.writeByte(self.action_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_port is None:
      raise TProtocol.TProtocolException(message='Required field action_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_set_hot_threshold_action_spec_t:
  """
  Attributes:
   - action_hot_threshold
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_hot_threshold', None, None, ), # 1
  )

  def __init__(self, action_hot_threshold=None,):
    self.action_hot_threshold = action_hot_threshold

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_hot_threshold = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_set_hot_threshold_action_spec_t')
    if self.action_hot_threshold is not None:
      oprot.writeFieldBegin('action_hot_threshold', TType.I16, 1)
      oprot.writeI16(self.action_hot_threshold)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_hot_threshold is None:
      raise TProtocol.TProtocolException(message='Required field action_hot_threshold is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_hot_threshold)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_ipmac_srcport_server2client_action_spec_t:
  """
  Attributes:
   - action_client_mac
   - action_server_mac
   - action_client_ip
   - action_server_ip
   - action_server_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'action_client_mac', None, None, ), # 1
    (2, TType.STRING, 'action_server_mac', None, None, ), # 2
    (3, TType.I32, 'action_client_ip', None, None, ), # 3
    (4, TType.I32, 'action_server_ip', None, None, ), # 4
    (5, TType.I16, 'action_server_port', None, None, ), # 5
  )

  def __init__(self, action_client_mac=None, action_server_mac=None, action_client_ip=None, action_server_ip=None, action_server_port=None,):
    self.action_client_mac = action_client_mac
    self.action_server_mac = action_server_mac
    self.action_client_ip = action_client_ip
    self.action_server_ip = action_server_ip
    self.action_server_port = action_server_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.action_client_mac = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.action_server_mac = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.action_client_ip = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.action_server_ip = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.action_server_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_ipmac_srcport_server2client_action_spec_t')
    if self.action_client_mac is not None:
      oprot.writeFieldBegin('action_client_mac', TType.STRING, 1)
      oprot.writeString(self.action_client_mac)
      oprot.writeFieldEnd()
    if self.action_server_mac is not None:
      oprot.writeFieldBegin('action_server_mac', TType.STRING, 2)
      oprot.writeString(self.action_server_mac)
      oprot.writeFieldEnd()
    if self.action_client_ip is not None:
      oprot.writeFieldBegin('action_client_ip', TType.I32, 3)
      oprot.writeI32(self.action_client_ip)
      oprot.writeFieldEnd()
    if self.action_server_ip is not None:
      oprot.writeFieldBegin('action_server_ip', TType.I32, 4)
      oprot.writeI32(self.action_server_ip)
      oprot.writeFieldEnd()
    if self.action_server_port is not None:
      oprot.writeFieldBegin('action_server_port', TType.I16, 5)
      oprot.writeI16(self.action_server_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_client_mac is None:
      raise TProtocol.TProtocolException(message='Required field action_client_mac is unset!')
    if self.action_server_mac is None:
      raise TProtocol.TProtocolException(message='Required field action_server_mac is unset!')
    if self.action_client_ip is None:
      raise TProtocol.TProtocolException(message='Required field action_client_ip is unset!')
    if self.action_server_ip is None:
      raise TProtocol.TProtocolException(message='Required field action_server_ip is unset!')
    if self.action_server_port is None:
      raise TProtocol.TProtocolException(message='Required field action_server_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_client_mac)
    value = (value * 31) ^ hash(self.action_server_mac)
    value = (value * 31) ^ hash(self.action_client_ip)
    value = (value * 31) ^ hash(self.action_server_ip)
    value = (value * 31) ^ hash(self.action_server_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_ipmac_srcport_switch2switchos_action_spec_t:
  """
  Attributes:
   - action_client_mac
   - action_switch_mac
   - action_client_ip
   - action_switch_ip
   - action_client_port
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'action_client_mac', None, None, ), # 1
    (2, TType.STRING, 'action_switch_mac', None, None, ), # 2
    (3, TType.I32, 'action_client_ip', None, None, ), # 3
    (4, TType.I32, 'action_switch_ip', None, None, ), # 4
    (5, TType.I16, 'action_client_port', None, None, ), # 5
  )

  def __init__(self, action_client_mac=None, action_switch_mac=None, action_client_ip=None, action_switch_ip=None, action_client_port=None,):
    self.action_client_mac = action_client_mac
    self.action_switch_mac = action_switch_mac
    self.action_client_ip = action_client_ip
    self.action_switch_ip = action_switch_ip
    self.action_client_port = action_client_port

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.action_client_mac = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRING:
          self.action_switch_mac = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.action_client_ip = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.action_switch_ip = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I16:
          self.action_client_port = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_ipmac_srcport_switch2switchos_action_spec_t')
    if self.action_client_mac is not None:
      oprot.writeFieldBegin('action_client_mac', TType.STRING, 1)
      oprot.writeString(self.action_client_mac)
      oprot.writeFieldEnd()
    if self.action_switch_mac is not None:
      oprot.writeFieldBegin('action_switch_mac', TType.STRING, 2)
      oprot.writeString(self.action_switch_mac)
      oprot.writeFieldEnd()
    if self.action_client_ip is not None:
      oprot.writeFieldBegin('action_client_ip', TType.I32, 3)
      oprot.writeI32(self.action_client_ip)
      oprot.writeFieldEnd()
    if self.action_switch_ip is not None:
      oprot.writeFieldBegin('action_switch_ip', TType.I32, 4)
      oprot.writeI32(self.action_switch_ip)
      oprot.writeFieldEnd()
    if self.action_client_port is not None:
      oprot.writeFieldBegin('action_client_port', TType.I16, 5)
      oprot.writeI16(self.action_client_port)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_client_mac is None:
      raise TProtocol.TProtocolException(message='Required field action_client_mac is unset!')
    if self.action_switch_mac is None:
      raise TProtocol.TProtocolException(message='Required field action_switch_mac is unset!')
    if self.action_client_ip is None:
      raise TProtocol.TProtocolException(message='Required field action_client_ip is unset!')
    if self.action_switch_ip is None:
      raise TProtocol.TProtocolException(message='Required field action_switch_ip is unset!')
    if self.action_client_port is None:
      raise TProtocol.TProtocolException(message='Required field action_client_port is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_client_mac)
    value = (value * 31) ^ hash(self.action_switch_mac)
    value = (value * 31) ^ hash(self.action_client_ip)
    value = (value * 31) ^ hash(self.action_switch_ip)
    value = (value * 31) ^ hash(self.action_client_port)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_dstipmac_client2server_action_spec_t:
  """
  Attributes:
   - action_server_mac
   - action_server_ip
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'action_server_mac', None, None, ), # 1
    (2, TType.I32, 'action_server_ip', None, None, ), # 2
  )

  def __init__(self, action_server_mac=None, action_server_ip=None,):
    self.action_server_mac = action_server_mac
    self.action_server_ip = action_server_ip

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.action_server_mac = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I32:
          self.action_server_ip = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_dstipmac_client2server_action_spec_t')
    if self.action_server_mac is not None:
      oprot.writeFieldBegin('action_server_mac', TType.STRING, 1)
      oprot.writeString(self.action_server_mac)
      oprot.writeFieldEnd()
    if self.action_server_ip is not None:
      oprot.writeFieldBegin('action_server_ip', TType.I32, 2)
      oprot.writeI32(self.action_server_ip)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_server_mac is None:
      raise TProtocol.TProtocolException(message='Required field action_server_mac is unset!')
    if self.action_server_ip is None:
      raise TProtocol.TProtocolException(message='Required field action_server_ip is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_server_mac)
    value = (value * 31) ^ hash(self.action_server_ip)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_pktlen_action_spec_t:
  """
  Attributes:
   - action_udplen
   - action_iplen
  """

  thrift_spec = (
    None, # 0
    (1, TType.I16, 'action_udplen', None, None, ), # 1
    (2, TType.I16, 'action_iplen', None, None, ), # 2
  )

  def __init__(self, action_udplen=None, action_iplen=None,):
    self.action_udplen = action_udplen
    self.action_iplen = action_iplen

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I16:
          self.action_udplen = iprot.readI16();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.I16:
          self.action_iplen = iprot.readI16();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_pktlen_action_spec_t')
    if self.action_udplen is not None:
      oprot.writeFieldBegin('action_udplen', TType.I16, 1)
      oprot.writeI16(self.action_udplen)
      oprot.writeFieldEnd()
    if self.action_iplen is not None:
      oprot.writeFieldBegin('action_iplen', TType.I16, 2)
      oprot.writeI16(self.action_iplen)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.action_udplen is None:
      raise TProtocol.TProtocolException(message='Required field action_udplen is unset!')
    if self.action_iplen is None:
      raise TProtocol.TProtocolException(message='Required field action_iplen is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.action_udplen)
    value = (value * 31) ^ hash(self.action_iplen)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_action_specs_t:
  """
  Attributes:
   - netbufferv4_cached_action
   - netbufferv4_update_getreq_inswitch_to_getres_by_mirroring
   - netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss
   - netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss
   - netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss
   - netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss
   - netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone
   - netbufferv4_update_putreq_inswitch_to_putres_by_mirroring
   - netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres
   - netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres
   - netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring
   - netbufferv4_update_delreq_inswitch_to_delres_by_mirroring
   - netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres
   - netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres
   - netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring
   - netbufferv4_forward_scanreq_split_and_clone
   - netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone
   - netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone
   - netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone
   - netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone
   - netbufferv4_forward_normal_response
   - netbufferv4_forward_special_get_response
   - netbufferv4_set_client_sid
   - netbufferv4_process_scanreq_split
   - netbufferv4_process_cloned_scanreq_split
   - netbufferv4_range_partition_for_scan_endkey
   - netbufferv4_range_partition
   - netbufferv4_recirculate_pkt
   - netbufferv4_set_hot_threshold
   - netbufferv4_update_ipmac_srcport_server2client
   - netbufferv4_update_ipmac_srcport_switch2switchos
   - netbufferv4_update_dstipmac_client2server
   - netbufferv4_update_pktlen
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'netbufferv4_cached_action', (netbufferv4_cached_action_action_spec_t, netbufferv4_cached_action_action_spec_t.thrift_spec), None, ), # 1
    (2, TType.STRUCT, 'netbufferv4_update_getreq_inswitch_to_getres_by_mirroring', (netbufferv4_update_getreq_inswitch_to_getres_by_mirroring_action_spec_t, netbufferv4_update_getreq_inswitch_to_getres_by_mirroring_action_spec_t.thrift_spec), None, ), # 2
    (3, TType.STRUCT, 'netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss', (netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss_action_spec_t, netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss_action_spec_t.thrift_spec), None, ), # 3
    (4, TType.STRUCT, 'netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss', (netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss_action_spec_t, netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss_action_spec_t.thrift_spec), None, ), # 4
    (5, TType.STRUCT, 'netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss', (netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss_action_spec_t, netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss_action_spec_t.thrift_spec), None, ), # 5
    (6, TType.STRUCT, 'netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss', (netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss_action_spec_t, netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss_action_spec_t.thrift_spec), None, ), # 6
    (7, TType.STRUCT, 'netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone', (netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone_action_spec_t, netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone_action_spec_t.thrift_spec), None, ), # 7
    (8, TType.STRUCT, 'netbufferv4_update_putreq_inswitch_to_putres_by_mirroring', (netbufferv4_update_putreq_inswitch_to_putres_by_mirroring_action_spec_t, netbufferv4_update_putreq_inswitch_to_putres_by_mirroring_action_spec_t.thrift_spec), None, ), # 8
    (9, TType.STRUCT, 'netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres', (netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres_action_spec_t, netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres_action_spec_t.thrift_spec), None, ), # 9
    (10, TType.STRUCT, 'netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres', (netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres_action_spec_t, netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres_action_spec_t.thrift_spec), None, ), # 10
    (11, TType.STRUCT, 'netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring', (netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring_action_spec_t, netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring_action_spec_t.thrift_spec), None, ), # 11
    (12, TType.STRUCT, 'netbufferv4_update_delreq_inswitch_to_delres_by_mirroring', (netbufferv4_update_delreq_inswitch_to_delres_by_mirroring_action_spec_t, netbufferv4_update_delreq_inswitch_to_delres_by_mirroring_action_spec_t.thrift_spec), None, ), # 12
    (13, TType.STRUCT, 'netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres', (netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres_action_spec_t, netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres_action_spec_t.thrift_spec), None, ), # 13
    (14, TType.STRUCT, 'netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres', (netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres_action_spec_t, netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres_action_spec_t.thrift_spec), None, ), # 14
    (15, TType.STRUCT, 'netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring', (netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring_action_spec_t, netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring_action_spec_t.thrift_spec), None, ), # 15
    (16, TType.STRUCT, 'netbufferv4_forward_scanreq_split_and_clone', (netbufferv4_forward_scanreq_split_and_clone_action_spec_t, netbufferv4_forward_scanreq_split_and_clone_action_spec_t.thrift_spec), None, ), # 16
    (17, TType.STRUCT, 'netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone', (netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone_action_spec_t, netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone_action_spec_t.thrift_spec), None, ), # 17
    (18, TType.STRUCT, 'netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone', (netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone_action_spec_t, netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone_action_spec_t.thrift_spec), None, ), # 18
    (19, TType.STRUCT, 'netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone', (netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone_action_spec_t, netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone_action_spec_t.thrift_spec), None, ), # 19
    (20, TType.STRUCT, 'netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone', (netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone_action_spec_t, netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone_action_spec_t.thrift_spec), None, ), # 20
    (21, TType.STRUCT, 'netbufferv4_forward_normal_response', (netbufferv4_forward_normal_response_action_spec_t, netbufferv4_forward_normal_response_action_spec_t.thrift_spec), None, ), # 21
    (22, TType.STRUCT, 'netbufferv4_forward_special_get_response', (netbufferv4_forward_special_get_response_action_spec_t, netbufferv4_forward_special_get_response_action_spec_t.thrift_spec), None, ), # 22
    (23, TType.STRUCT, 'netbufferv4_set_client_sid', (netbufferv4_set_client_sid_action_spec_t, netbufferv4_set_client_sid_action_spec_t.thrift_spec), None, ), # 23
    (24, TType.STRUCT, 'netbufferv4_process_scanreq_split', (netbufferv4_process_scanreq_split_action_spec_t, netbufferv4_process_scanreq_split_action_spec_t.thrift_spec), None, ), # 24
    (25, TType.STRUCT, 'netbufferv4_process_cloned_scanreq_split', (netbufferv4_process_cloned_scanreq_split_action_spec_t, netbufferv4_process_cloned_scanreq_split_action_spec_t.thrift_spec), None, ), # 25
    (26, TType.STRUCT, 'netbufferv4_range_partition_for_scan_endkey', (netbufferv4_range_partition_for_scan_endkey_action_spec_t, netbufferv4_range_partition_for_scan_endkey_action_spec_t.thrift_spec), None, ), # 26
    (27, TType.STRUCT, 'netbufferv4_range_partition', (netbufferv4_range_partition_action_spec_t, netbufferv4_range_partition_action_spec_t.thrift_spec), None, ), # 27
    (28, TType.STRUCT, 'netbufferv4_recirculate_pkt', (netbufferv4_recirculate_pkt_action_spec_t, netbufferv4_recirculate_pkt_action_spec_t.thrift_spec), None, ), # 28
    (29, TType.STRUCT, 'netbufferv4_set_hot_threshold', (netbufferv4_set_hot_threshold_action_spec_t, netbufferv4_set_hot_threshold_action_spec_t.thrift_spec), None, ), # 29
    (30, TType.STRUCT, 'netbufferv4_update_ipmac_srcport_server2client', (netbufferv4_update_ipmac_srcport_server2client_action_spec_t, netbufferv4_update_ipmac_srcport_server2client_action_spec_t.thrift_spec), None, ), # 30
    (31, TType.STRUCT, 'netbufferv4_update_ipmac_srcport_switch2switchos', (netbufferv4_update_ipmac_srcport_switch2switchos_action_spec_t, netbufferv4_update_ipmac_srcport_switch2switchos_action_spec_t.thrift_spec), None, ), # 31
    (32, TType.STRUCT, 'netbufferv4_update_dstipmac_client2server', (netbufferv4_update_dstipmac_client2server_action_spec_t, netbufferv4_update_dstipmac_client2server_action_spec_t.thrift_spec), None, ), # 32
    (33, TType.STRUCT, 'netbufferv4_update_pktlen', (netbufferv4_update_pktlen_action_spec_t, netbufferv4_update_pktlen_action_spec_t.thrift_spec), None, ), # 33
  )

  def __init__(self, netbufferv4_cached_action=None, netbufferv4_update_getreq_inswitch_to_getres_by_mirroring=None, netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss=None, netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss=None, netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss=None, netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss=None, netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone=None, netbufferv4_update_putreq_inswitch_to_putres_by_mirroring=None, netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres=None, netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres=None, netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring=None, netbufferv4_update_delreq_inswitch_to_delres_by_mirroring=None, netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres=None, netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres=None, netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring=None, netbufferv4_forward_scanreq_split_and_clone=None, netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone=None, netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone=None, netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone=None, netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone=None, netbufferv4_forward_normal_response=None, netbufferv4_forward_special_get_response=None, netbufferv4_set_client_sid=None, netbufferv4_process_scanreq_split=None, netbufferv4_process_cloned_scanreq_split=None, netbufferv4_range_partition_for_scan_endkey=None, netbufferv4_range_partition=None, netbufferv4_recirculate_pkt=None, netbufferv4_set_hot_threshold=None, netbufferv4_update_ipmac_srcport_server2client=None, netbufferv4_update_ipmac_srcport_switch2switchos=None, netbufferv4_update_dstipmac_client2server=None, netbufferv4_update_pktlen=None,):
    self.netbufferv4_cached_action = netbufferv4_cached_action
    self.netbufferv4_update_getreq_inswitch_to_getres_by_mirroring = netbufferv4_update_getreq_inswitch_to_getres_by_mirroring
    self.netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss = netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss
    self.netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss = netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss
    self.netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss = netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss
    self.netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss = netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss
    self.netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone = netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone
    self.netbufferv4_update_putreq_inswitch_to_putres_by_mirroring = netbufferv4_update_putreq_inswitch_to_putres_by_mirroring
    self.netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres = netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres
    self.netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres = netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres
    self.netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring = netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring
    self.netbufferv4_update_delreq_inswitch_to_delres_by_mirroring = netbufferv4_update_delreq_inswitch_to_delres_by_mirroring
    self.netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres = netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres
    self.netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres = netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres
    self.netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring = netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring
    self.netbufferv4_forward_scanreq_split_and_clone = netbufferv4_forward_scanreq_split_and_clone
    self.netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone = netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone
    self.netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone = netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone
    self.netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone = netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone
    self.netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone = netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone
    self.netbufferv4_forward_normal_response = netbufferv4_forward_normal_response
    self.netbufferv4_forward_special_get_response = netbufferv4_forward_special_get_response
    self.netbufferv4_set_client_sid = netbufferv4_set_client_sid
    self.netbufferv4_process_scanreq_split = netbufferv4_process_scanreq_split
    self.netbufferv4_process_cloned_scanreq_split = netbufferv4_process_cloned_scanreq_split
    self.netbufferv4_range_partition_for_scan_endkey = netbufferv4_range_partition_for_scan_endkey
    self.netbufferv4_range_partition = netbufferv4_range_partition
    self.netbufferv4_recirculate_pkt = netbufferv4_recirculate_pkt
    self.netbufferv4_set_hot_threshold = netbufferv4_set_hot_threshold
    self.netbufferv4_update_ipmac_srcport_server2client = netbufferv4_update_ipmac_srcport_server2client
    self.netbufferv4_update_ipmac_srcport_switch2switchos = netbufferv4_update_ipmac_srcport_switch2switchos
    self.netbufferv4_update_dstipmac_client2server = netbufferv4_update_dstipmac_client2server
    self.netbufferv4_update_pktlen = netbufferv4_update_pktlen

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.netbufferv4_cached_action = netbufferv4_cached_action_action_spec_t()
          self.netbufferv4_cached_action.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_getreq_inswitch_to_getres_by_mirroring = netbufferv4_update_getreq_inswitch_to_getres_by_mirroring_action_spec_t()
          self.netbufferv4_update_getreq_inswitch_to_getres_by_mirroring.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss = netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss_action_spec_t()
          self.netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.STRUCT:
          self.netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss = netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss_action_spec_t()
          self.netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss = netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss_action_spec_t()
          self.netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss = netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss_action_spec_t()
          self.netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone = netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone_action_spec_t()
          self.netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 8:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_putreq_inswitch_to_putres_by_mirroring = netbufferv4_update_putreq_inswitch_to_putres_by_mirroring_action_spec_t()
          self.netbufferv4_update_putreq_inswitch_to_putres_by_mirroring.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 9:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres = netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres_action_spec_t()
          self.netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 10:
        if ftype == TType.STRUCT:
          self.netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres = netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres_action_spec_t()
          self.netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 11:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring = netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring_action_spec_t()
          self.netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 12:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_delreq_inswitch_to_delres_by_mirroring = netbufferv4_update_delreq_inswitch_to_delres_by_mirroring_action_spec_t()
          self.netbufferv4_update_delreq_inswitch_to_delres_by_mirroring.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 13:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres = netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres_action_spec_t()
          self.netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 14:
        if ftype == TType.STRUCT:
          self.netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres = netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres_action_spec_t()
          self.netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 15:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring = netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring_action_spec_t()
          self.netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 16:
        if ftype == TType.STRUCT:
          self.netbufferv4_forward_scanreq_split_and_clone = netbufferv4_forward_scanreq_split_and_clone_action_spec_t()
          self.netbufferv4_forward_scanreq_split_and_clone.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 17:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone = netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone_action_spec_t()
          self.netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 18:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone = netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone_action_spec_t()
          self.netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 19:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone = netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone_action_spec_t()
          self.netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 20:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone = netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone_action_spec_t()
          self.netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 21:
        if ftype == TType.STRUCT:
          self.netbufferv4_forward_normal_response = netbufferv4_forward_normal_response_action_spec_t()
          self.netbufferv4_forward_normal_response.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 22:
        if ftype == TType.STRUCT:
          self.netbufferv4_forward_special_get_response = netbufferv4_forward_special_get_response_action_spec_t()
          self.netbufferv4_forward_special_get_response.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 23:
        if ftype == TType.STRUCT:
          self.netbufferv4_set_client_sid = netbufferv4_set_client_sid_action_spec_t()
          self.netbufferv4_set_client_sid.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 24:
        if ftype == TType.STRUCT:
          self.netbufferv4_process_scanreq_split = netbufferv4_process_scanreq_split_action_spec_t()
          self.netbufferv4_process_scanreq_split.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 25:
        if ftype == TType.STRUCT:
          self.netbufferv4_process_cloned_scanreq_split = netbufferv4_process_cloned_scanreq_split_action_spec_t()
          self.netbufferv4_process_cloned_scanreq_split.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 26:
        if ftype == TType.STRUCT:
          self.netbufferv4_range_partition_for_scan_endkey = netbufferv4_range_partition_for_scan_endkey_action_spec_t()
          self.netbufferv4_range_partition_for_scan_endkey.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 27:
        if ftype == TType.STRUCT:
          self.netbufferv4_range_partition = netbufferv4_range_partition_action_spec_t()
          self.netbufferv4_range_partition.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 28:
        if ftype == TType.STRUCT:
          self.netbufferv4_recirculate_pkt = netbufferv4_recirculate_pkt_action_spec_t()
          self.netbufferv4_recirculate_pkt.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 29:
        if ftype == TType.STRUCT:
          self.netbufferv4_set_hot_threshold = netbufferv4_set_hot_threshold_action_spec_t()
          self.netbufferv4_set_hot_threshold.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 30:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_ipmac_srcport_server2client = netbufferv4_update_ipmac_srcport_server2client_action_spec_t()
          self.netbufferv4_update_ipmac_srcport_server2client.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 31:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_ipmac_srcport_switch2switchos = netbufferv4_update_ipmac_srcport_switch2switchos_action_spec_t()
          self.netbufferv4_update_ipmac_srcport_switch2switchos.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 32:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_dstipmac_client2server = netbufferv4_update_dstipmac_client2server_action_spec_t()
          self.netbufferv4_update_dstipmac_client2server.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 33:
        if ftype == TType.STRUCT:
          self.netbufferv4_update_pktlen = netbufferv4_update_pktlen_action_spec_t()
          self.netbufferv4_update_pktlen.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_action_specs_t')
    if self.netbufferv4_cached_action is not None:
      oprot.writeFieldBegin('netbufferv4_cached_action', TType.STRUCT, 1)
      self.netbufferv4_cached_action.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_getreq_inswitch_to_getres_by_mirroring is not None:
      oprot.writeFieldBegin('netbufferv4_update_getreq_inswitch_to_getres_by_mirroring', TType.STRUCT, 2)
      self.netbufferv4_update_getreq_inswitch_to_getres_by_mirroring.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss is not None:
      oprot.writeFieldBegin('netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss', TType.STRUCT, 3)
      self.netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss is not None:
      oprot.writeFieldBegin('netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss', TType.STRUCT, 4)
      self.netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss is not None:
      oprot.writeFieldBegin('netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss', TType.STRUCT, 5)
      self.netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss is not None:
      oprot.writeFieldBegin('netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss', TType.STRUCT, 6)
      self.netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone is not None:
      oprot.writeFieldBegin('netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone', TType.STRUCT, 7)
      self.netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_putreq_inswitch_to_putres_by_mirroring is not None:
      oprot.writeFieldBegin('netbufferv4_update_putreq_inswitch_to_putres_by_mirroring', TType.STRUCT, 8)
      self.netbufferv4_update_putreq_inswitch_to_putres_by_mirroring.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres is not None:
      oprot.writeFieldBegin('netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres', TType.STRUCT, 9)
      self.netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres is not None:
      oprot.writeFieldBegin('netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres', TType.STRUCT, 10)
      self.netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring is not None:
      oprot.writeFieldBegin('netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring', TType.STRUCT, 11)
      self.netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_delreq_inswitch_to_delres_by_mirroring is not None:
      oprot.writeFieldBegin('netbufferv4_update_delreq_inswitch_to_delres_by_mirroring', TType.STRUCT, 12)
      self.netbufferv4_update_delreq_inswitch_to_delres_by_mirroring.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres is not None:
      oprot.writeFieldBegin('netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres', TType.STRUCT, 13)
      self.netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres is not None:
      oprot.writeFieldBegin('netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres', TType.STRUCT, 14)
      self.netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring is not None:
      oprot.writeFieldBegin('netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring', TType.STRUCT, 15)
      self.netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_forward_scanreq_split_and_clone is not None:
      oprot.writeFieldBegin('netbufferv4_forward_scanreq_split_and_clone', TType.STRUCT, 16)
      self.netbufferv4_forward_scanreq_split_and_clone.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone is not None:
      oprot.writeFieldBegin('netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone', TType.STRUCT, 17)
      self.netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone is not None:
      oprot.writeFieldBegin('netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone', TType.STRUCT, 18)
      self.netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone is not None:
      oprot.writeFieldBegin('netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone', TType.STRUCT, 19)
      self.netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone is not None:
      oprot.writeFieldBegin('netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone', TType.STRUCT, 20)
      self.netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_forward_normal_response is not None:
      oprot.writeFieldBegin('netbufferv4_forward_normal_response', TType.STRUCT, 21)
      self.netbufferv4_forward_normal_response.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_forward_special_get_response is not None:
      oprot.writeFieldBegin('netbufferv4_forward_special_get_response', TType.STRUCT, 22)
      self.netbufferv4_forward_special_get_response.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_set_client_sid is not None:
      oprot.writeFieldBegin('netbufferv4_set_client_sid', TType.STRUCT, 23)
      self.netbufferv4_set_client_sid.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_process_scanreq_split is not None:
      oprot.writeFieldBegin('netbufferv4_process_scanreq_split', TType.STRUCT, 24)
      self.netbufferv4_process_scanreq_split.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_process_cloned_scanreq_split is not None:
      oprot.writeFieldBegin('netbufferv4_process_cloned_scanreq_split', TType.STRUCT, 25)
      self.netbufferv4_process_cloned_scanreq_split.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_range_partition_for_scan_endkey is not None:
      oprot.writeFieldBegin('netbufferv4_range_partition_for_scan_endkey', TType.STRUCT, 26)
      self.netbufferv4_range_partition_for_scan_endkey.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_range_partition is not None:
      oprot.writeFieldBegin('netbufferv4_range_partition', TType.STRUCT, 27)
      self.netbufferv4_range_partition.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_recirculate_pkt is not None:
      oprot.writeFieldBegin('netbufferv4_recirculate_pkt', TType.STRUCT, 28)
      self.netbufferv4_recirculate_pkt.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_set_hot_threshold is not None:
      oprot.writeFieldBegin('netbufferv4_set_hot_threshold', TType.STRUCT, 29)
      self.netbufferv4_set_hot_threshold.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_ipmac_srcport_server2client is not None:
      oprot.writeFieldBegin('netbufferv4_update_ipmac_srcport_server2client', TType.STRUCT, 30)
      self.netbufferv4_update_ipmac_srcport_server2client.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_ipmac_srcport_switch2switchos is not None:
      oprot.writeFieldBegin('netbufferv4_update_ipmac_srcport_switch2switchos', TType.STRUCT, 31)
      self.netbufferv4_update_ipmac_srcport_switch2switchos.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_dstipmac_client2server is not None:
      oprot.writeFieldBegin('netbufferv4_update_dstipmac_client2server', TType.STRUCT, 32)
      self.netbufferv4_update_dstipmac_client2server.write(oprot)
      oprot.writeFieldEnd()
    if self.netbufferv4_update_pktlen is not None:
      oprot.writeFieldBegin('netbufferv4_update_pktlen', TType.STRUCT, 33)
      self.netbufferv4_update_pktlen.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.netbufferv4_cached_action)
    value = (value * 31) ^ hash(self.netbufferv4_update_getreq_inswitch_to_getres_by_mirroring)
    value = (value * 31) ^ hash(self.netbufferv4_update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss)
    value = (value * 31) ^ hash(self.netbufferv4_forward_getres_latest_seq_inswitch_case1_clone_for_pktloss)
    value = (value * 31) ^ hash(self.netbufferv4_update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss)
    value = (value * 31) ^ hash(self.netbufferv4_forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss)
    value = (value * 31) ^ hash(self.netbufferv4_update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone)
    value = (value * 31) ^ hash(self.netbufferv4_update_putreq_inswitch_to_putres_by_mirroring)
    value = (value * 31) ^ hash(self.netbufferv4_update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres)
    value = (value * 31) ^ hash(self.netbufferv4_forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres)
    value = (value * 31) ^ hash(self.netbufferv4_update_putreq_seq_inswitch_case1_to_putres_by_mirroring)
    value = (value * 31) ^ hash(self.netbufferv4_update_delreq_inswitch_to_delres_by_mirroring)
    value = (value * 31) ^ hash(self.netbufferv4_update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres)
    value = (value * 31) ^ hash(self.netbufferv4_forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres)
    value = (value * 31) ^ hash(self.netbufferv4_update_delreq_seq_inswitch_case1_to_delres_by_mirroring)
    value = (value * 31) ^ hash(self.netbufferv4_forward_scanreq_split_and_clone)
    value = (value * 31) ^ hash(self.netbufferv4_update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone)
    value = (value * 31) ^ hash(self.netbufferv4_update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone)
    value = (value * 31) ^ hash(self.netbufferv4_update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone)
    value = (value * 31) ^ hash(self.netbufferv4_update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone)
    value = (value * 31) ^ hash(self.netbufferv4_forward_normal_response)
    value = (value * 31) ^ hash(self.netbufferv4_forward_special_get_response)
    value = (value * 31) ^ hash(self.netbufferv4_set_client_sid)
    value = (value * 31) ^ hash(self.netbufferv4_process_scanreq_split)
    value = (value * 31) ^ hash(self.netbufferv4_process_cloned_scanreq_split)
    value = (value * 31) ^ hash(self.netbufferv4_range_partition_for_scan_endkey)
    value = (value * 31) ^ hash(self.netbufferv4_range_partition)
    value = (value * 31) ^ hash(self.netbufferv4_recirculate_pkt)
    value = (value * 31) ^ hash(self.netbufferv4_set_hot_threshold)
    value = (value * 31) ^ hash(self.netbufferv4_update_ipmac_srcport_server2client)
    value = (value * 31) ^ hash(self.netbufferv4_update_ipmac_srcport_switch2switchos)
    value = (value * 31) ^ hash(self.netbufferv4_update_dstipmac_client2server)
    value = (value * 31) ^ hash(self.netbufferv4_update_pktlen)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_action_desc_t:
  """
  Attributes:
   - name
   - data
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRING, 'name', None, None, ), # 1
    (2, TType.STRUCT, 'data', (netbufferv4_action_specs_t, netbufferv4_action_specs_t.thrift_spec), None, ), # 2
  )

  def __init__(self, name=None, data=None,):
    self.name = name
    self.data = data

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRING:
          self.name = iprot.readString();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.STRUCT:
          self.data = netbufferv4_action_specs_t()
          self.data.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_action_desc_t')
    if self.name is not None:
      oprot.writeFieldBegin('name', TType.STRING, 1)
      oprot.writeString(self.name)
      oprot.writeFieldEnd()
    if self.data is not None:
      oprot.writeFieldBegin('data', TType.STRUCT, 2)
      self.data.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.name is None:
      raise TProtocol.TProtocolException(message='Required field name is unset!')
    if self.data is None:
      raise TProtocol.TProtocolException(message='Required field data is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.name)
    value = (value * 31) ^ hash(self.data)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_cache_frequency_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_access_cache_frequency_tbl_match_spec_t, netbufferv4_access_cache_frequency_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_access_cache_frequency_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_cache_frequency_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_case1_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_access_case1_tbl_match_spec_t, netbufferv4_access_case1_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_access_case1_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_case1_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_cm1_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_access_cm1_tbl_match_spec_t, netbufferv4_access_cm1_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_access_cm1_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_cm1_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_cm2_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_access_cm2_tbl_match_spec_t, netbufferv4_access_cm2_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_access_cm2_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_cm2_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_cm3_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_access_cm3_tbl_match_spec_t, netbufferv4_access_cm3_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_access_cm3_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_cm3_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_cm4_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_access_cm4_tbl_match_spec_t, netbufferv4_access_cm4_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_access_cm4_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_cm4_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_deleted_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_access_deleted_tbl_match_spec_t, netbufferv4_access_deleted_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_access_deleted_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_deleted_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_latest_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_access_latest_tbl_match_spec_t, netbufferv4_access_latest_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_access_latest_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_latest_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_savedseq_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_access_savedseq_tbl_match_spec_t, netbufferv4_access_savedseq_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_access_savedseq_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_savedseq_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_seq_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_access_seq_tbl_match_spec_t, netbufferv4_access_seq_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_access_seq_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_seq_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_access_validvalue_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_access_validvalue_tbl_match_spec_t, netbufferv4_access_validvalue_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_access_validvalue_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_access_validvalue_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_add_and_remove_value_header_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - priority
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_add_and_remove_value_header_tbl_match_spec_t, netbufferv4_add_and_remove_value_header_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.I32, 'priority', None, None, ), # 6
    (7, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 7
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, priority=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.priority = priority
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_add_and_remove_value_header_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_add_and_remove_value_header_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 6)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 7)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.priority is None:
      raise TProtocol.TProtocolException(message='Required field priority is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.priority)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_cache_lookup_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_cache_lookup_tbl_match_spec_t, netbufferv4_cache_lookup_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_cache_lookup_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_cache_lookup_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_drop_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_drop_tbl_match_spec_t, netbufferv4_drop_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_drop_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_drop_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_eg_port_forward_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_eg_port_forward_tbl_match_spec_t, netbufferv4_eg_port_forward_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_eg_port_forward_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_eg_port_forward_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_hash_for_cm1_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_hash_for_cm1_tbl_match_spec_t, netbufferv4_hash_for_cm1_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_hash_for_cm1_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_hash_for_cm1_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_hash_for_cm2_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_hash_for_cm2_tbl_match_spec_t, netbufferv4_hash_for_cm2_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_hash_for_cm2_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_hash_for_cm2_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_hash_for_cm3_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_hash_for_cm3_tbl_match_spec_t, netbufferv4_hash_for_cm3_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_hash_for_cm3_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_hash_for_cm3_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_hash_for_cm4_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_hash_for_cm4_tbl_match_spec_t, netbufferv4_hash_for_cm4_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_hash_for_cm4_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_hash_for_cm4_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_hash_for_seq_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_hash_for_seq_tbl_match_spec_t, netbufferv4_hash_for_seq_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_hash_for_seq_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_hash_for_seq_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_ig_port_forward_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_ig_port_forward_tbl_match_spec_t, netbufferv4_ig_port_forward_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_ig_port_forward_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_ig_port_forward_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_ipv4_forward_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_ipv4_forward_tbl_match_spec_t, netbufferv4_ipv4_forward_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_ipv4_forward_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_ipv4_forward_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_is_hot_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_is_hot_tbl_match_spec_t, netbufferv4_is_hot_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_is_hot_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_is_hot_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_lastclone_lastscansplit_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_lastclone_lastscansplit_tbl_match_spec_t, netbufferv4_lastclone_lastscansplit_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_lastclone_lastscansplit_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_lastclone_lastscansplit_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_need_recirculate_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_need_recirculate_tbl_match_spec_t, netbufferv4_need_recirculate_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_need_recirculate_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_need_recirculate_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_prepare_for_cachehit_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_prepare_for_cachehit_tbl_match_spec_t, netbufferv4_prepare_for_cachehit_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_prepare_for_cachehit_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_prepare_for_cachehit_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_process_scanreq_split_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_process_scanreq_split_tbl_match_spec_t, netbufferv4_process_scanreq_split_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_process_scanreq_split_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_process_scanreq_split_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_range_partition_for_scan_endkey_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - priority
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_range_partition_for_scan_endkey_tbl_match_spec_t, netbufferv4_range_partition_for_scan_endkey_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.I32, 'priority', None, None, ), # 6
    (7, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 7
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, priority=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.priority = priority
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_range_partition_for_scan_endkey_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_range_partition_for_scan_endkey_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 6)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 7)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.priority is None:
      raise TProtocol.TProtocolException(message='Required field priority is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.priority)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_range_partition_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - priority
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_range_partition_tbl_match_spec_t, netbufferv4_range_partition_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.I32, 'priority', None, None, ), # 6
    (7, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 7
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, priority=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.priority = priority
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_range_partition_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_range_partition_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 6)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 7)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.priority is None:
      raise TProtocol.TProtocolException(message='Required field priority is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.priority)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_recirculate_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_recirculate_tbl_match_spec_t, netbufferv4_recirculate_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_recirculate_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_recirculate_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_sample_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_sample_tbl_match_spec_t, netbufferv4_sample_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_sample_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_sample_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_save_client_udpport_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_save_client_udpport_tbl_match_spec_t, netbufferv4_save_client_udpport_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_save_client_udpport_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_save_client_udpport_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_set_hot_threshold_tbl_entry_desc_t:
  """
  Attributes:
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.BOOL, 'has_mbr_hdl', None, None, ), # 1
    (2, TType.BOOL, 'has_grp_hdl', None, None, ), # 2
    (3, TType.I32, 'selector_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'action_mbr_hdl', None, None, ), # 4
    (5, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 5
  )

  def __init__(self, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_set_hot_threshold_tbl_entry_desc_t')
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 1)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 3)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 4)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 5)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_snapshot_flag_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_snapshot_flag_tbl_match_spec_t, netbufferv4_snapshot_flag_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_snapshot_flag_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_snapshot_flag_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_ipmac_srcport_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_ipmac_srcport_tbl_match_spec_t, netbufferv4_update_ipmac_srcport_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_ipmac_srcport_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_ipmac_srcport_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_pktlen_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - priority
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_pktlen_tbl_match_spec_t, netbufferv4_update_pktlen_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.I32, 'priority', None, None, ), # 6
    (7, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 7
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, priority=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.priority = priority
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_pktlen_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.I32:
          self.priority = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 7:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_pktlen_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.priority is not None:
      oprot.writeFieldBegin('priority', TType.I32, 6)
      oprot.writeI32(self.priority)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 7)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.priority is None:
      raise TProtocol.TProtocolException(message='Required field priority is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.priority)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi10_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi10_tbl_match_spec_t, netbufferv4_update_valhi10_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi10_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi10_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi11_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi11_tbl_match_spec_t, netbufferv4_update_valhi11_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi11_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi11_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi12_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi12_tbl_match_spec_t, netbufferv4_update_valhi12_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi12_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi12_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi13_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi13_tbl_match_spec_t, netbufferv4_update_valhi13_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi13_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi13_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi14_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi14_tbl_match_spec_t, netbufferv4_update_valhi14_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi14_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi14_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi15_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi15_tbl_match_spec_t, netbufferv4_update_valhi15_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi15_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi15_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi16_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi16_tbl_match_spec_t, netbufferv4_update_valhi16_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi16_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi16_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi1_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi1_tbl_match_spec_t, netbufferv4_update_valhi1_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi1_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi1_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi2_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi2_tbl_match_spec_t, netbufferv4_update_valhi2_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi2_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi2_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi3_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi3_tbl_match_spec_t, netbufferv4_update_valhi3_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi3_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi3_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi4_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi4_tbl_match_spec_t, netbufferv4_update_valhi4_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi4_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi4_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi5_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi5_tbl_match_spec_t, netbufferv4_update_valhi5_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi5_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi5_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi6_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi6_tbl_match_spec_t, netbufferv4_update_valhi6_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi6_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi6_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi7_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi7_tbl_match_spec_t, netbufferv4_update_valhi7_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi7_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi7_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi8_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi8_tbl_match_spec_t, netbufferv4_update_valhi8_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi8_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi8_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_valhi9_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_valhi9_tbl_match_spec_t, netbufferv4_update_valhi9_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_valhi9_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_valhi9_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallen_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallen_tbl_match_spec_t, netbufferv4_update_vallen_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallen_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallen_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo10_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo10_tbl_match_spec_t, netbufferv4_update_vallo10_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo10_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo10_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo11_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo11_tbl_match_spec_t, netbufferv4_update_vallo11_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo11_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo11_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo12_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo12_tbl_match_spec_t, netbufferv4_update_vallo12_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo12_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo12_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo13_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo13_tbl_match_spec_t, netbufferv4_update_vallo13_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo13_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo13_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo14_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo14_tbl_match_spec_t, netbufferv4_update_vallo14_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo14_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo14_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo15_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo15_tbl_match_spec_t, netbufferv4_update_vallo15_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo15_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo15_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo16_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo16_tbl_match_spec_t, netbufferv4_update_vallo16_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo16_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo16_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo1_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo1_tbl_match_spec_t, netbufferv4_update_vallo1_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo1_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo1_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo2_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo2_tbl_match_spec_t, netbufferv4_update_vallo2_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo2_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo2_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo3_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo3_tbl_match_spec_t, netbufferv4_update_vallo3_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo3_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo3_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo4_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo4_tbl_match_spec_t, netbufferv4_update_vallo4_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo4_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo4_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo5_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo5_tbl_match_spec_t, netbufferv4_update_vallo5_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo5_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo5_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo6_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo6_tbl_match_spec_t, netbufferv4_update_vallo6_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo6_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo6_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo7_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo7_tbl_match_spec_t, netbufferv4_update_vallo7_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo7_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo7_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo8_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo8_tbl_match_spec_t, netbufferv4_update_vallo8_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo8_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo8_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class netbufferv4_update_vallo9_tbl_entry_desc_t:
  """
  Attributes:
   - match_spec
   - has_mbr_hdl
   - has_grp_hdl
   - selector_grp_hdl
   - action_mbr_hdl
   - action_desc
  """

  thrift_spec = (
    None, # 0
    (1, TType.STRUCT, 'match_spec', (netbufferv4_update_vallo9_tbl_match_spec_t, netbufferv4_update_vallo9_tbl_match_spec_t.thrift_spec), None, ), # 1
    (2, TType.BOOL, 'has_mbr_hdl', None, None, ), # 2
    (3, TType.BOOL, 'has_grp_hdl', None, None, ), # 3
    (4, TType.I32, 'selector_grp_hdl', None, None, ), # 4
    (5, TType.I32, 'action_mbr_hdl', None, None, ), # 5
    (6, TType.STRUCT, 'action_desc', (netbufferv4_action_desc_t, netbufferv4_action_desc_t.thrift_spec), None, ), # 6
  )

  def __init__(self, match_spec=None, has_mbr_hdl=None, has_grp_hdl=None, selector_grp_hdl=None, action_mbr_hdl=None, action_desc=None,):
    self.match_spec = match_spec
    self.has_mbr_hdl = has_mbr_hdl
    self.has_grp_hdl = has_grp_hdl
    self.selector_grp_hdl = selector_grp_hdl
    self.action_mbr_hdl = action_mbr_hdl
    self.action_desc = action_desc

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.STRUCT:
          self.match_spec = netbufferv4_update_vallo9_tbl_match_spec_t()
          self.match_spec.read(iprot)
        else:
          iprot.skip(ftype)
      elif fid == 2:
        if ftype == TType.BOOL:
          self.has_mbr_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 3:
        if ftype == TType.BOOL:
          self.has_grp_hdl = iprot.readBool();
        else:
          iprot.skip(ftype)
      elif fid == 4:
        if ftype == TType.I32:
          self.selector_grp_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 5:
        if ftype == TType.I32:
          self.action_mbr_hdl = iprot.readI32();
        else:
          iprot.skip(ftype)
      elif fid == 6:
        if ftype == TType.STRUCT:
          self.action_desc = netbufferv4_action_desc_t()
          self.action_desc.read(iprot)
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('netbufferv4_update_vallo9_tbl_entry_desc_t')
    if self.match_spec is not None:
      oprot.writeFieldBegin('match_spec', TType.STRUCT, 1)
      self.match_spec.write(oprot)
      oprot.writeFieldEnd()
    if self.has_mbr_hdl is not None:
      oprot.writeFieldBegin('has_mbr_hdl', TType.BOOL, 2)
      oprot.writeBool(self.has_mbr_hdl)
      oprot.writeFieldEnd()
    if self.has_grp_hdl is not None:
      oprot.writeFieldBegin('has_grp_hdl', TType.BOOL, 3)
      oprot.writeBool(self.has_grp_hdl)
      oprot.writeFieldEnd()
    if self.selector_grp_hdl is not None:
      oprot.writeFieldBegin('selector_grp_hdl', TType.I32, 4)
      oprot.writeI32(self.selector_grp_hdl)
      oprot.writeFieldEnd()
    if self.action_mbr_hdl is not None:
      oprot.writeFieldBegin('action_mbr_hdl', TType.I32, 5)
      oprot.writeI32(self.action_mbr_hdl)
      oprot.writeFieldEnd()
    if self.action_desc is not None:
      oprot.writeFieldBegin('action_desc', TType.STRUCT, 6)
      self.action_desc.write(oprot)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    if self.match_spec is None:
      raise TProtocol.TProtocolException(message='Required field match_spec is unset!')
    if self.has_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_mbr_hdl is unset!')
    if self.has_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field has_grp_hdl is unset!')
    if self.selector_grp_hdl is None:
      raise TProtocol.TProtocolException(message='Required field selector_grp_hdl is unset!')
    if self.action_mbr_hdl is None:
      raise TProtocol.TProtocolException(message='Required field action_mbr_hdl is unset!')
    if self.action_desc is None:
      raise TProtocol.TProtocolException(message='Required field action_desc is unset!')
    return


  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.match_spec)
    value = (value * 31) ^ hash(self.has_mbr_hdl)
    value = (value * 31) ^ hash(self.has_grp_hdl)
    value = (value * 31) ^ hash(self.selector_grp_hdl)
    value = (value * 31) ^ hash(self.action_mbr_hdl)
    value = (value * 31) ^ hash(self.action_desc)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidTableOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidTableOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidLearnOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidLearnOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidDbgOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidDbgOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidSnapshotOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidSnapshotOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidCounterOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidCounterOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidRegisterOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidRegisterOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidMeterOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidMeterOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidLPFOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidLPFOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)

class InvalidWREDOperation(TException):
  """
  Attributes:
   - code
  """

  thrift_spec = (
    None, # 0
    (1, TType.I32, 'code', None, None, ), # 1
  )

  def __init__(self, code=None,):
    self.code = code

  def read(self, iprot):
    if iprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and isinstance(iprot.trans, TTransport.CReadableTransport) and self.thrift_spec is not None and fastbinary is not None:
      fastbinary.decode_binary(self, iprot.trans, (self.__class__, self.thrift_spec))
      return
    iprot.readStructBegin()
    while True:
      (fname, ftype, fid) = iprot.readFieldBegin()
      if ftype == TType.STOP:
        break
      if fid == 1:
        if ftype == TType.I32:
          self.code = iprot.readI32();
        else:
          iprot.skip(ftype)
      else:
        iprot.skip(ftype)
      iprot.readFieldEnd()
    iprot.readStructEnd()

  def write(self, oprot):
    if oprot.__class__ == TBinaryProtocol.TBinaryProtocolAccelerated and self.thrift_spec is not None and fastbinary is not None:
      oprot.trans.write(fastbinary.encode_binary(self, (self.__class__, self.thrift_spec)))
      return
    oprot.writeStructBegin('InvalidWREDOperation')
    if self.code is not None:
      oprot.writeFieldBegin('code', TType.I32, 1)
      oprot.writeI32(self.code)
      oprot.writeFieldEnd()
    oprot.writeFieldStop()
    oprot.writeStructEnd()

  def validate(self):
    return


  def __str__(self):
    return repr(self)

  def __hash__(self):
    value = 17
    value = (value * 31) ^ hash(self.code)
    return value

  def __repr__(self):
    L = ['%s=%r' % (key, value)
      for key, value in self.__dict__.iteritems()]
    return '%s(%s)' % (self.__class__.__name__, ', '.join(L))

  def __eq__(self, other):
    return isinstance(other, self.__class__) and self.__dict__ == other.__dict__

  def __ne__(self, other):
    return not (self == other)
