package site.ycsb.db;

import java.io.RandomAccessFile;
import java.nio.ByteBuffer;
import java.nio.channels.FileChannel;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import com.inswitchcache.InswitchCacheClient;
import com.inswitchcache.core.GlobalConfig;
import com.inswitchcache.core.IOHelper;
import com.inswitchcache.core.InmemoryReq;
import com.inswitchcache.core.Value;
import com.inswitchcache.core.Key;
import com.inswitchcache.core.packets.PacketType;

import site.ycsb.ByteIterator;
import site.ycsb.DBException;
import site.ycsb.RemoteDB;
import site.ycsb.Status;
import site.ycsb.StringByteIterator;

/**
 * KeydumpClient inherits RemoteDB.
 * Simply dump all client requests to local based on key frequency.
 * 
 * 
 * Given the workload, perform the following tasks:
 * (1) dump 10000 hot keys for static workload
 * (2) Calculate the bottleneck server logical index for static workload under
 * 16/32/64/128 servers
 * (3) NOTE: dynamic rules are generated by generate_dynamicrules.py
 * 
 */
public class KeydumpClient extends RemoteDB {

  private String pregenerateFilepath = "";
  // private FileOutputStream fos = null;
  private RandomAccessFile pregenerateFile = null;
  private FileChannel fos = null;
  private byte[] reqbuf = new byte[GlobalConfig.MAX_BUFFER_SIZE];

  @Override
  public void init() throws DBException {
    super.init();
    System.out.println("[INFO][KeydumpClient] Client logical index: " + localLogicalClientIndex); // TMPDBG

    pregenerateFilepath = IOHelper.getPregenerateWorkloadFilepath(
        GlobalConfig.getWorkloadName(), localLogicalClientIndex);
    try {
      // fos = new FileOutputStream(pregenerateFilepath);
      pregenerateFile = new RandomAccessFile(pregenerateFilepath, "rw");
      fos = pregenerateFile.getChannel();
    } catch (Exception e) {
      System.out.println(e.getMessage());
      e.printStackTrace();
      System.exit(-1);
    }
  }

  @Override
  public void cleanup() throws DBException {
    System.out.println("[INFO][KeydumpClient] Logical client " + localLogicalClientIndex + " cleanup"); // TMPDBG

    try {
      fos.close();
      pregenerateFile.close();
      System.out
          .println(String.format("Pre-generate static workload for server rotation into %s", pregenerateFilepath));
    } catch (Exception e) {
      System.out.println(e.getMessage());
      e.printStackTrace();
      System.exit(-1);
    }
  }

  @Override
  public Status read(final String table, final String key, final Set<String> fields,
      Map<String, ByteIterator> result) {
    InswitchCacheClient.getKeyFrequencyRecords(localLogicalClientIndex)
        .put(key, InswitchCacheClient.getKeyFrequencyRecords(localLogicalClientIndex).getOrDefault(key, 0) + 1);

    Key tmpkey = new Key();
    tmpkey.fromString(key);
    int serveridx16 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 16);
    InswitchCacheClient.increPerserverLoad16(serveridx16);
    int serveridx32 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 32);
    InswitchCacheClient.increPerserverLoad32(serveridx32);
    int serveridx64 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 64);
    InswitchCacheClient.increPerserverLoad64(serveridx64);
    int serveridx128 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 128);
    InswitchCacheClient.increPerserverLoad128(serveridx128);

    InmemoryReq tmpreq = new InmemoryReq(PacketType.GETREQ.getType(), tmpkey);
    int tmpreqsize = tmpreq.serialize(reqbuf, GlobalConfig.MAX_BUFFER_SIZE);
    // InswitchCacheClient.getInmemoryReqList(localLogicalClientIndex).add(tmpreq);
    try {
      fos.write(ByteBuffer.wrap(reqbuf, 0, tmpreqsize));
    } catch (Exception e) {
      System.out.println(e.getMessage());
      e.printStackTrace();
      System.exit(-1);
    }

    return Status.OK;
  }

  @Override
  public Status scan(final String table, final String startkey, final int recordcount, final Set<String> fields,
      final Vector<HashMap<String, ByteIterator>> result) {
    // NOTE: NOT count scan for hot keys, as scan will never be processed by switch

    Key startKeyStruct = new Key();
    startKeyStruct.fromString(startkey);
    int serveridx16 = startKeyStruct.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 16);
    InswitchCacheClient.increPerserverLoad16(serveridx16);
    int serveridx32 = startKeyStruct.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 32);
    InswitchCacheClient.increPerserverLoad32(serveridx32);
    int serveridx64 = startKeyStruct.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 64);
    InswitchCacheClient.increPerserverLoad64(serveridx64);
    int serveridx128 = startKeyStruct.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 128);
    InswitchCacheClient.increPerserverLoad128(serveridx128);

    // Key endKeyStruct = startkeyStruct.getEndkey(recordcount);
    // InmemoryReq tmpreq = new InmemoryReq(PacketType.SCANREQ.getType(),
    // startKeyStruct, endKeyStruct);
    InmemoryReq tmpreq = new InmemoryReq(PacketType.SCANREQ.getType(), startKeyStruct, recordcount);
    int tmpreqsize = tmpreq.serialize(reqbuf, GlobalConfig.MAX_BUFFER_SIZE);
    // InswitchCacheClient.getInmemoryReqList(localLogicalClientIndex).add(tmpreq);
    try {
      fos.write(ByteBuffer.wrap(reqbuf, 0, tmpreqsize));
    } catch (Exception e) {
      System.out.println(e.getMessage());
      e.printStackTrace();
      System.exit(-1);
    }

    return Status.OK;
  }

  @Override
  public Status update(final String table, final String key, final Map<String, ByteIterator> values) {
    InswitchCacheClient.getKeyFrequencyRecords(localLogicalClientIndex)
        .put(key, InswitchCacheClient.getKeyFrequencyRecords(localLogicalClientIndex).getOrDefault(key, 0) + 1);

    Key tmpkey = new Key();
    tmpkey.fromString(key);
    int serveridx16 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 16);
    InswitchCacheClient.increPerserverLoad16(serveridx16);
    int serveridx32 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 32);
    InswitchCacheClient.increPerserverLoad32(serveridx32);
    int serveridx64 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 64);
    InswitchCacheClient.increPerserverLoad64(serveridx64);
    int serveridx128 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 128);
    InswitchCacheClient.increPerserverLoad128(serveridx128);

    Map<String, String> valueMap = StringByteIterator.getStringMap(values);
    Map.Entry<String, String> entry = valueMap.entrySet().iterator().next();
    Value tmpValue = new Value();
    tmpValue.fromString(entry.getValue());
    InmemoryReq tmpreq = new InmemoryReq(PacketType.PUTREQ.getType(), tmpkey, tmpValue);
    int tmpreqsize = tmpreq.serialize(reqbuf, GlobalConfig.MAX_BUFFER_SIZE);
    // InswitchCacheClient.getInmemoryReqList(localLogicalClientIndex).add(tmpreq);
    try {
      fos.write(ByteBuffer.wrap(reqbuf, 0, tmpreqsize));
    } catch (Exception e) {
      System.out.println(e.getMessage());
      e.printStackTrace();
      System.exit(-1);
    }

    return Status.OK;
  }

  @Override
  public Status insert(final String table, final String key, final Map<String, ByteIterator> values) {
    InswitchCacheClient.getKeyFrequencyRecords(localLogicalClientIndex)
        .put(key, InswitchCacheClient.getKeyFrequencyRecords(localLogicalClientIndex).getOrDefault(key, 0) + 1);

    Key tmpkey = new Key();
    tmpkey.fromString(key);
    int serveridx16 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 16);
    InswitchCacheClient.increPerserverLoad16(serveridx16);
    int serveridx32 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 32);
    InswitchCacheClient.increPerserverLoad32(serveridx32);
    int serveridx64 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 64);
    InswitchCacheClient.increPerserverLoad64(serveridx64);
    int serveridx128 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 128);
    InswitchCacheClient.increPerserverLoad128(serveridx128);

    Map<String, String> valueMap = StringByteIterator.getStringMap(values);
    Map.Entry<String, String> entry = valueMap.entrySet().iterator().next();
    Value tmpValue = new Value();
    tmpValue.fromString(entry.getValue());
    InmemoryReq tmpreq = new InmemoryReq(PacketType.PUTREQ.getType(), tmpkey, tmpValue);
    int tmpreqsize = tmpreq.serialize(reqbuf, GlobalConfig.MAX_BUFFER_SIZE);
    // InswitchCacheClient.getInmemoryReqList(localLogicalClientIndex).add(tmpreq);
    try {
      fos.write(ByteBuffer.wrap(reqbuf, 0, tmpreqsize));
    } catch (Exception e) {
      System.out.println(e.getMessage());
      e.printStackTrace();
      System.exit(-1);
    }

    return Status.OK;
  }

  @Override
  public Status delete(final String table, final String key) {
    InswitchCacheClient.getKeyFrequencyRecords(localLogicalClientIndex)
        .put(key, InswitchCacheClient.getKeyFrequencyRecords(localLogicalClientIndex).getOrDefault(key, 0) + 1);

    Key tmpkey = new Key();
    tmpkey.fromString(key);
    int serveridx16 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 16);
    InswitchCacheClient.increPerserverLoad16(serveridx16);
    int serveridx32 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 32);
    InswitchCacheClient.increPerserverLoad32(serveridx32);
    int serveridx64 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 64);
    InswitchCacheClient.increPerserverLoad64(serveridx64);
    int serveridx128 = tmpkey.getHashPartitionIdx(GlobalConfig.getSwitchPartitionCount(), 128);
    InswitchCacheClient.increPerserverLoad128(serveridx128);

    InmemoryReq tmpreq = new InmemoryReq(PacketType.DELREQ.getType(), tmpkey);
    int tmpreqsize = tmpreq.serialize(reqbuf, GlobalConfig.MAX_BUFFER_SIZE);
    // InswitchCacheClient.getInmemoryReqList(localLogicalClientIndex).add(tmpreq);
    try {
      fos.write(ByteBuffer.wrap(reqbuf, 0, tmpreqsize));
    } catch (Exception e) {
      System.out.println(e.getMessage());
      e.printStackTrace();
      System.exit(-1);
    }

    return Status.OK;
  }
}
