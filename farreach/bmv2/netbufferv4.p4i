# 1 "/root/P4/farreach-private/farreach/bmv2/netbufferv4.p4"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/root/P4/farreach-private/farreach/bmv2/netbufferv4.p4"
# 1 "/usr/local/share/p4c/p4include/core.p4" 1
/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* This is the P4-16 core library, which declares some built-in P4 constructs using P4 */




/// Standard error codes.  New error codes can be declared by users.
error {
    NoError, /// No error.
    PacketTooShort, /// Not enough bits in packet for 'extract'.
    NoMatch, /// 'select' expression has no matches.
    StackOutOfBounds, /// Reference to invalid element of a header stack.
    HeaderTooShort, /// Extracting too many bits into a varbit field.
    ParserTimeout, /// Parser execution time limit exceeded.
    ParserInvalidArgument /// Parser operation was called with a value
                           /// not supported by the implementation.
}

extern packet_in {
    /// Read a header from the packet into a fixed-sized header @hdr and advance the cursor.
    /// May trigger error PacketTooShort or StackOutOfBounds.
    /// @T must be a fixed-size header type
    void extract<T>(out T hdr);
    /// Read bits from the packet into a variable-sized header @variableSizeHeader
    /// and advance the cursor.
    /// @T must be a header containing exactly 1 varbit field.
    /// May trigger errors PacketTooShort, StackOutOfBounds, or HeaderTooShort.
    void extract<T>(out T variableSizeHeader,
                    in bit<32> variableFieldSizeInBits);
    /// Read bits from the packet without advancing the cursor.
    /// @returns: the bits read from the packet.
    /// T may be an arbitrary fixed-size type.
    T lookahead<T>();
    /// Advance the packet cursor by the specified number of bits.
    void advance(in bit<32> sizeInBits);
    /// @return packet length in bytes.  This method may be unavailable on
    /// some target architectures.
    bit<32> length();
}

extern packet_out {
    /// Write @hdr into the output packet, advancing cursor.
    /// @T can be a header type, a header stack, a header_union, or a struct
    /// containing fields with such types.
    void emit<T>(in T hdr);
}

// TODO: remove from this file, convert to built-in
/// Check a predicate @check in the parser; if the predicate is true do nothing,
/// otherwise set the parser error to @toSignal, and transition to the `reject` state.
extern void verify(in bool check, in error toSignal);

/// Built-in action that does nothing.
@noWarn("unused")
action NoAction() {}

/// Standard match kinds for table key fields.
/// Some architectures may not support all these match kinds.
/// Architectures can declare additional match kinds.
match_kind {
    /// Match bits exactly.
    exact,
    /// Ternary match, using a mask.
    ternary,
    /// Longest-prefix match.
    lpm
}
# 2 "/root/P4/farreach-private/farreach/bmv2/netbufferv4.p4" 2
# 1 "/usr/local/share/p4c/p4include/v1model.p4" 1
/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* P4-16 declaration of the P4 v1.0 switch model */

/* Note 1: More details about the definition of v1model architecture
 * can be found at the location below.
 *
 * https://github.com/p4lang/behavioral-model/blob/main/docs/simple_switch.md
 *
 * Note 3: There are at least some P4_14 implementations where
 * invoking a generate_digest operation on a field_list will create a
 * message to the control plane that contains the values of those
 * fields when the ingress control is finished executing, which can be
 * different than the values those fields have at the time the
 * generate_digest operation is invoked in the program, if those field
 * values are changed later in the execution of the P4_14 ingress
 * control.
 *
 * The P4_16 plus v1model implementation should always create digest
 * messages that contain the values of the specified fields at the
 * time that the digest extern function is called.  Thus if a P4_14
 * program expecting the behavior described above is compiled using
 * p4c, it may behave differently.
 */




# 1 "/usr/local/share/p4c/p4include/core.p4" 1
/*
Copyright 2013-present Barefoot Networks, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

/* This is the P4-16 core library, which declares some built-in P4 constructs using P4 */
# 44 "/usr/local/share/p4c/p4include/v1model.p4" 2





match_kind {
    range,
    // Either an exact match, or a wildcard (matching any value).
    optional,
    // Used for implementing dynamic_action_selection
    selector
}

const bit<32> __v1model_version = 20180101;





@metadata @name("standard_metadata")
struct standard_metadata_t {





    bit<9> ingress_port;
    bit<9> egress_spec;
    bit<9> egress_port;

    bit<32> instance_type;
    bit<32> packet_length;
    //
    // @alias is used to generate the field_alias section of the BMV2 JSON.
    // Field alias creates a mapping from the metadata name in P4 program to
    // the behavioral model's internal metadata name. Here we use it to
    // expose all metadata supported by simple switch to the user through
    // standard_metadata_t.
    //
    // flattening fields that exist in bmv2-ss
    // queueing metadata
    @alias("queueing_metadata.enq_timestamp")
    bit<32> enq_timestamp;
    @alias("queueing_metadata.enq_qdepth")
    bit<19> enq_qdepth;
    @alias("queueing_metadata.deq_timedelta")
    bit<32> deq_timedelta;
    /// queue depth at the packet dequeue time.
    @alias("queueing_metadata.deq_qdepth")
    bit<19> deq_qdepth;

    // intrinsic metadata
    @alias("intrinsic_metadata.ingress_global_timestamp")
    bit<48> ingress_global_timestamp;
    @alias("intrinsic_metadata.egress_global_timestamp")
    bit<48> egress_global_timestamp;
    /// multicast group id (key for the mcast replication table)
    @alias("intrinsic_metadata.mcast_grp")
    bit<16> mcast_grp;
    /// Replication ID for multicast
    @alias("intrinsic_metadata.egress_rid")
    bit<16> egress_rid;
    /// Indicates that a verify_checksum() method has failed.
    /// 1 if a checksum error was found, otherwise 0.
    bit<1> checksum_error;
    /// Error produced by parsing
    error parser_error;
    /// set packet priority
    @alias("intrinsic_metadata.priority")
    bit<3> priority;
}

enum CounterType {
    packets,
    bytes,
    packets_and_bytes
}

enum MeterType {
    packets,
    bytes
}

extern counter



{
    /***
     * A counter object is created by calling its constructor.  This
     * creates an array of counter states, with the number of counter
     * states specified by the size parameter.  The array indices are
     * in the range [0, size-1].
     *
     * You must provide a choice of whether to maintain only a packet
     * count (CounterType.packets), only a byte count
     * (CounterType.bytes), or both (CounterType.packets_and_bytes).
     *
     * Counters can be updated from your P4 program, but can only be
     * read from the control plane.  If you need something that can be
     * both read and written from the P4 program, consider using a
     * register.
     */
    counter(bit<32> size, CounterType type);
    // FIXME -- size arg should be `int` but that breaks typechecking

    /***
     * count() causes the counter state with the specified index to be
     * read, modified, and written back, atomically relative to the
     * processing of other packets, updating the packet count, byte
     * count, or both, depending upon the CounterType of the counter
     * instance used when it was constructed.
     *
     * @param index The index of the counter state in the array to be
     *              updated, normally a value in the range [0,
     *              size-1].  If index >= size, no counter state will be
     *              updated.
     */



    void count(in bit<32> index);

}

extern direct_counter {
    /***
     * A direct_counter object is created by calling its constructor.
     * You must provide a choice of whether to maintain only a packet
     * count (CounterType.packets), only a byte count
     * (CounterType.bytes), or both (CounterType.packets_and_bytes).
     * After constructing the object, you can associate it with at
     * most one table, by adding the following table property to the
     * definition of that table:
     *
     *     counters = <object_name>;
     *
     * Counters can be updated from your P4 program, but can only be
     * read from the control plane.  If you need something that can be
     * both read and written from the P4 program, consider using a
     * register.
     */
    direct_counter(CounterType type);
    /***
     * The count() method is actually unnecessary in the v1model
     * architecture.  This is because after a direct_counter object
     * has been associated with a table as described in the
     * documentation for the direct_counter constructor, every time
     * the table is applied and a table entry is matched, the counter
     * state associated with the matching entry is read, modified, and
     * written back, atomically relative to the processing of other
     * packets, regardless of whether the count() method is called in
     * the body of that action.
     */
    void count();
}





extern meter



{
    /***
     * A meter object is created by calling its constructor.  This
     * creates an array of meter states, with the number of meter
     * states specified by the size parameter.  The array indices are
     * in the range [0, size-1].  For example, if in your system you
     * have 128 different "flows" numbered from 0 up to 127, and you
     * want to meter each of those flows independently of each other,
     * you could do so by creating a meter object with size=128.
     *
     * You must provide a choice of whether to meter based on the
     * number of packets, regardless of their size
     * (MeterType.packets), or based upon the number of bytes the
     * packets contain (MeterType.bytes).
     */
    meter(bit<32> size, MeterType type);
    // FIXME -- size arg should be `int` but that breaks typechecking

    /***
     * execute_meter() causes the meter state with the specified index
     * to be read, modified, and written back, atomically relative to
     * the processing of other packets, and an integer encoding of one
     * of the colors green, yellow, or red to be written to the result
     * out parameter.
     *
     * @param index The index of the meter state in the array to be
     *              updated, normally a value in the range [0,
     *              size-1].  If index >= size, no meter state will be
     *              updated.
     * @param result Type T must be bit<W> with W >= 2.  When index is
     *              in range, the value of result will be assigned 0
     *              for color GREEN, 1 for color YELLOW, and 2 for
     *              color RED (see RFC 2697 and RFC 2698 for the
     *              meaning of these colors).  When index is out of
     *              range, the final value of result is not specified,
     *              and should be ignored by the caller.
     */



    void execute_meter<T>(in bit<32> index, out T result);

}

extern direct_meter<T> {
    /***
     * A direct_meter object is created by calling its constructor.
     * You must provide a choice of whether to meter based on the
     * number of packets, regardless of their size
     * (MeterType.packets), or based upon the number of bytes the
     * packets contain (MeterType.bytes).  After constructing the
     * object, you can associate it with at most one table, by adding
     * the following table property to the definition of that table:
     *
     *     meters = <object_name>;
     */
    direct_meter(MeterType type);
    /***
     * After a direct_meter object has been associated with a table as
     * described in the documentation for the direct_meter
     * constructor, every time the table is applied and a table entry
     * is matched, the meter state associated with the matching entry
     * is read, modified, and written back, atomically relative to the
     * processing of other packets, regardless of whether the read()
     * method is called in the body of that action.
     *
     * read() may only be called within an action executed as a result
     * of matching a table entry, of a table that has a direct_meter
     * associated with it.  Calling read() causes an integer encoding
     * of one of the colors green, yellow, or red to be written to the
     * result out parameter.
     *
     * @param result Type T must be bit<W> with W >= 2.  The value of
     *              result will be assigned 0 for color GREEN, 1 for
     *              color YELLOW, and 2 for color RED (see RFC 2697
     *              and RFC 2698 for the meaning of these colors).
     */
    void read(out T result);
}




extern register<T>

{
    /***
     * A register object is created by calling its constructor.  This
     * creates an array of 'size' identical elements, each with type
     * T.  The array indices are in the range [0, size-1].  For
     * example, this constructor call:
     *
     *     register<bit<32>>(512) my_reg;
     *
     * allocates storage for 512 values, each with type bit<32>.
     */
    register(bit<32> size); // FIXME -- arg should be `int` but that breaks typechecking
    /***
     * read() reads the state of the register array stored at the
     * specified index, and returns it as the value written to the
     * result parameter.
     *
     * @param index The index of the register array element to be
     *              read, normally a value in the range [0, size-1].
     * @param result Only types T that are bit<W> are currently
     *              supported.  When index is in range, the value of
     *              result becomes the value read from the register
     *              array element.  When index >= size, the final
     *              value of result is not specified, and should be
     *              ignored by the caller.
     */
    @noSideEffects



    void read(out T result, in bit<32> index);

    /***
     * write() writes the state of the register array at the specified
     * index, with the value provided by the value parameter.
     *
     * If you wish to perform a read() followed later by a write() to
     * the same register array element, and you wish the
     * read-modify-write sequence to be atomic relative to other
     * processed packets, then there may be parallel implementations
     * of the v1model architecture for which you must execute them in
     * a P4_16 block annotated with an @atomic annotation.  See the
     * P4_16 language specification description of the @atomic
     * annotation for more details.
     *
     * @param index The index of the register array element to be
     *              written, normally a value in the range [0,
     *              size-1].  If index >= size, no register state will
     *              be updated.
     * @param value Only types T that are bit<W> are currently
     *              supported.  When index is in range, this
     *              parameter's value is written into the register
     *              array element specified by index.
     */



    void write(in bit<32> index, in T value);

}

// used as table implementation attribute
extern action_profile {
    action_profile(bit<32> size);
}

/***
 * Generate a random number in the range lo..hi, inclusive, and write
 * it to the result parameter.  The value written to result is not
 * specified if lo > hi.
 *
 * @param T          Must be a type bit<W>
 */
extern void random<T>(out T result, in T lo, in T hi);

/***
 * Calling digest causes a message containing the values specified in
 * the data parameter to be sent to the control plane software.  It is
 * similar to sending a clone of the packet to the control plane
 * software, except that it can be more efficient because the messages
 * are typically smaller than packets, and many such small digest
 * messages are typically coalesced together into a larger "batch"
 * which the control plane software processes all at once.
 *
 * The value of the fields that are sent in the message to the control
 * plane is the value they have at the time the digest call occurs,
 * even if those field values are changed by later ingress control
 * code.  See Note 3.
 *
 * Calling digest is only supported in the ingress control.  There is
 * no way to undo its effects once it has been called.
 *
 * If the type T is a named struct, the name is used to generate the
 * control plane API.
 *
 * The BMv2 implementation of the v1model architecture ignores the
 * value of the receiver parameter.
 */
extern void digest<T>(in bit<32> receiver, in T data);

enum HashAlgorithm {
    crc32,
    crc32_custom,
    crc16,
    crc16_custom,
    random,
    identity,
    csum16,
    xor16
}

@deprecated("Please use mark_to_drop(standard_metadata) instead.")
extern void mark_to_drop();

/***
 * mark_to_drop(standard_metadata) is a primitive action that modifies
 * standard_metadata.egress_spec to an implementation-specific special
 * value that in some cases causes the packet to be dropped at the end
 * of ingress or egress processing.  It also assigns 0 to
 * standard_metadata.mcast_grp.  Either of those metadata fields may
 * be changed by executing later P4 code, after calling
 * mark_to_drop(), and this can change the resulting behavior of the
 * packet to do something other than drop.
 *
 * See
 * https://github.com/p4lang/behavioral-model/blob/main/docs/simple_switch.md
 * -- in particular the section "Pseudocode for what happens at the
 * end of ingress and egress processing" -- for the relative priority
 * of the different possible things that can happen to a packet when
 * ingress and egress processing are complete.
 */
@pure
extern void mark_to_drop(inout standard_metadata_t standard_metadata);

/***
 * Calculate a hash function of the value specified by the data
 * parameter.  The value written to the out parameter named result
 * will always be in the range [base, base+max-1] inclusive, if max >=
 * 1.  If max=0, the value written to result will always be base.
 *
 * Note that the types of all of the parameters may be the same as, or
 * different from, each other, and thus their bit widths are allowed
 * to be different.
 *
 * @param O          Must be a type bit<W>
 * @param D          Must be a tuple type where all the fields are bit-fields (type bit<W> or int<W>) or varbits.
 * @param T          Must be a type bit<W>
 * @param M          Must be a type bit<W>
 */
@pure
extern void hash<O, T, D, M>(out O result, in HashAlgorithm algo, in T base, in D data, in M max);

extern action_selector {
    action_selector(HashAlgorithm algorithm, bit<32> size, bit<32> outputWidth);
}

enum CloneType {
    I2E,
    E2E
}

@deprecated("Please use verify_checksum/update_checksum instead.")
extern Checksum16 {
    Checksum16();
    bit<16> get<D>(in D data);
}

/***
 * Verifies the checksum of the supplied data.  If this method detects
 * that a checksum of the data is not correct, then the value of the
 * standard_metadata checksum_error field will be equal to 1 when the
 * packet begins ingress processing.
 *
 * Calling verify_checksum is only supported in the VerifyChecksum
 * control.
 *
 * @param T          Must be a tuple type where all the tuple elements
 *                   are of type bit<W>, int<W>, or varbit<W>.  The
 *                   total length of the fields must be a multiple of
 *                   the output size.
 * @param O          Checksum type; must be bit<X> type.
 * @param condition  If 'false' the verification always succeeds.
 * @param data       Data whose checksum is verified.
 * @param checksum   Expected checksum of the data; note that it must
 *                   be a left-value.
 * @param algo       Algorithm to use for checksum (not all algorithms
 *                   may be supported).  Must be a compile-time
 *                   constant.
 */
extern void verify_checksum<T, O>(in bool condition, in T data, in O checksum, HashAlgorithm algo);

/***
 * Computes the checksum of the supplied data and writes it to the
 * checksum parameter.
 *
 * Calling update_checksum is only supported in the ComputeChecksum
 * control.
 *
 * @param T          Must be a tuple type where all the tuple elements
 *                   are of type bit<W>, int<W>, or varbit<W>.  The
 *                   total length of the fields must be a multiple of
 *                   the output size.
 * @param O          Output type; must be bit<X> type.
 * @param condition  If 'false' the checksum parameter is not changed
 * @param data       Data whose checksum is computed.
 * @param checksum   Checksum of the data.
 * @param algo       Algorithm to use for checksum (not all algorithms
 *                   may be supported).  Must be a compile-time
 *                   constant.
 */
@pure
extern void update_checksum<T, O>(in bool condition, in T data, inout O checksum, HashAlgorithm algo);

/***
 * verify_checksum_with_payload is identical in all ways to
 * verify_checksum, except that it includes the payload of the packet
 * in the checksum calculation.  The payload is defined as "all bytes
 * of the packet which were not parsed by the parser".
 *
 * Calling verify_checksum_with_payload is only supported in the
 * VerifyChecksum control.
 */
extern void verify_checksum_with_payload<T, O>(in bool condition, in T data, in O checksum, HashAlgorithm algo);

/**
 * update_checksum_with_payload is identical in all ways to
 * update_checksum, except that it includes the payload of the packet
 * in the checksum calculation.  The payload is defined as "all bytes
 * of the packet which were not parsed by the parser".
 *
 * Calling update_checksum_with_payload is only supported in the
 * ComputeChecksum control.
 */
@noSideEffects
extern void update_checksum_with_payload<T, O>(in bool condition, in T data, inout O checksum, HashAlgorithm algo);

/***
 * clone is in most ways identical to the clone_preserving_field_list
 * operation, with the only difference being that it never preserves
 * any user-defined metadata fields with the cloned packet.  It is
 * equivalent to calling clone_preserving_field_list with the same
 * type and session parameter values, with empty data.
 */
extern void clone(in CloneType type, in bit<32> session);

@deprecated("Please use 'resubmit_preserving_field_list' instead")
extern void resubmit<T>(in T data);
/***
 * Calling resubmit_preserving_field_list during execution of the
 * ingress control will cause the packet to be resubmitted, i.e. it
 * will begin processing again with the parser, with the contents of
 * the packet exactly as they were when it last began parsing.  The
 * only difference is in the value of the standard_metadata
 * instance_type field, and any user-defined metadata fields that the
 * resubmit_preserving_field_list operation causes to be preserved.
 *
 * The user metadata fields that are tagged with @field_list(index) will
 * be sent to the parser together with the packet.
 *
 * Calling resubmit_preserving_field_list is only supported in the
 * ingress control.  There is no way to undo its effects once it has
 * been called.  If resubmit_preserving_field_list is called multiple
 * times during a single execution of the ingress control, only one
 * packet is resubmitted, and only the user-defined metadata fields
 * specified by the field list index from the last such call are
 * preserved.  See the v1model architecture documentation (Note 1) for
 * more details.
 *
 * For example, the user metadata fields can be annotated as follows:
 * struct UM {
 *    @field_list(1)
 *    bit<32> x;
 *    @field_list(1, 2)
 *    bit<32> y;
 *    bit<32> z;
 * }
 *
 * Calling resubmit_preserving_field_list(1) will resubmit the packet
 * and preserve fields x and y of the user metadata.  Calling
 * resubmit_preserving_field_list(2) will only preserve field y.
 */
extern void resubmit_preserving_field_list(bit<8> index);

@deprecated("Please use 'recirculate_preserving_field_list' instead")
extern void recirculate<T>(in T data);
/***
 * Calling recirculate_preserving_field_list during execution of the
 * egress control will cause the packet to be recirculated, i.e. it
 * will begin processing again with the parser, with the contents of
 * the packet as they are created by the deparser.  Recirculated
 * packets can be distinguished from new packets in ingress processing
 * by the value of the standard_metadata instance_type field.  The
 * caller may request that some user-defined metadata fields be
 * preserved with the recirculated packet.
 *
 * The user metadata fields that are tagged with @field_list(index) will be
 * sent to the parser together with the packet.
 *
 * Calling recirculate_preserving_field_list is only supported in the
 * egress control.  There is no way to undo its effects once it has
 * been called.  If recirculate_preserving_field_list is called
 * multiple times during a single execution of the egress control,
 * only one packet is recirculated, and only the user-defined metadata
 * fields specified by the field list index from the last such call
 * are preserved.  See the v1model architecture documentation (Note 1)
 * for more details.
 */
extern void recirculate_preserving_field_list(bit<8> index);

@deprecated("Please use 'clone_preserving_field_list' instead")
extern void clone3<T>(in CloneType type, in bit<32> session, in T data);

/***
 * Calling clone_preserving_field_list during execution of the ingress
 * or egress control will cause the packet to be cloned, sometimes
 * also called mirroring, i.e. zero or more copies of the packet are
 * made, and each will later begin egress processing as an independent
 * packet from the original packet.  The original packet continues
 * with its normal next steps independent of the clone(s).
 *
 * The session parameter is an integer identifying a clone session id
 * (sometimes called a mirror session id).  The control plane software
 * must configure each session you wish to use, or else no clones will
 * be made using that session.  Typically this will involve the
 * control plane software specifying one output port to which the
 * cloned packet should be sent, or a list of (port, egress_rid) pairs
 * to which a separate clone should be created for each, similar to
 * multicast packets.
 *
 * Cloned packets can be distinguished from others by the value of the
 * standard_metadata instance_type field.
 *
 * The user metadata fields that are tagged with @field_list(index) will be
 * sent to the parser together with a clone of the packet.
 *
 * If clone_preserving_field_list is called during ingress processing,
 * the first parameter must be CloneType.I2E.  If
 * clone_preserving_field_list is called during egress processing, the
 * first parameter must be CloneType.E2E.
 *
 * There is no way to undo its effects once it has been called.  If
 * there are multiple calls to clone_preserving_field_list and/or
 * clone during a single execution of the same ingress (or egress)
 * control, only the last clone session and index are used.  See the
 * v1model architecture documentation (Note 1) for more details.
 */
extern void clone_preserving_field_list(in CloneType type, in bit<32> session, bit<8> index);

extern void truncate(in bit<32> length);

/***
 * Calling assert when the argument is true has no effect, except any
 * effect that might occur due to evaluation of the argument (but see
 * below).  If the argument is false, the precise behavior is
 * target-specific, but the intent is to record or log which assert
 * statement failed, and optionally other information about the
 * failure.
 *
 * For example, on the simple_switch target, executing an assert
 * statement with a false argument causes a log message with the file
 * name and line number of the assert statement to be printed, and
 * then the simple_switch process exits.
 *
 * If you provide the --ndebug command line option to p4c when
 * compiling, the compiled program behaves as if all assert statements
 * were not present in the source code.
 *
 * We strongly recommend that you avoid using expressions as an
 * argument to an assert call that can have side effects, e.g. an
 * extern method or function call that has side effects.  p4c will
 * allow you to do this with no warning given.  We recommend this
 * because, if you follow this advice, your program will behave the
 * same way when assert statements are removed.
 */
extern void assert(in bool check);

/***
 * For the purposes of compiling and executing P4 programs on a target
 * device, assert and assume are identical, including the use of the
 * --ndebug p4c option to elide them.  See documentation for assert.
 *
 * The reason that assume exists as a separate function from assert is
 * because they are expected to be used differently by formal
 * verification tools.  For some formal tools, the goal is to try to
 * find example packets and sets of installed table entries that cause
 * an assert statement condition to be false.
 *
 * Suppose you run such a tool on your program, and the example packet
 * given is an MPLS packet, i.e. hdr.ethernet.etherType == 0x8847.
 * You look at the example, and indeed it does cause an assert
 * condition to be false.  However, your plan is to deploy your P4
 * program in a network in places where no MPLS packets can occur.
 * You could add extra conditions to your P4 program to handle the
 * processing of such a packet cleanly, without assertions failing,
 * but you would prefer to tell the tool "such example packets are not
 * applicable in my scenario -- never show them to me".  By adding a
 * statement:
 *
 *     assume(hdr.ethernet.etherType != 0x8847);
 *
 * at an appropriate place in your program, the formal tool should
 * never show you such examples -- only ones that make all such assume
 * conditions true.
 *
 * The reason that assume statements behave the same as assert
 * statements when compiled to a target device is that if the
 * condition ever evaluates to false when operating in a network, it
 * is likely that your assumption was wrong, and should be reexamined.
 */
extern void assume(in bool check);

/*
 * Log user defined messages
 * Example: log_msg("User defined message");
 * or log_msg("Value1 = {}, Value2 = {}",{value1, value2});
 */
extern void log_msg(string msg);
extern void log_msg<T>(string msg, in T data);

// The name 'standard_metadata' is reserved

/*
 * Architecture.
 *
 * M must be a struct.
 *
 * H must be a struct where every one if its members is of type
 * header, header stack, or header_union.
 */

parser Parser<H, M>(packet_in b,
                    out H parsedHdr,
                    inout M meta,
                    inout standard_metadata_t standard_metadata);

/*
 * The only legal statements in the body of the VerifyChecksum control
 * are: block statements, calls to the verify_checksum and
 * verify_checksum_with_payload methods, and return statements.
 */
control VerifyChecksum<H, M>(inout H hdr,
                             inout M meta);
@pipeline
control Ingress<H, M>(inout H hdr,
                      inout M meta,
                      inout standard_metadata_t standard_metadata);
@pipeline
control Egress<H, M>(inout H hdr,
                     inout M meta,
                     inout standard_metadata_t standard_metadata);

/*
 * The only legal statements in the body of the ComputeChecksum
 * control are: block statements, calls to the update_checksum and
 * update_checksum_with_payload methods, and return statements.
 */
control ComputeChecksum<H, M>(inout H hdr,
                              inout M meta);

/*
 * The only legal statements in the body of the Deparser control are:
 * calls to the packet_out.emit() method.
 */
@deparser
control Deparser<H>(packet_out b, in H hdr);

package V1Switch<H, M>(Parser<H, M> p,
                       VerifyChecksum<H, M> vr,
                       Ingress<H, M> ig,
                       Egress<H, M> eg,
                       ComputeChecksum<H, M> ck,
                       Deparser<H> dep
                       );
# 3 "/root/P4/farreach-private/farreach/bmv2/netbufferv4.p4" 2

// macros
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/macro.p4" 1
// Uncomment it for XMU testbed
//#define USE_BFSDE920

// DEPRECATED: read blocking for pktloss of PUTREQ_LARGEVALUE of cached keys
////#define ENABLE_LARGEVALUEBLOCK

// Uncomment it if support range query, or comment it otherwise
// Change netbufferv4.p4, common.py, and helper.h accordingly
//#define RANGE_SUPPORT

// Uncomment it before evaluation
// NOTE: update config.ini accordingly
//#define DEBUG

// NOTE: 1B optype does not need endian conversion
// 0b0001

//#define WARMUPREQ 0x0011
//#define LOADREQ 0x0021
// 0b0011
# 30 "/root/P4/farreach-private/farreach/bmv2/p4src/macro.p4"
// 0b0110

// For large value

// 0b0111
// 0b1111
# 45 "/root/P4/farreach-private/farreach/bmv2/p4src/macro.p4"
// For large value

// 0b1011




//#define GETRES_LATEST_SEQ_SERVER 0x0046
//#define GETRES_DELETED_SEQ_SERVER 0x005b



// 0b1001

// 0b0101

// 0b0100
# 70 "/root/P4/farreach-private/farreach/bmv2/p4src/macro.p4"
// For large value

// 0b0010



// For large value (PUTREQ_LARGEVALUE_SEQ_CACHED ONLY for netcache/distcache; PUTREQ_LARGEVALUE_SEQ_CASE3 ONLY for farreach/distfarreach)



// For read blocking under cache eviction rare case
# 89 "/root/P4/farreach-private/farreach/bmv2/p4src/macro.p4"
// For read blocking under largevalue rare case

// 0b1000


// 0b1010


// 0b0000
# 117 "/root/P4/farreach-private/farreach/bmv2/p4src/macro.p4"
// NOTE: NETCACHE_CACHE_POP/_ACK, NETCACHE_CACHE_POP_FINISH/_ACK, NETCACHE_CACHE_EVICT/_ACK only used by end-hosts







// For large value (NETCACHE_CACHE_POP_ACK_NLATEST is ONLY used by end-hosts)
# 136 "/root/P4/farreach-private/farreach/bmv2/p4src/macro.p4"
/*
#define GETREQ 0x00
#define PUTREQ 0x01
#define DELREQ 0x02
#define SCANREQ 0x03
#define GETRES 0x04
#define PUTRES 0x05
#define DELRES 0x06
#define SCANRES_SPLIT 0x07
#define GETREQ_INSWITCH 0x08
#define GETREQ_POP 0x09
#define GETREQ_NLATEST 0x0a
#define GETRES_LATEST_SEQ 0x0b
#define GETRES_LATEST_SEQ_INSWITCH 0x0c
#define GETRES_LATEST_SEQ_INSWITCH_CASE1 0x0d
#define GETRES_DELETED_SEQ 0x0e
#define GETRES_DELETED_SEQ_INSWITCH 0x0f
#define GETRES_DELETED_SEQ_INSWITCH_CASE1 0x10
#define PUTREQ_INSWITCH 0x11
#define PUTREQ_SEQ 0x12
#define PUTREQ_POP_SEQ 0x13
#define PUTREQ_SEQ_INSWITCH_CASE1 0x14
#define PUTREQ_SEQ_CASE3 0x15
#define PUTREQ_POP_SEQ_CASE3 0x16
#define DELREQ_INSWITCH 0x17
#define DELREQ_SEQ 0x18
#define DELREQ_SEQ_INSWITCH_CASE1 0x19
#define DELREQ_SEQ_CASE3 0x1a
#define SCANREQ_SPLIT 0x1b
#define CACHE_POP 0x1c
#define CACHE_POP_INSWITCH 0x1d
#define CACHE_POP_INSWITCH_ACK 0x1e
#define CACHE_EVICT 0x1f
#define CACHE_EVICT_ACK 0x20
#define CACHE_EVICT_CASE2 0x21
*/



// NOTE: limited by 12 stages and 64*4B PHV (not T-PHV) (fields in the same ALU must be in the same PHV group)
// 32K * (2B vallen + 128B value + 4B frequency + 1B status)

//#define KV_BUCKET_COUNT 16384
// 64K * 2B counter

//#define HH_THRESHOLD 10
// 32K * 4B counter
# 194 "/root/P4/farreach-private/farreach/bmv2/p4src/macro.p4"
// hot_threshold=10 + sampling_ratio=0.5 -> hot_pktcnt=20 during each clean period (NOTE: cached key will not update CM)
// NOTE: it can be reconfigured by MAT


// egress_pipeline_num * kv_bucket_count
//#define LOOKUP_ENTRY_COUNT 65536


// MAX_SERVER_NUM <= 128

// RANGE_PARTITION_ENTRY_NUM = 14 * MAX_SERVER_NUM < 16 * MAX_SERVER_NUM

// RANGE_PARTITION_FOR_SCAN_ENDKEY_ENTRY_NUM = 1 * MAX_SERVER_NUM

// PROCESS_SCANREQ_SPLIT_ENTRY_NUM = 2 * MAX_SERVER_NUM

// HASH_PARTITION_ENTRY_NUM = 13 * MAX_SERVER_NUM < 16 * MAX_SERVER_NUM


// hash partition range




//#define CPU_PORT 192
# 6 "/root/P4/farreach-private/farreach/bmv2/netbufferv4.p4" 2

// headers
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/header.p4" 1
/* Packet Header Types */

// PUT ipv4 in T-PHV

header ethernet_t {

    bit<48> dstAddr;
    bit<48> srcAddr;
    bit<16> etherType;
}

header ipv4_t {

    bit<4> version;
    bit<4> ihl;
    bit<8> diffserv;
    bit<16> totalLen;
    bit<16> identification;
    bit<3> flags;
    bit<13> fragOffset;
    bit<8> ttl;
    bit<8> protocol;
    bit<16> hdrChecksum;
    bit<32> srcAddr;
    bit<32> dstAddr;
}

header udp_t {

    bit<16> srcPort;
    bit<16> dstPort;
    bit<16> hdrlen;
    bit<16> checksum;
}

header op_t {

    bit<16> optype;
    bit<32> keylolo;
    bit<32> keylohi;
    bit<32> keyhilo;
    bit<16> keyhihilo;
    bit<16> keyhihihi;
}


// Used by PUTREQ and GETRES to save PHV
header vallen_t {
    bit<16> vallen;
}

header val_t {

    bit<32> vallo;
    bit<32> valhi;
}

header shadowtype_t {
    bit<16> shadowtype;
}

header seq_t {

    bit<32> seq;
    bit<32> snapshot_token;
}

// NOTE: inswicth_t affects INSWITCH_PREV_BYTES in packet_format.h
header inswitch_t {

  // 32-bit container
    bit<1> snapshot_flag;
    bit<1> is_cached;
    bit<1> is_sampled;
    bit<10> client_sid; // clone to client for cache hit; NOTE: clone_e2e sets eg_intr_md_for_mb.mirror_id w/ 10 bits
    bit<3> padding;
    bit<16> hot_threshold;
  // 32-bit containers
    bit<16> hashval_for_cm1; // at most 64K
    bit<16> hashval_for_cm2; // at most 64K
    bit<16> hashval_for_cm3; // at most 64K
    bit<16> hashval_for_cm4; // at most 64K
    bit<32> snapshot_token; // NOTE: only place it before inswitch_hdr.idx, we can simply change INSWITCH_PREVBYTES in libcommon
    bit<16> hashval_for_seq; // at most 32K
    bit<16> idx; // index for in-switch cache
}

header stat_t {

    bit<8> stat;
    bit<16> nodeidx_foreval; // cache hit: 0xFFFF; cache miss: [0, servernum-1]
    bit<8> padding;
}

header clone_t {

    bit<16> clonenum_for_pktloss;
    bit<16> client_udpport;
    bit<32> assignedseq_for_farreach;
}

header frequency_t {
    bit<32> frequency;
}

header validvalue_t {
    bit<8> validvalue; // used by SETVALID_INSWITCH to set validvalue_reg
}

header fraginfo_t {

    bit<16> padding1; // clientlogicalidx in T-PHV
    bit<32> padding2; // fragseq in T-PHV
    bit<16> cur_fragidx;
    bit<16> max_fragnum;
}

struct metadata_t {

    bit<1> need_recirculate;

    bit<16> hashval_for_partition; // at most 32K

    bit<4> cm1_predicate;
    bit<4> cm2_predicate;
    bit<4> cm3_predicate;
    bit<4> cm4_predicate;
    bit<1> is_hot;
    bit<1> is_latest; // if the entry is latest
//#ifdef ENABLE_LARGEVALUEBLOCK
    bit<32> largevalueseq;
    bit<1> is_largevalueblock;
//#endif
    bit<1> is_deleted; // if the entry is deleted
    bit<1> is_case1;
    bit<1> is_lastclone_for_pktloss;
    bit<4> access_val_mode; // 0: not access val_reg; 1: get; 2: set_and_get; 3: reset_and_get
    bit<16> recirport;
}

/*header debug_t {



		// 8-bit container

    bit<1> is_hot;

    bit<1> is_lastclone_for_pktloss;

    bit<6> padding;

}*/
# 149 "/root/P4/farreach-private/farreach/bmv2/p4src/header.p4"
// Header instances
struct headers {
# 159 "/root/P4/farreach-private/farreach/bmv2/p4src/header.p4"
 ethernet_t ethernet_hdr;
 /*@pragma pa_no_overlay ingress ipv4_hdr.srcAddr

	@pragma pa_no_overlay egress ipv4_hdr.srcAddr

	@pragma pa_no_overlay ingress ipv4_hdr.dstAddr

	@pragma pa_no_overlay egress ipv4_hdr.dstAddr

	@pragma pa_no_overlay ingress ipv4_hdr.protocol

	@pragma pa_no_overlay egress ipv4_hdr.protocol*/
# 166 "/root/P4/farreach-private/farreach/bmv2/p4src/header.p4"
 ipv4_t ipv4_hdr;
 /*@pragma pa_no_overlay ingress udp_hdr.srcPort

	@pragma pa_no_overlay egress udp_hdr.srcPort

	@pragma pa_no_overlay ingress udp_hdr.dstPort

	@pragma pa_no_overlay egress udp_hdr.dstPort

	@pragma pa_no_overlay ingress udp_hdr.hdrlen

	@pragma pa_no_overlay egress udp_hdr.hdrlen*/
# 173 "/root/P4/farreach-private/farreach/bmv2/p4src/header.p4"
 udp_t udp_hdr;
 op_t op_hdr;
 vallen_t vallen_hdr;
 val_t val1_hdr;
 val_t val2_hdr;
 val_t val3_hdr;
 val_t val4_hdr;
 val_t val5_hdr;
 val_t val6_hdr;
 val_t val7_hdr;
 val_t val8_hdr;
 val_t val9_hdr;
 val_t val10_hdr;
 val_t val11_hdr;
 val_t val12_hdr;
 val_t val13_hdr;
 val_t val14_hdr;
 val_t val15_hdr;
 val_t val16_hdr;
 shadowtype_t shadowtype_hdr;
 seq_t seq_hdr;
 //@pragma pa_no_overlay ingress inswitch_hdr.idx
 //@pragma pa_no_overlay egress inswitch_hdr.idx
 inswitch_t inswitch_hdr;
 stat_t stat_hdr;
 clone_t clone_hdr;
 frequency_t frequency_hdr;
 validvalue_t validvalue_hdr;
 @pragma pa_no_overlay ingress fraginfo_hdr.padding1
 @pragma pa_no_overlay egress fraginfo_hdr.padding1
 @pragma pa_no_overlay ingress fraginfo_hdr.padding2
 @pragma pa_no_overlay egress fraginfo_hdr.padding2
 @pragma pa_no_overlay ingress fraginfo_hdr.cur_fragidx
 @pragma pa_no_overlay egress fraginfo_hdr.cur_fragidx
 @pragma pa_no_overlay ingress fraginfo_hdr.max_fragnum
 @pragma pa_no_overlay egress fraginfo_hdr.max_fragnum
 fraginfo_t fraginfo_hdr;
 //@pragma pa_no_overlay ingress meta.meta.udp_hdrlen
 //@pragma pa_no_overlay egress meta.meta.udp_hdrlen
}
struct metadata {
    /* empty */
    metadata_t meta;
}

//header debug_t debug_hdr;
# 9 "/root/P4/farreach-private/farreach/bmv2/netbufferv4.p4" 2

// parsers
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/parser.p4" 1
/* Parser */






// NOTE: due to hardware limitation, we cannot make too many branches in switch expression

// NOTE: carefully assign optype to reduce branches
// (1) vallen&value: &&& 0b0001; seq: &&& 0b0010; inswitch_hdr: &&& 0b0100; stat: &&& 0b1000;
// (2) scan/split: specific value (X + 0b0000); not parsed optypes: X + 0b0000
// op_hdr + vallen&value + shadowtype (0b0001): PUTREQ, WARMUPREQ (deprecated), LOADREQ
// op_hdr + vallen&value + shadowtype + seq (0b0011): PUTREQ_SEQ, PUTREQ_POP_SEQ, PUTREQ_SEQ_CASE3, PUTREQ_POP_SEQ_CASE3, NETCACHE_PUTREQ_SEQ_CACHED
// op_hdr + vallen&value + shadowtype + seq + inswitch_hdr (0b0111): NONE
// op_hdr + vallen&value + shadowtype + seq + inswitch_hdr + stat (0b1111) (XXX_CASE1 w/ clone_hdr): GETRES_LATEST_SEQ_INSWITCH, GETRES_DELETED_SEQ_INSWITCH, GETRES_LATEST_SEQ_INSWITCH_CASE1, GETRES_DELETED_SEQ_INSWITCH_CASE1, PUTREQ_SEQ_INSWITCH_CASE1, DELREQ_SEQ_INSWITCH_CASE1, LOADSNAPSHOTDATA_INSWITCH_ACK, CACHE_POP_INSWITC, NETCACHE_VALUEUPDATE_INSWITCHH
// op_hdr + vallen&value + shadowtype + seq + stat (0b1011): GETRES_LATEST_SEQ, GETRES_DELETED_SEQ, CACHE_EVICT_LOADDATA_INSWITCH_ACK, NETCACHE_VALUEUPDATE
// op_hdr + vallen&value + shadowtype + stat (0b1001): GETRES
// op_hdr + vallen&value + shadowtype + inswitch (0b0101): PUTREQ_INSWITCH
// op_hdr + shadowtype + inswitch_hdr (0b0100): GETREQ_INSWITCH, DELREQ_INSWITCH, CACHE_EVICT_LOADFREQ_INSWITCH, CACHE_EVICT_LOADDATA_INSWITCH, SETVALID_INSWITCH (w/ validvalue_hdr), NETCACHE_WARMUPREQ_INSWITCH, NETCACHE_WARMUPREQ_INSWITCH_POP (w/ clone_hdr)
// op_hdr + shadowtype + seq (0b0010): DELREQ_SEQ, DELREQ_SEQ_CASE3, NETCACHE_DELREQ_SEQ_CACHED
// op_hdr + shadowtype + stat (0b1000): PUTRES, DELRES
// NOTE: followings are ended with 0b0000
// op_hdr + scan_hdr (specific value): SCANREQ
// op_hdr + scan_hdr + split_hdr (specific value): SCANREQ_SPLIT
// only op_hdr (default): WARMUPREQ, GETREQ, DELREQ, GETREQ_POP, GETREQ_NLATEST, CACHE_POP_INSWITCH_ACK (deprecated: w/ clone_hdr), WARMUPACK, LOADACK, CACHE_POP_ACK, CACHE_EVICT_LOADFREQ_INSWITCH_ACK (w/ frequency_hdr), NETCACHE_GETREQ_POP, NETCACHE_VALUEUPATE_ACK
// not parsed in switch: SCANRES_SPLIT, CACHE_POP, CACHE_EVICT, CACHE_EVICT_ACK, CACHE_EVICT_CASE2, CACHE_POP_ACK, CACHE_EVICT_LOADFREQ_INSWITCH_ACK, SETVALID_INSWITCH_ACK, NETCACHE_CACHE_POP/_ACK, NETCACHE_CACHE_POP_FINISH/_ACK, NETCACHE_CACHE_EVICT/_ACK

parser farreachParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t standard_metadata){
 state start {
  transition parse_ethernet;
 }

 state parse_ethernet {
  packet.extract(hdr.ethernet_hdr);
  transition select(hdr.ethernet_hdr.etherType) {
   0x0800: parse_ipv4;
   default: accept;
  }
 }

 state parse_ipv4 {
  packet.extract(hdr.ipv4_hdr);
  transition select(hdr.ipv4_hdr.protocol) {
   0x11: parse_udp_dstport;
   default: accept;
  }
 }

 state parse_udp_dstport {
  packet.extract(hdr.udp_hdr);
  transition select(hdr.udp_hdr.dstPort) {
   0x0480 &&& 0xFF80: parse_op; // reserve multiple udp port due to server simulation
   5008: parse_op; // reserve reflector.dp2cpserver_port due to hardware link simulation between switch and switchos
   default: parse_udp_srcport;
  }
 }

 state parse_udp_srcport {
  transition select(hdr.udp_hdr.srcPort) {
   0x0480 &&& 0xFF80: parse_op; // reserve multiple udp port due to server simulation
   5009: parse_op; // reserve reflector.cp2dpserver_port due to hardware link simulation between switch and switchos
   default: accept; // traditional packet
  }
 }

 // op_hdr -> scan_hdr -> split_hdr -> vallen_hdr -> val_hdr -> shadowtype_hdr -> seq_hdr -> inswitch_hdr -> stat_hdr -> clone_hdr/frequency_hdr/validvalue_hdr/fraginfo_hdr

 state parse_op {
  packet.extract(hdr.op_hdr);
  transition select(hdr.op_hdr.optype) {
   //CACHE_POP_INSWITCH_ACK: parse_clone;
   0x0100: parse_frequency;
   0x02d0: parse_fraginfo;
   1 &&& 0x01: parse_vallen;
   /*2 &&& 0x02: parse_seq;

			4 &&& 0x04: parse_inswitch;

			8 &&& 0x08: parse_stat;*/
# 82 "/root/P4/farreach-private/farreach/bmv2/p4src/parser.p4"
   2 &&& 0x02: parse_shadowtype;
   4 &&& 0x04: parse_shadowtype;
   8 &&& 0x08: parse_shadowtype;
   default: accept;
  }
 }


 state parse_vallen {
  packet.extract(hdr.vallen_hdr);
  transition select(hdr.vallen_hdr.vallen) {
   //0: parse_val_len0;
   0: parse_shadowtype;
   0 &&& 0xFFF8: parse_val_len1;
   8: parse_val_len1;
   8 &&& 0xFFF8: parse_val_len2;
   16: parse_val_len2;
   16 &&& 0xFFF8: parse_val_len3;
   24: parse_val_len3;
   24 &&& 0xFFF8: parse_val_len4;
   32: parse_val_len4;
   32 &&& 0xFFF8: parse_val_len5;
   40: parse_val_len5;
   40 &&& 0xFFF8: parse_val_len6;
   48: parse_val_len6;
   48 &&& 0xFFF8: parse_val_len7;
   56: parse_val_len7;
   56 &&& 0xFFF8: parse_val_len8;
   64: parse_val_len8;
   64 &&& 0xFFF8: parse_val_len9;
   72: parse_val_len9;
   72 &&& 0xFFF8: parse_val_len10;
   80: parse_val_len10;
   80 &&& 0xFFF8: parse_val_len11;
   88: parse_val_len11;
   88 &&& 0xFFF8: parse_val_len12;
   96: parse_val_len12;
   96 &&& 0xFFF8: parse_val_len13;
   104: parse_val_len13;
   104 &&& 0xFFF8: parse_val_len14;
   112: parse_val_len14;
   112 &&& 0xFFF8: parse_val_len15;
   120: parse_val_len15;
   120 &&& 0xFFF8: parse_val_len16;
   128: parse_val_len16;
   //default: parse_val_len0; // > 128
   default: parse_shadowtype; // > 128
  }
 }

 /*parser parse_val_len0 {

		transition select(hdr.op_hdr.optype) {

			2 &&& 0x02: parse_seq;

			4 &&& 0x04: parse_inswitch;

			8 &&& 0x08: parse_stat;

			default: accept;

			//default: parse_debug;

			

			//GETRES: parse_stat;

			//GETRES_LATEST_SEQ: parse_seq;

			//GETRES_LATEST_SEQ_INSWITCH: parse_seq;

			//GETRES_LATEST_SEQ_INSWITCH_CASE1: parse_seq;

			//GETRES_DELETED_SEQ: parse_seq;

			//GETRES_DELETED_SEQ_INSWITCH: parse_seq;

			//GETRES_DELETED_SEQ_INSWITCH_CASE1: parse_seq;

			//CACHE_POP_INSWITCH: parse_seq;

			//PUTREQ_INSWITCH: parse_inswitch;

			//PUTREQ_SEQ: parse_seq;

			//PUTREQ_POP_SEQ: parse_seq;

			//PUTREQ_SEQ_INSWITCH_CASE1: parse_seq;

			//PUTREQ_SEQ_CASE3: parse_seq;

			//PUTREQ_POP_SEQ_CASE3: parse_seq;

			//DELREQ_INSWITCH: parse_inswitch;

			//DELREQ_SEQ_INSWITCH_CASE1: parse_seq;

			//default: accept; // PUTREQ

			////default: parse_debug; // PUTREQ

		}

	}*/
# 161 "/root/P4/farreach-private/farreach/bmv2/p4src/parser.p4"
 state parse_val_len1 {
  packet.extract(hdr.val1_hdr);
  //return parse_val_len0;
  transition parse_shadowtype;
 }

 state parse_val_len2 {
  packet.extract(hdr.val2_hdr);
  transition parse_val_len1;
 }

 state parse_val_len3 {
  packet.extract(hdr.val3_hdr);
  transition parse_val_len2;
 }

 state parse_val_len4 {
  packet.extract(hdr.val4_hdr);
  transition parse_val_len3;
 }

 state parse_val_len5 {
  packet.extract(hdr.val5_hdr);
  transition parse_val_len4;
 }

 state parse_val_len6 {
  packet.extract(hdr.val6_hdr);
  transition parse_val_len5;
 }

 state parse_val_len7 {
  packet.extract(hdr.val7_hdr);
  transition parse_val_len6;
 }

 state parse_val_len8 {
  packet.extract(hdr.val8_hdr);
  transition parse_val_len7;
 }

 state parse_val_len9 {
  packet.extract(hdr.val9_hdr);
  transition parse_val_len8;
 }

 state parse_val_len10 {
  packet.extract(hdr.val10_hdr);
  transition parse_val_len9;
 }

 state parse_val_len11 {
  packet.extract(hdr.val11_hdr);
  transition parse_val_len10;
 }

 state parse_val_len12 {
  packet.extract(hdr.val12_hdr);
  transition parse_val_len11;
 }

 state parse_val_len13 {
  packet.extract(hdr.val13_hdr);
  transition parse_val_len12;
 }

 state parse_val_len14 {
  packet.extract(hdr.val14_hdr);
  transition parse_val_len13;
 }

 state parse_val_len15 {
  packet.extract(hdr.val15_hdr);
  transition parse_val_len14;
 }

 state parse_val_len16 {
  packet.extract(hdr.val16_hdr);
  transition parse_val_len15;
 }

 state parse_shadowtype {
  packet.extract(hdr.shadowtype_hdr);
  transition select(hdr.shadowtype_hdr.shadowtype) {
   2 &&& 0x02: parse_seq;
   4 &&& 0x04: parse_inswitch;
   8 &&& 0x08: parse_stat;
   default: accept;
   //default: parse_debug;
  }
 }

 state parse_seq {
  packet.extract(hdr.seq_hdr);
  transition select(hdr.shadowtype_hdr.shadowtype) {
   0x0032: parse_fraginfo;
   0x0042: parse_fraginfo;
   0x0052: parse_fraginfo;
   0x0082: parse_fraginfo;
   0x0092: parse_fraginfo;
   0x00c2: parse_fraginfo; // only used by distfarreach
   0x00d2: parse_fraginfo; // only used by distfarreach
   4 &&& 0x04: parse_inswitch;
   8 &&& 0x08: parse_stat;
   default: accept;
   //default: parse_debug;

   /*GETRES_LATEST_SEQ_INSWITCH: parse_inswitch;

			GETRES_LATEST_SEQ_INSWITCH_CASE1: parse_inswitch;

			GETRES_DELETED_SEQ_INSWITCH: parse_inswitch;

			GETRES_DELETED_SEQ_INSWITCH_CASE1: parse_inswitch;

		hdr.	CACHE_POP_INSWITCH: parse_inswitch; // inswitch_hdr is set by switchos

			PUTREQ_SEQ_INSWITCH_CASE1: parse_inswitch;

			DELREQ_SEQ_INSWITCH_CASE1: parse_inswitch;

			default: accept;

			//default: parse_debug; // GETRES_LATEST_SEQ, GETRES_DELETED_SEQ, PUTREQ_SEQ, PUTREQ_POP_SEQ, PUTREQ_SEQ_CASE3, PUTREQ_POP_SEQ_CASE3, DELREQ_SEQ, DELREQ_SEQ_CASE3 */
# 277 "/root/P4/farreach-private/farreach/bmv2/p4src/parser.p4"
  }
 }

 state parse_inswitch {
  packet.extract(hdr.inswitch_hdr);

  transition select(hdr.shadowtype_hdr.shadowtype) {
   0x0054: parse_validvalue;
   0x00a4: parse_fraginfo;
   0x0016: parse_fraginfo;
   8 &&& 0x08: parse_stat;
   default: accept;
   //default: parse_debug;

   /*GETRES_LATEST_SEQ_INSWITCH_CASE1: parse_stat;

			GETRES_DELETED_SEQ_INSWITCH_CASE1: parse_stat;

			PUTREQ_SEQ_INSWITCH_CASE1: parse_stat;

			DELREQ_SEQ_INSWITCH_CASE1: parse_stat;

			default: accept;

			//default: parse_debug; // GETRES_LATEST_SEQ_INSWITCH, GETRES_DELETED_SEQ_INSWITCH, PUTREQ_INSWITCH, DELREQ_INSWITCH, CACHE_POP_INSWITCH */
# 297 "/root/P4/farreach-private/farreach/bmv2/p4src/parser.p4"
  }
 }

 state parse_stat {
  packet.extract(hdr.stat_hdr);
  transition select(hdr.shadowtype_hdr.shadowtype) {
   0x002f: parse_clone;
   0x003f: parse_clone;
   0x004f: parse_clone;
   0x005f: parse_clone;
   default: accept; // CACHE_POP_INSWITCH
   //default: parse_debug;
  }
  //return ingress;
  ////return parse_debug; // GETRES, PUTRES, DELRES, GETRES_LATEST_SEQ_INSWITCH_CASE1, GETRES_DELETED_SEQ_INSWITCH_CASE1, PUTREQ_SEQ_INSWITCH_CASE1, DELREQ_SEQ_INSWITCH_CASE1
 }

 state parse_clone {
  packet.extract(hdr.clone_hdr);
  transition accept;
  //return parse_debug; // GETRES_LATEST_SEQ_INSWITCH_CASE1, GETRES_DELETED_SEQ_INSWITCH_CASE1, PUTREQ_SEQ_INSWITCH_CASE1, DELREQ_SEQ_INSWITCH_CASE1

 }

 state parse_frequency {
  packet.extract(hdr.frequency_hdr);
  transition accept; // CACHE_EVICT_LOADFREQ_INSWITCH_ACK
 }

 state parse_validvalue {
  packet.extract(hdr.validvalue_hdr);
  transition accept; // SETVALID_INSWITCH
 }

 state parse_fraginfo {
  packet.extract(hdr.fraginfo_hdr);
  transition accept; // PUTREQ_LARGEVALUE, PUTREQ_LARGEVALUE_INSWITCH, PUTREQ_LARGEVALUE_SEQ, PUTREQ_LARGEVALUE_SEQ_INSWITCH, PUTREQ_LARGEVALUE_SEQ_CACHED, PUTREQ_LARGEVALUE_SEQ_CASE3
 }
}
/*parser parse_debug {

	packet.extract(hdr.debug_hdr);

	return ingress;

}*/
# 340 "/root/P4/farreach-private/farreach/bmv2/p4src/parser.p4"
control farreachDeparser(packet_out packet, in headers hdr) {
    apply {
  packet.emit(hdr.ethernet_hdr);
  packet.emit(hdr.ipv4_hdr);
  packet.emit(hdr.udp_hdr);
  packet.emit(hdr.op_hdr);

    }
}
# 12 "/root/P4/farreach-private/farreach/bmv2/netbufferv4.p4" 2


# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/ingress.p4" 1
/* Ingress Processing */

control farreachIngress (inout headers hdr,
                  inout metadata meta,
                  inout standard_metadata_t standard_metadata){
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/ingress_mat.p4" 1
/* Ingress Processing (Normal Operation) */

// Stage 0

action l2l3_forward(bit<9>eport) {
 standard_metadata.egress_spec = eport;
}

@pragma stage 0
table l2l3_forward_tbl {
 key = {
  hdr.ethernet_hdr.dstAddr: exact;
  hdr.ipv4_hdr.dstAddr: lpm;
 }
 actions = {
  l2l3_forward;
  NoAction;
 }
 default_action = NoAction();
 size = 16;
}

action set_need_recirculate(bit<16> eport) {
 meta.meta.need_recirculate = 1;
 meta.meta.recirport = eport;
}

action reset_need_recirculate() {
 meta.meta.need_recirculate = 0;
}

@pragma stage 0
table need_recirculate_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  standard_metadata.ingress_port: exact;
 }
 actions = {
  set_need_recirculate;
  reset_need_recirculate;
 }
 default_action = reset_need_recirculate();
 size = 8;
}

action set_hot_threshold(bit<16> hot_threshold) {
 hdr.inswitch_hdr.hot_threshold = hot_threshold;
}

@pragma stage 0
table set_hot_threshold_tbl {
 actions = {
  set_hot_threshold;
 }
 default_action = set_hot_threshold(10);
 size = 1;
}

// Stage 1 (need_recirculate = 1)

//action recirculate_pkt(port) {
//	recirculate(port);
//}

// NOTE: as our Tofino does not support cross-ingress-pipeline recirculation, we use hardware link to simluate it
action recirculate_pkt() {
 // standard_metadata.egress_spec = (bit<9>) meta.meta.recirport;
 // bypass_egress();
 // ???
}

@pragma stage 1
table recirculate_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  meta.meta.need_recirculate: exact;
 }
 actions = {
  recirculate_pkt;
  NoAction;
 }
 default_action = NoAction();
 size = 16;
}

// Stage 1 (need_recirculate = 0)

/*action reset_is_wrong_pipeline() {

	hdr.inswitch_hdr.is_wrong_pipeline = 0;

}*/
# 92 "/root/P4/farreach-private/farreach/bmv2/p4src/ingress_mat.p4"
action hash_for_partition() {
 hash(meta.meta.hashval_for_partition, HashAlgorithm.crc32, (bit<32>)0, {
  hdr.op_hdr.keylolo,
  hdr.op_hdr.keylohi,
  hdr.op_hdr.keyhilo,
  hdr.op_hdr.keyhihilo,
  hdr.op_hdr.keyhihihi
 }, (bit<32>) 32768);
}
@pragma stage 1
table hash_for_partition_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  meta.meta.need_recirculate: exact;
 }
 actions = {
  hash_for_partition;
  NoAction;
 }
 default_action = NoAction();
 size = 16;
}


// Stage 2



action hash_partition(bit<16> udpport,bit<9> eport) {
 hdr.udp_hdr.dstPort = udpport;
 standard_metadata.egress_spec = eport;
}
action hash_partition_for_special_response(bit<9> eport) {
 standard_metadata.egress_spec = eport;
}
@pragma stage 2
table hash_partition_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  meta.meta.hashval_for_partition: range;
  //standard_metadata.ingress_port: exact;
  meta.meta.need_recirculate: exact;
 }
 actions = {
  hash_partition;
  //reset_is_wrong_pipeline;
  hash_partition_for_special_response;
  NoAction;
 }
 //default_action = reset_is_wrong_pipeline();
 default_action = NoAction();
 size = 2048;
}


action hash_for_cm12() {
 hash(hdr.inswitch_hdr.hashval_for_cm1, HashAlgorithm.crc32, (bit<32>)0, {
  hdr.op_hdr.keylolo,
  hdr.op_hdr.keylohi,
  hdr.op_hdr.keyhilo,
  hdr.op_hdr.keyhihilo,
  hdr.op_hdr.keyhihihi
 }, (bit<32>)65536);
 hash(hdr.inswitch_hdr.hashval_for_cm2, HashAlgorithm.crc32_custom, (bit<32>)0, {
  hdr.op_hdr.keylolo,
  hdr.op_hdr.keylohi,
  hdr.op_hdr.keyhilo,
  hdr.op_hdr.keyhihilo,
  hdr.op_hdr.keyhihihi
 }, (bit<32>) 65536);
}

@pragma stage 2
table hash_for_cm12_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  meta.meta.need_recirculate: exact;
 }
 actions = {
  hash_for_cm12;
  NoAction;
 }
 default_action = NoAction();
 size = 2;
}


action cached_action(bit<16> idx) {
 hdr.inswitch_hdr.idx = idx;
 hdr.inswitch_hdr.is_cached = 1;
}

action uncached_action() {
 hdr.inswitch_hdr.is_cached = 0;
}

@pragma stage 2 16384
@pragma stage 3
table cache_lookup_tbl {
 key = {
  hdr.op_hdr.keylolo: exact;
  hdr.op_hdr.keylohi: exact;
  hdr.op_hdr.keyhilo: exact;

  hdr.op_hdr.keyhihilo: exact;
  hdr.op_hdr.keyhihihi: exact;
  meta.meta.need_recirculate: exact;
 }
 actions = {
  cached_action;
  uncached_action;
 }
 default_action = uncached_action();
 size = 32768; // egress_pipenum * KV_BUCKET_COUNT
}


// Stage 3
# 243 "/root/P4/farreach-private/farreach/bmv2/p4src/ingress_mat.p4"
action hash_for_seq() {
 hash(hdr.inswitch_hdr.hashval_for_seq, HashAlgorithm.crc32, (bit<32>)0, {
  hdr.op_hdr.keylolo,
  hdr.op_hdr.keylohi,
  hdr.op_hdr.keyhilo,
  hdr.op_hdr.keyhihilo,
  hdr.op_hdr.keyhihihi
 }, (bit<32>) 32768);
}

@pragma stage 3
table hash_for_seq_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  meta.meta.need_recirculate: exact;
 }
 actions = {
  hash_for_seq;
  NoAction;
 }
 default_action = NoAction();
 size = 4;
}

// Stage 4

action hash_for_cm34() {
 hash(hdr.inswitch_hdr.hashval_for_cm3, HashAlgorithm.identity, (bit<32>)0, {
  hdr.op_hdr.keylolo,
  hdr.op_hdr.keylohi,
  hdr.op_hdr.keyhilo,
  hdr.op_hdr.keyhihilo,
  hdr.op_hdr.keyhihihi
 }, (bit<32>) 65536);
 hash(hdr.inswitch_hdr.hashval_for_cm4, HashAlgorithm.csum16, (bit<32>)0, {
  hdr.op_hdr.keylolo,
  hdr.op_hdr.keylohi,
  hdr.op_hdr.keyhilo,
  hdr.op_hdr.keyhihilo,
  hdr.op_hdr.keyhihihi
 }, (bit<32>) 65536);
}

@pragma stage 4
table hash_for_cm34_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  meta.meta.need_recirculate: exact;
 }
 actions = {
  hash_for_cm34;
  NoAction;
 }
 default_action = NoAction();
 size = 2;
}

action set_snapshot_flag(bit<32> snapshotid) {
 hdr.inswitch_hdr.snapshot_flag = 1;
 //seq_hdr.snapshot_token = snapshotid;
 hdr.inswitch_hdr.snapshot_token = snapshotid;
}

action reset_snapshot_flag() {
 hdr.inswitch_hdr.snapshot_flag = 0;
 //seq_hdr.snapshot_token = 0;
 hdr.inswitch_hdr.snapshot_token = 0;
}

@pragma stage 4
table snapshot_flag_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  meta.meta.need_recirculate: exact;
 }
 actions = {
  set_snapshot_flag;
  reset_snapshot_flag;
 }
 default_action = reset_snapshot_flag();
 size = 8;
}

// Stage 5



// NOTE: standard_metadata.engress_port is a read-only field (we cannot directly set egress port in egress pipeline even if w/ correct pipeline)
// NOTE: using inswitch_hdr.client_sid for clone_e2e in ALU needs to maintain inswitch_hdr.client_sid and eg_intr_md_for_md.mirror_id into the same group, which violates PHV allocation constraints -> but MAU can access different groups
action set_client_sid(bit<10> client_sid) {
 hdr.inswitch_hdr.client_sid = client_sid;
}

@pragma stage 5
table prepare_for_cachehit_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  //standard_metadata.ingress_port: exact;
  hdr.ipv4_hdr.srcAddr: lpm;
  meta.meta.need_recirculate: exact;
 }
 actions = {
  set_client_sid;
  NoAction;
 }
 default_action = set_client_sid(0); // deprecated: configured as set_client_sid(sids[0]) in ptf
 size = 32;
}

action forward_normal_response(bit<9> eport) {
 standard_metadata.egress_spec = eport;
}

action forward_special_get_response(bit<10> client_sid) {
 // NOTE: eport to server has already been set by partition_tbl for GETRES_LATEST/DELETED_SEQ
 //standard_metadata.egress_spec = standard_metadata.ingress_port; // Original packet enters the egress pipeline to server
 clone(CloneType.I2E, (bit<32>)client_sid);
 // clone_ingress_pkt_to_egress(client_sid); // Cloned packet enter the egress pipeline to corresponding client
}

@pragma stage 5
table ipv4_forward_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.ipv4_hdr.dstAddr: lpm;
  meta.meta.need_recirculate: exact;
 }
 actions = {
  forward_normal_response;
  forward_special_get_response;
  NoAction;
 }
 default_action = NoAction();
 size = 128;
}

// Stage 6

action sample() {
 //hash((inswitch_hdr.is_sampled, 0, hash_calc, 2), HashAlgorithm.crc32, (bit<32>)0, {
 // 	hdr.op_hdr.keylolo,
 // 	hdr.op_hdr.keylohi,
 // 	hdr.op_hdr.keyhilo,
 // 	hdr.op_hdr.keyhihilo,
 // 	hdr.op_hdr.keyhihihi
 // }, (bit<32>) (inswitch_hdr.is_sampled); // WRONG: we should not sample key
 random(hdr.inswitch_hdr.is_sampled,(bit<1>)0,(bit<1>)1);; // generate a random value in [0, 1] to sample packet
}

@pragma stage 6
table sample_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  meta.meta.need_recirculate: exact;
 }
 actions = {
  sample;
  NoAction;
 }
 default_action = NoAction();
 size = 2;
}

action update_getreq_to_getreq_inswitch() {
 hdr.op_hdr.optype = 0x0004;
 hdr.shadowtype_hdr.shadowtype = 0x0004;
 hdr.shadowtype_hdr.setValid();
 hdr.inswitch_hdr.setValid();
}

action update_getres_latest_seq_to_getres_latest_seq_inswitch() {
 hdr.op_hdr.optype = 0x000f;
 hdr.shadowtype_hdr.shadowtype = 0x000f;
 hdr.inswitch_hdr.setValid();
}

action update_getres_deleted_seq_to_getres_deleted_seq_inswitch() {
 hdr.op_hdr.optype = 0x001f;
 hdr.shadowtype_hdr.shadowtype = 0x001f;
 hdr.inswitch_hdr.setValid();
}

action update_putreq_to_putreq_inswitch() {
 hdr.op_hdr.optype = 0x0005;
 hdr.shadowtype_hdr.shadowtype = 0x0005;
 hdr.shadowtype_hdr.setValid();
 hdr.inswitch_hdr.setValid();
}

action update_delreq_to_delreq_inswitch() {
 hdr.op_hdr.optype = 0x0014;
 hdr.shadowtype_hdr.shadowtype = 0x0014;
 hdr.shadowtype_hdr.setValid();
 hdr.inswitch_hdr.setValid();
}

action update_putreq_largevalue_to_putreq_largevalue_inswitch() {
 // NOTE: PUTREQ_LARGEVALUE only w/ op_hdr + fraginfo_hdr -> PUTREQ_LARGEVALUE_INSWITCH w/ op_hdr + shadowtype_hdr + inswitch_hdr + fraginfo_hdr
 hdr.op_hdr.optype = 0x00a4;
 hdr.shadowtype_hdr.shadowtype = 0x00a4;

 hdr.shadowtype_hdr.setValid();
 hdr.inswitch_hdr.setValid();
}
# 455 "/root/P4/farreach-private/farreach/bmv2/p4src/ingress_mat.p4"
@pragma stage 6
table ig_port_forward_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  meta.meta.need_recirculate: exact;
 }
 actions = {
  update_getreq_to_getreq_inswitch;
  update_getres_latest_seq_to_getres_latest_seq_inswitch;
  update_getres_deleted_seq_to_getres_deleted_seq_inswitch;
  update_putreq_to_putreq_inswitch;
  update_delreq_to_delreq_inswitch;

  update_putreq_largevalue_to_putreq_largevalue_inswitch;
  NoAction;
 }
 default_action = NoAction();
 size = 8;
}
# 7 "/root/P4/farreach-private/farreach/bmv2/p4src/ingress.p4" 2
    apply{
        // Stage 0
        if (!hdr.op_hdr.isValid()) {
            l2l3_forward_tbl.apply(); // forward traditional packet
        }else {
        need_recirculate_tbl.apply(); // set meta.meta.need_recirculate
        set_hot_threshold_tbl.apply(); // set inswitch_hdr.hot_threshold

        /* if meta.meta.need_recirculate == 1 */

        // Stage 1
        recirculate_tbl.apply(); // recirculate for atomic snapshot (NOTE: recirculate will collide with modifying egress port)

        /* else if meta.meta.need_recirculate == 0 */

        // Stage 1

        hash_for_partition_tbl.apply(); // for hash partition (including startkey of SCANREQ)


        // Stage 2 (not sure why we cannot place cache_lookup_tbl, hash_for_cm_tbl, and hash_for_seq_tbl in stage 1; follow automatic placement of tofino compiler)
        hash_partition_tbl.apply();

        hash_for_cm12_tbl.apply(); // for CM (access inswitch_hdr.hashval_for_cm1/2)
        // IMPORTANT: to save TCAM, we do not match op_hdr.optype in cache_lookup_tbl 
        // -> so as long as op_hdr.key matches an entry in cache_lookup_tbl, inswitch_hdr.is_cached must be 1 (e.g., CACHE_EVICT_LOADXXX)
        // -> but note that if the optype does not have inswitch_hdr, is_cached of 1 will be dropped after entering egress pipeline, and is_cached is still 0 (e.g., SCANREQ_SPLIT)

        cache_lookup_tbl.apply(); // managed by controller (access inswitch_hdr.is_cached, inswitch_hdr.idx)


        // Stage 3




        //hash_for_cm2_tbl.apply(); // for CM (access inswitch_hdr.hashval_for_cm2)
        hash_for_seq_tbl.apply(); // for seq (access inswitch_hdr.hashval_for_seq)

        // Stage 4
        hash_for_cm34_tbl.apply(); // for CM (access inswitch_hdr.hashval_for_cm3/4)
        snapshot_flag_tbl.apply(); // for snapshot (access inswitch_hdr.snapshot_flag)

        // Stage 5
        //hash_for_cm4_tbl.apply(); // for CM (access inswitch_hdr.hashval_for_cm4)
        prepare_for_cachehit_tbl.apply(); // for response of cache hit (access inswitch_hdr.client_sid)
        ipv4_forward_tbl.apply(); // update egress_port for normal/speical response packets

        // Stage 6
        sample_tbl.apply(); // for CM and cache_frequency (access inswitch_hdr.is_sampled)
        ig_port_forward_tbl.apply(); // update op_hdr.optype
        }
        // Stage 7
        //ig_copy_udplen_for_checksum_tbl.apply();
    }
}
# 15 "/root/P4/farreach-private/farreach/bmv2/netbufferv4.p4" 2
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/egress.p4" 1
control farreachEgress(inout headers hdr,
                 inout metadata meta,
                 inout standard_metadata_t standard_metadata){
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/egress_mat.p4" 1
/* Ingress Processing (Normal Operation) */

// Stage 0

/*@pragma stage 0

table eg_copy_udplen_for_checksum_tbl {

	actions = {

		copy_udplen_for_checksum;

	}

	default_action = copy_udplen_for_checksum();

	size = 1;

}*/
# 14 "/root/P4/farreach-private/farreach/bmv2/p4src/egress_mat.p4"
// Stage 1

action set_is_hot() {
 meta.meta.is_hot = 1;
 //debug_hdr.is_hot = 1;
}

action reset_is_hot() {
 meta.meta.is_hot = 0;
 //debug_hdr.is_hot = 0;
}

@pragma stage 1
table is_hot_tbl {
 key = {
  meta.meta.cm1_predicate: exact;
  meta.meta.cm2_predicate: exact;
  meta.meta.cm3_predicate: exact;
  meta.meta.cm4_predicate: exact;
 }
 actions = {
  set_is_hot;
  reset_is_hot;
 }
 default_action = reset_is_hot();
 size = 1;
}


// Stage 2

action save_client_udpport() {
 hdr.clone_hdr.client_udpport = hdr.udp_hdr.srcPort;
}

@pragma stage 2
table save_client_udpport_tbl {
 key = {
  hdr.op_hdr.optype: exact;
 }
 actions = {
  save_client_udpport;
  NoAction;
 }
 default_action = NoAction();
 size = 4;
}

// Stage 3

action set_is_largevalueblock() {
 meta.meta.is_largevalueblock = 1;
}

@pragma stage 3
table is_largevalueblock_tbl {
 actions = {
  set_is_largevalueblock;
 }
 default_action = set_is_largevalueblock();
 size = 1;
}

// Stage 7
# 87 "/root/P4/farreach-private/farreach/bmv2/p4src/egress_mat.p4"
action set_is_lastclone() {
 meta.meta.is_lastclone_for_pktloss = 1;
 //debug_hdr.is_lastclone_for_pktloss = 1;
}



action reset_is_lastclone_lastscansplit() {
 meta.meta.is_lastclone_for_pktloss = 0;
 //debug_hdr.is_lastclone_for_pktloss = 0;

}

@pragma stage 7
table lastclone_lastscansplit_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.clone_hdr.clonenum_for_pktloss: exact;
 }
 actions = {
  set_is_lastclone;
  reset_is_lastclone_lastscansplit;
 }
 default_action = reset_is_lastclone_lastscansplit();
 size = 8;
}

// Stage 8

action update_getreq_inswitch_to_getreq() {
 hdr.op_hdr.optype = 0x0030;

 hdr.shadowtype_hdr.setInvalid();
 hdr.inswitch_hdr.setInvalid();

 //standard_metadata.engress_port = eport;
}


action update_getreq_inswitch_to_getreq_beingevicted_record(bit<8> stat) {
 hdr.op_hdr.optype = 0x007b;
 hdr.shadowtype_hdr.shadowtype = 0x007b;
 hdr.stat_hdr.stat = stat;

 //shadowtype_hdr.setInvalid();
 hdr.seq_hdr.setValid();
 hdr.inswitch_hdr.setInvalid();
 hdr.stat_hdr.setValid();
}

//#ifdef ENABLE_LARGEVALUEBLOCK
action update_getreq_inswitch_to_getreq_largevalueblock_record(bit<8> stat) {
 hdr.op_hdr.optype = 0x008b;
 hdr.shadowtype_hdr.shadowtype = 0x008b;
 hdr.stat_hdr.stat = stat;

 //shadowtype_hdr.setInvalid();
 hdr.seq_hdr.setValid();
 hdr.inswitch_hdr.setInvalid();
 hdr.stat_hdr.setValid();
}
//#endif

action update_getreq_inswitch_to_getreq_pop() {
 hdr.op_hdr.optype = 0x0050;

 hdr.shadowtype_hdr.setInvalid();
 hdr.inswitch_hdr.setInvalid();

 //standard_metadata.engress_port = eport;
}

action update_getreq_inswitch_to_getreq_nlatest() {
 hdr.op_hdr.optype = 0x0060;

 hdr.shadowtype_hdr.setInvalid();
 hdr.inswitch_hdr.setInvalid();

 //standard_metadata.engress_port = eport;
}

action update_getreq_inswitch_to_getres_seq_by_mirroring(bit<10> client_sid,bit<16> server_port,bit<8> stat) {
 hdr.op_hdr.optype = 0x006b;
 hdr.shadowtype_hdr.shadowtype = 0x006b;
 hdr.stat_hdr.stat = stat;
 hdr.stat_hdr.nodeidx_foreval = 0xFFFF;
 // NOTE: we must set udp.srcPort now, otherwise it will dropped by parser/deparser due to NO reserved udp ports (current pkt will NOT access update_ipmac_srcport_tbl for server2client as current devport is server instead of client)
 hdr.udp_hdr.srcPort = server_port;
 hdr.udp_hdr.dstPort = hdr.clone_hdr.client_udpport;

 /*vallen_hdr.setValid();

	hdr.val1_hdr.setValid();

	hdr.val2_hdr.setValid();

	hdr.val3_hdr.setValid();

	hdr.val4_hdr.setValid();

	hdr.val5_hdr.setValid();

	hdr.val6_hdr.setValid();

	hdr.val7_hdr.setValid();

	hdr.val8_hdr.setValid();

	hdr.val9_hdr.setValid();

	hdr.val10_hdr.setValid();

	hdr.val11_hdr.setValid();

	hdr.val12_hdr.setValid();

	hdr.val13_hdr.setValid();

	hdr.val14_hdr.setValid();

	hdr.val15_hdr.setValid();

	hdr.val16_hdr.setValid();*/
# 195 "/root/P4/farreach-private/farreach/bmv2/p4src/egress_mat.p4"
 hdr.seq_hdr.setValid();
 hdr.inswitch_hdr.setInvalid();
 hdr.stat_hdr.setValid();

 mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring
 clone(CloneType.E2E, (bit<32>)client_sid); // clone to client (inswitch_hdr.client_sid)
}

action update_getres_latest_seq_to_getres_seq() {
 hdr.op_hdr.optype = 0x006b;
 hdr.shadowtype_hdr.shadowtype = 0x006b;
 hdr.stat_hdr.stat = 1;

 //seq_hdr.setInvalid();
 hdr.seq_hdr.setValid();
 hdr.stat_hdr.setValid();
}


//action update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss(switchos_sid, port, stat) {
action update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss(bit<10> switchos_sid,bit<8> stat,bit<16> reflector_port) {
 hdr.op_hdr.optype = 0x002f;
 hdr.shadowtype_hdr.shadowtype = 0x002f;
 hdr.stat_hdr.stat = stat;
 hdr.udp_hdr.dstPort = reflector_port;
 //meta.clonenum_for_pktloss = 1; // 3 ACKs (clone w/ 1 -> clone w/ 0 -> no clone w/ case1)
 hdr.clone_hdr.clonenum_for_pktloss = 2; // 3 ACKs (drop w/ 2 -> clone w/ 1 -> clone w/ 0 -> no clone w/ case1)

 //inswitch_hdr.setInvalid();
 hdr.stat_hdr.setValid();
 hdr.clone_hdr.setValid();

 //standard_metadata.engress_port = port; // set eport to switchos
 mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring
 //clone(CloneType.E2E, (bit<32>)switchos_sid, clone_field_list_for_pktloss); // clone to switchos
 clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos
}

action forward_getres_latest_seq_inswitch_case1_clone_for_pktloss(bit<10> switchos_sid) {
 hdr.clone_hdr.clonenum_for_pktloss = hdr.clone_hdr.clonenum_for_pktloss - 1;

 //clone(CloneType.E2E, (bit<32>)switchos_sid, clone_field_list_for_pktloss); // clone to switchos
 clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos
}

//action forward_getres_latest_seq_inswitch_case1() {
//}

action update_getres_deleted_seq_to_getres_seq() {
 hdr.op_hdr.optype = 0x006b;
 hdr.shadowtype_hdr.shadowtype = 0x006b;
 hdr.stat_hdr.stat = 0;

 //seq_hdr.setInvalid();
 hdr.seq_hdr.setValid();
 hdr.stat_hdr.setValid();
}

//action update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss(switchos_sid, port, stat) {
action update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss(bit<10> switchos_sid,bit<8> stat,bit<16> reflector_port) {
 hdr.op_hdr.optype = 0x003f;
 hdr.shadowtype_hdr.shadowtype = 0x003f;
 hdr.stat_hdr.stat = stat;
 hdr.udp_hdr.dstPort = reflector_port;
 //meta.clonenum_for_pktloss = 1; // 3 ACKs (clone w/ 1 -> clone w/ 0 -> no clone w/ case1)
 hdr.clone_hdr.clonenum_for_pktloss = 2; // 3 ACKs (drop w/ 2 -> clone w/ 1 -> clone w/ 0 -> no clone w/ case1)

 //inswitch_hdr.setInvalid();
 hdr.stat_hdr.setValid();
 hdr.clone_hdr.setValid();

 //standard_metadata.engress_port = port; // set eport to switchos
 mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring
 //clone(CloneType.E2E, (bit<32>)switchos_sid, clone_field_list_for_pktloss); // clone to switchos
 clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos
}

action forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss(bit<10> switchos_sid) {
 hdr.clone_hdr.clonenum_for_pktloss = hdr.clone_hdr.clonenum_for_pktloss - 1;

 //clone(CloneType.E2E, (bit<32>)switchos_sid, clone_field_list_for_pktloss); // clone to switchos
 clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos
}

//action forward_getres_deleted_seq_inswitch_case1() {
//}

action update_putreq_largevalue_inswitch_to_putreq_largevalue_seq() {
 // NOTE: PUTREQ_LARGEVALUE_INSWITCH w/ op_hdr + shadowtype_hdr + inswitch_hdr + fraginfo_hdr -> PUTREQ_LARGEVALUE_SEQ w/ op_hdr + shadowtype_hdr + seq_hdr + fraginfo_hdr
 hdr.op_hdr.optype = 0x0032;
 hdr.shadowtype_hdr.shadowtype = 0x0032;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();
}

action update_putreq_largevalue_inswitch_to_putreq_largevalue_seq_case3() {
 // NOTE: PUTREQ_LARGEVALUE_INSWITCH w/ op_hdr + shadowtype_hdr + inswitch_hdr + fraginfo_hdr -> PUTREQ_LARGEVALUE_SEQ_CASE3 w/ op_hdr + shadowtype_hdr + seq_hdr + fraginfo_hdr
 hdr.op_hdr.optype = 0x0052;
 hdr.shadowtype_hdr.shadowtype = 0x0052;
 hdr.seq_hdr.snapshot_token = hdr.inswitch_hdr.snapshot_token;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();
}

action update_putreq_largevalue_inswitch_to_putreq_largevalue_seq_beingevicted() {
 // NOTE: PUTREQ_LARGEVALUE_INSWITCH w/ op_hdr + shadowtype_hdr + inswitch_hdr + fraginfo_hdr -> PUTREQ_LARGEVALUE_SEQ_BEINGEVICTED w/ op_hdr + shadowtype_hdr + seq_hdr + fraginfo_hdr
 hdr.op_hdr.optype = 0x0082;
 hdr.shadowtype_hdr.shadowtype = 0x0082;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();
}

action update_putreq_largevalue_inswitch_to_putreq_largevalue_seq_case3_beingevicted() {
 // NOTE: PUTREQ_LARGEVALUE_INSWITCH w/ op_hdr + shadowtype_hdr + inswitch_hdr + fraginfo_hdr -> PUTREQ_LARGEVALUE_SEQ_CASE3_BEINGEVICTED w/ op_hdr + shadowtype_hdr + seq_hdr + fraginfo_hdr
 hdr.op_hdr.optype = 0x0092;
 hdr.shadowtype_hdr.shadowtype = 0x0092;
 hdr.seq_hdr.snapshot_token = hdr.inswitch_hdr.snapshot_token;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();
}
# 328 "/root/P4/farreach-private/farreach/bmv2/p4src/egress_mat.p4"
@pragma stage 8
table another_eg_port_forward_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.inswitch_hdr.is_cached: exact;
  meta.meta.is_hot: exact;
  hdr.validvalue_hdr.validvalue: exact;
  meta.meta.is_latest: exact;
//#ifdef ENABLE_LARGEVALUEBLOCK
  meta.meta.is_largevalueblock: exact;
//#endif
  meta.meta.is_deleted: exact;
  hdr.inswitch_hdr.client_sid: exact;
  meta.meta.is_lastclone_for_pktloss: exact;
  hdr.inswitch_hdr.snapshot_flag: exact;
  meta.meta.is_case1: exact;
 }
 actions = {
  update_getreq_inswitch_to_getreq;
//		update_getreq_inswitch_to_getreq_beingevicted;
////#ifdef ENABLE_LARGEVALUEBLOCK
//		update_getreq_inswitch_to_getreq_largevalueblock_seq;
////#endif
  update_getreq_inswitch_to_getreq_beingevicted_record;
//#ifdef ENABLE_LARGEVALUEBLOCK
  update_getreq_inswitch_to_getreq_largevalueblock_record;
//#endif
  update_getreq_inswitch_to_getreq_pop;
  update_getreq_inswitch_to_getreq_nlatest;
  update_getreq_inswitch_to_getres_seq_by_mirroring;
  update_getres_latest_seq_to_getres_seq; // GETRES_LATEST_SEQ must be cloned from ingress to egress
  update_getres_latest_seq_inswitch_to_getres_latest_seq_inswitch_case1_clone_for_pktloss; // drop original packet of GETRES_LATEST_SEQ -> clone for first GETRES_LATEST_SEQ_INSWITCH_CASE1
  //drop_getres_latest_seq_inswitch; // drop original packet of GETRES_LATEST_SEQ
  forward_getres_latest_seq_inswitch_case1_clone_for_pktloss; // not last clone of GETRES_LATEST_SEQ_INSWITCH_CASE1
  //forward_getres_latest_seq_inswitch_case1; // last clone of GETRES_LATEST_SEQ_INSWITCH_CASE1
  update_getres_deleted_seq_to_getres_seq; // GETRES_DELETED_SEQ must be cloned from ingress to egress
  update_getres_deleted_seq_inswitch_to_getres_deleted_seq_inswitch_case1_clone_for_pktloss; // drop original packet of GETRES_DELETED_SEQ -> clone for first GETRES_DELETED_SEQ_INSWITCH_CASE1
  //drop_getres_deleted_seq_inswitch; // original packet of GETRES_DELETED_SEQ
  forward_getres_deleted_seq_inswitch_case1_clone_for_pktloss; // not last clone of GETRES_DELETED_SEQ_INSWITCH_CASE1
  //forward_getres_deleted_seq_inswitch_case1; // last clone of GETRES_DELETED_SEQ_INSWITCH_CASE1
  update_putreq_largevalue_inswitch_to_putreq_largevalue_seq;
  update_putreq_largevalue_inswitch_to_putreq_largevalue_seq_case3;
  update_putreq_largevalue_inswitch_to_putreq_largevalue_seq_beingevicted;
  update_putreq_largevalue_inswitch_to_putreq_largevalue_seq_case3_beingevicted;
  NoAction;
 }
 default_action = NoAction();
//#ifdef ENABLE_LARGEVALUEBLOCK
 size = 512;
//#else
//	size = 256;
//#endif
}

// Stage 9

/*action update_cache_pop_inswitch_to_cache_pop_inswitch_ack_clone_for_pktloss(bit<10> switchos_sid,bit<16>  reflector_port) {

	hdr.op_hdr.optype = CACHE_POP_INSWITCH_ACK;

	hdr.udp_hdr.dstPort = reflector_port;

	//meta.clonenum_for_pktloss = 1; // 3 ACKs (clone w/ 1 -> clone w/ 0 -> no clone w/ ack)

	hdr.clone_hdr.clonenum_for_pktloss = 2; // 3 ACKs (drop w/ 2 -> clone w/ 1 -> clone w/ 0 -> no clone w/ ack)



	//vallen_hdr.setInvalid();

	//val1_hdr.setInvalid();

	//val2_hdr.setInvalid();

	//val3_hdr.setInvalid();

	//val4_hdr.setInvalid();

	//val5_hdr.setInvalid();

	//val6_hdr.setInvalid();

	//val7_hdr.setInvalid();

	//val8_hdr.setInvalid();

	//val9_hdr.setInvalid();

	//val10_hdr.setInvalid();

	//val11_hdr.setInvalid();

	//val12_hdr.setInvalid();

	//val13_hdr.setInvalid();

	//val14_hdr.setInvalid();

	//val15_hdr.setInvalid();

	//val16_hdr.setInvalid();

	hdr.shadowtype_hdr.setInvalid();

	hdr.seq_hdr.setInvalid();

	hdr.inswitch_hdr.setInvalid();

	hdr.clone_hdr.setValid();



	//standard_metadata.engress_port = port; // set eport to switchos

	mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring

	//clone(CloneType.E2E, (bit<32>)switchos_sid, clone_field_list_for_pktloss); // clone to switchos

	clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos

}



action forward_cache_pop_inswitch_ack_clone_for_pktloss(switchos_sid) {

	hdr.clone_hdr.clonenum_for_pktloss = hdr.clone_hdr.clonenum_for_pktloss - 1;



	//clone(CloneType.E2E, (bit<32>)switchos_sid, clone_field_list_for_pktloss); // clone to switchos

	clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos

}*/
# 425 "/root/P4/farreach-private/farreach/bmv2/p4src/egress_mat.p4"
action update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone(bit<10> switchos_sid,bit<16> reflector_port) {
 hdr.op_hdr.optype = 0x0070;
 hdr.udp_hdr.dstPort = reflector_port;

 // NOTE: we add/remove vallen and value headers in add_remove_value_header_tbl
 hdr.shadowtype_hdr.setInvalid();
 hdr.seq_hdr.setInvalid();
 hdr.inswitch_hdr.setInvalid();
 hdr.stat_hdr.setInvalid();

 mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring
 clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos
}

//action forward_cache_pop_inswitch_ack() {
//}

action update_putreq_inswitch_to_putreq_seq() {
 hdr.op_hdr.optype = 0x0003;
 hdr.shadowtype_hdr.shadowtype = 0x0003;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();

 //standard_metadata.engress_port = eport;
}

action update_putreq_inswitch_to_putreq_seq_beingevicted() {
 hdr.op_hdr.optype = 0x0053;
 hdr.shadowtype_hdr.shadowtype = 0x0053;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();
}

action update_putreq_inswitch_to_putreq_pop_seq() {
 hdr.op_hdr.optype = 0x0013;
 hdr.shadowtype_hdr.shadowtype = 0x0013;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();

 //standard_metadata.engress_port = eport;
}

action update_putreq_inswitch_to_putres_seq_by_mirroring(bit<10> client_sid,bit<16> server_port) {
 hdr.op_hdr.optype = 0x000a;
 hdr.shadowtype_hdr.shadowtype = 0x000a;
 hdr.seq_hdr.seq = hdr.clone_hdr.assignedseq_for_farreach;
 hdr.stat_hdr.stat = 1;
 hdr.stat_hdr.nodeidx_foreval = 0xFFFF;
 // NOTE: we must set udp.srcPort now, otherwise it will dropped by parser/deparser due to NO reserved udp ports (current pkt will NOT access update_ipmac_srcport_tbl for server2client as current devport is server instead of client)
 hdr.udp_hdr.srcPort = server_port;
 hdr.udp_hdr.dstPort = hdr.clone_hdr.client_udpport;

 /*vallen_hdr.setInvalid();

	hdr.val1_hdr.setInvalid();

	hdr.val2_hdr.setInvalid();

	hdr.val3_hdr.setInvalid();

	hdr.val4_hdr.setInvalid();

	hdr.val5_hdr.setInvalid();

	hdr.val6_hdr.setInvalid();

	hdr.val7_hdr.setInvalid();

	hdr.val8_hdr.setInvalid();

	hdr.val9_hdr.setInvalid();

	hdr.val10_hdr.setInvalid();

	hdr.val11_hdr.setInvalid();

	hdr.val12_hdr.setInvalid();

	hdr.val13_hdr.setInvalid();

	hdr.val14_hdr.setInvalid();

	hdr.val15_hdr.setInvalid();

	hdr.val16_hdr.setInvalid();*/
# 498 "/root/P4/farreach-private/farreach/bmv2/p4src/egress_mat.p4"
 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();
 hdr.stat_hdr.setValid();

 mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring
 clone(CloneType.E2E, (bit<32>)client_sid); // clone to client (inswitch_hdr.client_sid)
}

/*field_list clone_field_list_for_pktloss_and_res {

	meta.meta.clonenum_for_pktloss;

	meta.meta.client_udpport;

	// NOTE: extracted fields cannot be used as clone fields

	//inswitch_hdr.is_wrong_pipeline;

	//inswitch_hdr.eport_for_res;

	//inswitch_hdr.client_sid;

}*/
# 515 "/root/P4/farreach-private/farreach/bmv2/p4src/egress_mat.p4"
//action update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres(switchos_sid, port, stat) {
action update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres(bit<10> switchos_sid,bit<8> stat,bit<16> reflector_port) {
 hdr.op_hdr.optype = 0x004f;
 hdr.shadowtype_hdr.shadowtype = 0x004f;
 hdr.stat_hdr.stat = stat;
 hdr.udp_hdr.dstPort = reflector_port;
 //meta.clonenum_for_pktloss = 2; // 3 ACKs (clone w/ 2 -> clone w/ 1 -> clone w/ 0 -> drop w/ PUTRES)
 hdr.clone_hdr.clonenum_for_pktloss = 3; // 3 ACKs (drop w/ 3 -> clone w/ 2 -> clone w/ 1 -> clone w/ 0 -> drop w/ PUTRES)

 //inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();
 hdr.stat_hdr.setValid();
 hdr.clone_hdr.setValid();

 //standard_metadata.engress_port = port; // set eport to switchos
 mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring
 //clone(CloneType.E2E, (bit<32>)switchos_sid, clone_field_list_for_pktloss_and_res); // clone to switchos
 clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos
}

action forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres(bit<10> switchos_sid) {
 hdr.clone_hdr.clonenum_for_pktloss = hdr.clone_hdr.clonenum_for_pktloss - 1;

 //clone(CloneType.E2E, (bit<32>)switchos_sid, clone_field_list_for_pktloss_and_res); // clone to switchos
 clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos
}

action update_putreq_seq_inswitch_case1_to_putres_seq_by_mirroring(bit<10> client_sid,bit<16> server_port) {
 hdr.op_hdr.optype = 0x000a;
 hdr.shadowtype_hdr.shadowtype = 0x000a;
 hdr.seq_hdr.seq = hdr.clone_hdr.assignedseq_for_farreach;
 hdr.stat_hdr.stat = 1;
 hdr.stat_hdr.nodeidx_foreval = 0xFFFF;
 // NOTE: we must set udp.srcPort now, otherwise it will dropped by parser/deparser due to NO reserved udp ports (current pkt will NOT access update_ipmac_srcport_tbl for server2client as current devport is server instead of client)
 hdr.udp_hdr.srcPort = server_port;
 hdr.udp_hdr.dstPort = hdr.clone_hdr.client_udpport;

 /*vallen_hdr.setInvalid();

	hdr.val1_hdr.setInvalid();

	hdr.val2_hdr.setInvalid();

	hdr.val3_hdr.setInvalid();

	hdr.val4_hdr.setInvalid();

	hdr.val5_hdr.setInvalid();

	hdr.val6_hdr.setInvalid();

	hdr.val7_hdr.setInvalid();

	hdr.val8_hdr.setInvalid();

	hdr.val9_hdr.setInvalid();

	hdr.val10_hdr.setInvalid();

	hdr.val11_hdr.setInvalid();

	hdr.val12_hdr.setInvalid();

	hdr.val13_hdr.setInvalid();

	hdr.val14_hdr.setInvalid();

	hdr.val15_hdr.setInvalid();

	hdr.val16_hdr.setInvalid();*/
# 570 "/root/P4/farreach-private/farreach/bmv2/p4src/egress_mat.p4"
 //seq_hdr.setInvalid();
 hdr.seq_hdr.setValid();

 hdr.inswitch_hdr.setInvalid();
 hdr.clone_hdr.setInvalid();

 mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring
 clone(CloneType.E2E, (bit<32>)client_sid); // clone to client (inswitch_hdr.client_sid)
}

action update_putreq_inswitch_to_putreq_seq_case3() {
 hdr.op_hdr.optype = 0x0023;
 hdr.shadowtype_hdr.shadowtype = 0x0023;
 hdr.seq_hdr.snapshot_token = hdr.inswitch_hdr.snapshot_token;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();

 //standard_metadata.engress_port = eport;
}

action update_putreq_inswitch_to_putreq_seq_case3_beingevicted() {
 hdr.op_hdr.optype = 0x0063;
 hdr.shadowtype_hdr.shadowtype = 0x0063;
 hdr.seq_hdr.snapshot_token = hdr.inswitch_hdr.snapshot_token;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();
}

action update_putreq_inswitch_to_putreq_pop_seq_case3() {
 hdr.op_hdr.optype = 0x0033;
 hdr.shadowtype_hdr.shadowtype = 0x0033;
 hdr.seq_hdr.snapshot_token = hdr.inswitch_hdr.snapshot_token;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();

 //standard_metadata.engress_port = eport;
}

action update_delreq_inswitch_to_delreq_seq() {
 hdr.op_hdr.optype = 0x0002;
 hdr.shadowtype_hdr.shadowtype = 0x0002;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();

 //standard_metadata.engress_port = eport;
}

action update_delreq_inswitch_to_delreq_seq_beingevicted() {
 hdr.op_hdr.optype = 0x0062;
 hdr.shadowtype_hdr.shadowtype = 0x0062;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();
}

action update_delreq_inswitch_to_delres_seq_by_mirroring(bit<10> client_sid,bit<16> server_port) {
 hdr.op_hdr.optype = 0x001a;
 hdr.shadowtype_hdr.shadowtype = 0x001a;
 hdr.seq_hdr.seq = hdr.clone_hdr.assignedseq_for_farreach;
 hdr.stat_hdr.stat = 1;
 hdr.stat_hdr.nodeidx_foreval = 0xFFFF;
 // NOTE: we must set udp.srcPort now, otherwise it will dropped by parser/deparser due to NO reserved udp ports (current pkt will NOT access update_ipmac_srcport_tbl for server2client as current devport is server instead of client)
 hdr.udp_hdr.srcPort = server_port;
 hdr.udp_hdr.dstPort = hdr.clone_hdr.client_udpport;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();
 hdr.stat_hdr.setValid();

 mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring
 clone(CloneType.E2E, (bit<32>)client_sid); // clone to client (inswitch_hdr.client_sid)
}

//action update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres(switchos_sid, port, stat) {
action update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres(bit<10> switchos_sid,bit<8> stat,bit<16> reflector_port) {
 hdr.op_hdr.optype = 0x005f;
 hdr.shadowtype_hdr.shadowtype = 0x005f;
 hdr.stat_hdr.stat = stat;
 hdr.udp_hdr.dstPort = reflector_port;
 //meta.clonenum_for_pktloss = 2; // 3 ACKs (clone w/ 2 -> clone w/ 1 -> clone w/ 0 -> DELRES)
 hdr.clone_hdr.clonenum_for_pktloss = 3; // 3 ACKs (drop w/ 3 -> clone w/ 2 -> clone w/ 1 -> clone w/ 0 -> DELRES)

 //inswitch_hdr.setInvalid();
 /*vallen_hdr.setValid();

	hdr.val1_hdr.setValid();

	hdr.val2_hdr.setValid();

	hdr.val3_hdr.setValid();

	hdr.val4_hdr.setValid();

	hdr.val5_hdr.setValid();

	hdr.val6_hdr.setValid();

	hdr.val7_hdr.setValid();

	hdr.val8_hdr.setValid();

	hdr.val9_hdr.setValid();

	hdr.val10_hdr.setValid();

	hdr.val11_hdr.setValid();

	hdr.val12_hdr.setValid();

	hdr.val13_hdr.setValid();

	hdr.val14_hdr.setValid();

	hdr.val15_hdr.setValid();

	hdr.val16_hdr.setValid();*/
# 674 "/root/P4/farreach-private/farreach/bmv2/p4src/egress_mat.p4"
 hdr.seq_hdr.setValid();
 hdr.stat_hdr.setValid();
 hdr.clone_hdr.setValid();

 //standard_metadata.engress_port = port; // set eport to switchos
 mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring
 //clone(CloneType.E2E, (bit<32>)switchos_sid, clone_field_list_for_pktloss_and_res); // clone to switchps
 clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos
}

action forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres(bit<10> switchos_sid) {
 hdr.clone_hdr.clonenum_for_pktloss = hdr.clone_hdr.clonenum_for_pktloss - 1;

 //clone(CloneType.E2E, (bit<32>)switchos_sid, clone_field_list_for_pktloss_and_res); // clone to switchos
 clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos
}

action update_delreq_seq_inswitch_case1_to_delres_seq_by_mirroring(bit<10> client_sid,bit<16> server_port) {
 hdr.op_hdr.optype = 0x001a;
 hdr.shadowtype_hdr.shadowtype = 0x001a;
 hdr.seq_hdr.seq = hdr.clone_hdr.assignedseq_for_farreach;
 hdr.stat_hdr.stat = 1;
 hdr.stat_hdr.nodeidx_foreval = 0xFFFF;
 // NOTE: we must set udp.srcPort now, otherwise it will dropped by parser/deparser due to NO reserved udp ports (current pkt will NOT access update_ipmac_srcport_tbl for server2client as current devport is server instead of client)
 hdr.udp_hdr.srcPort = server_port;
 hdr.udp_hdr.dstPort = hdr.clone_hdr.client_udpport;

 /*vallen_hdr.setInvalid();

	hdr.val1_hdr.setInvalid();

	hdr.val2_hdr.setInvalid();

	hdr.val3_hdr.setInvalid();

	hdr.val4_hdr.setInvalid();

	hdr.val5_hdr.setInvalid();

	hdr.val6_hdr.setInvalid();

	hdr.val7_hdr.setInvalid();

	hdr.val8_hdr.setInvalid();

	hdr.val9_hdr.setInvalid();

	hdr.val10_hdr.setInvalid();

	hdr.val11_hdr.setInvalid();

	hdr.val12_hdr.setInvalid();

	hdr.val13_hdr.setInvalid();

	hdr.val14_hdr.setInvalid();

	hdr.val15_hdr.setInvalid();

	hdr.val16_hdr.setInvalid();*/
# 719 "/root/P4/farreach-private/farreach/bmv2/p4src/egress_mat.p4"
 //seq_hdr.setInvalid();
 hdr.seq_hdr.setValid();

 hdr.inswitch_hdr.setInvalid();
 hdr.clone_hdr.setInvalid();

 mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring
 clone(CloneType.E2E, (bit<32>)client_sid); // clone to client (inswitch_hdr.client_sid)
}

action update_delreq_inswitch_to_delreq_seq_case3() {
 hdr.op_hdr.optype = 0x0012;
 hdr.shadowtype_hdr.shadowtype = 0x0012;
 hdr.seq_hdr.snapshot_token = hdr.inswitch_hdr.snapshot_token;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();

 //standard_metadata.engress_port = eport;
}

action update_delreq_inswitch_to_delreq_seq_case3_beingevicted() {
 hdr.op_hdr.optype = 0x0072;
 hdr.shadowtype_hdr.shadowtype = 0x0072;
 hdr.seq_hdr.snapshot_token = hdr.inswitch_hdr.snapshot_token;

 hdr.inswitch_hdr.setInvalid();
 hdr.seq_hdr.setValid();
}


action update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone(bit<10> switchos_sid,bit<16> reflector_port) {
 hdr.op_hdr.optype = 0x0100;
 hdr.udp_hdr.dstPort = reflector_port;

 hdr.shadowtype_hdr.setInvalid();
 hdr.inswitch_hdr.setInvalid();
 hdr.frequency_hdr.setValid();

 mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring
 clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos
}

//action forward_cache_evict_loadfreq_inswitch_ack() {
//}

action update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone(bit<10> switchos_sid,bit<16> reflector_port,bit<8> stat) {
 hdr.op_hdr.optype = 0x002b;
 hdr.udp_hdr.dstPort = reflector_port;
 hdr.shadowtype_hdr.shadowtype = 0x002b;
 hdr.stat_hdr.stat = stat;

 hdr.inswitch_hdr.setInvalid();
 // NOTE: we add/remove vallen and value headers in add_remove_value_header_tbl
 hdr.seq_hdr.setValid();
 hdr.stat_hdr.setValid();

 mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring
 clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos
}

//action forward_cache_evict_loaddata_inswitch_ack() {
//}

action update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone(bit<10> switchos_sid,bit<16> reflector_port, bit<8> stat) {
 hdr.op_hdr.optype = 0x006f;
 hdr.udp_hdr.dstPort = reflector_port;
 hdr.shadowtype_hdr.shadowtype = 0x006f;
 hdr.stat_hdr.stat = stat;

 // NOTE: we add/remove vallen and value headers in add_remove_value_header_tbl
 hdr.seq_hdr.setValid();
 hdr.stat_hdr.setValid();

 mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring
 clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos
}

//action forward_loadsnapshotdata_inswitch_ack() {
//}

action update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone(bit<10> switchos_sid,bit<16> reflector_port) {
 hdr.op_hdr.optype = 0x0110;
 hdr.udp_hdr.dstPort = reflector_port;

 hdr.shadowtype_hdr.setInvalid();
 hdr.inswitch_hdr.setInvalid();
 hdr.validvalue_hdr.setInvalid();

 mark_to_drop(standard_metadata); // Disable unicast, but enable mirroring
 clone(CloneType.E2E, (bit<32>)switchos_sid); // clone to switchos
}

//action forward_setvalid_inswitch_ack() {
//}
# 823 "/root/P4/farreach-private/farreach/bmv2/p4src/egress_mat.p4"
@pragma stage 9
table eg_port_forward_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.inswitch_hdr.is_cached: exact;
  meta.meta.is_hot: exact;

  hdr.validvalue_hdr.validvalue: exact;
  meta.meta.is_latest: exact;
  meta.meta.is_deleted: exact;

  hdr.inswitch_hdr.client_sid: exact;
  meta.meta.is_lastclone_for_pktloss: exact;

  hdr.inswitch_hdr.snapshot_flag: exact;
  meta.meta.is_case1: exact;
 }
 actions = {
  //update_cache_pop_inswitch_to_cache_pop_inswitch_ack_clone_for_pktloss; // clone for first CACHE_POP_INSWITCH_ACK
  //forward_cache_pop_inswitch_ack_clone_for_pktloss; // not last clone of CACHE_POP_INSWITCH_ACK
  update_cache_pop_inswitch_to_cache_pop_inswitch_ack_drop_and_clone; // clone for first CACHE_POP_INSWITCH_ACK (not need to clone for duplication due to switchos-side timeout-and-retry)
  //forward_cache_pop_inswitch_ack; // last clone of CACHE_POP_INSWITCH_ACK
  update_putreq_inswitch_to_putreq_seq;
  update_putreq_inswitch_to_putreq_seq_beingevicted;
  update_putreq_inswitch_to_putreq_pop_seq;
  update_putreq_inswitch_to_putres_seq_by_mirroring;
  update_putreq_inswitch_to_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres;
  forward_putreq_seq_inswitch_case1_clone_for_pktloss_and_putres;
  update_putreq_seq_inswitch_case1_to_putres_seq_by_mirroring;
  update_putreq_inswitch_to_putreq_seq_case3;
  update_putreq_inswitch_to_putreq_seq_case3_beingevicted;
  update_putreq_inswitch_to_putreq_pop_seq_case3;
  update_delreq_inswitch_to_delreq_seq;
  update_delreq_inswitch_to_delreq_seq_beingevicted;
  update_delreq_inswitch_to_delres_seq_by_mirroring;
  update_delreq_inswitch_to_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres;
  forward_delreq_seq_inswitch_case1_clone_for_pktloss_and_delres;
  update_delreq_seq_inswitch_case1_to_delres_seq_by_mirroring;
  update_delreq_inswitch_to_delreq_seq_case3;
  update_delreq_inswitch_to_delreq_seq_case3_beingevicted;
  update_cache_evict_loadfreq_inswitch_to_cache_evict_loadfreq_inswitch_ack_drop_and_clone; // clone to reflector and hence switchos; but not need clone for pktloss due to switchos-side timeout-and-retry
  //forward_cache_evict_loadfreq_inswitch_ack;
  update_cache_evict_loaddata_inswitch_to_cache_evict_loaddata_inswitch_ack_drop_and_clone; // clone to reflector and hence switchos; but not need clone for pktloss due to switchos-side timeout-and-retry
  //forward_cache_evict_loaddata_inswitch_ack;
  update_loadsnapshotdata_inswitch_to_loadsnapshotdata_inswitch_ack_drop_and_clone;
  //forward_loadsnapshotdata_inswitch_ack;
  update_setvalid_inswitch_to_setvalid_inswitch_ack_drop_and_clone;
  //forward_setvalid_inswitch_ack;
  NoAction;
 }
 default_action = NoAction();
 size = 2048;
}

// stage 10
# 887 "/root/P4/farreach-private/farreach/bmv2/p4src/egress_mat.p4"
action update_ipmac_srcport_server2client(bit<48> client_mac, bit<48> server_mac,bit<32> client_ip,bit<32> server_ip,
bit<16> server_port) {
 hdr.ethernet_hdr.srcAddr = server_mac;
 hdr.ethernet_hdr.dstAddr = client_mac;
 hdr.ipv4_hdr.srcAddr = server_ip;
 hdr.ipv4_hdr.dstAddr = client_ip;
 hdr.udp_hdr.srcPort = server_port;
}

// NOTE: as we use software link, switch_mac/ip = reflector_mac/ip
// NOTE: although we use client_port to update srcport here, reflector does not care about the specific value of srcport
action update_ipmac_srcport_switch2switchos(bit<48> client_mac, bit<48> switch_mac,bit<32> client_ip,bit<32> switch_ip,
bit<16> client_port) {
 hdr.ethernet_hdr.srcAddr = client_mac;
 hdr.ethernet_hdr.dstAddr = switch_mac;
 hdr.ipv4_hdr.srcAddr = client_ip;
 hdr.ipv4_hdr.dstAddr = switch_ip;
 hdr.udp_hdr.srcPort = client_port;
}

action update_dstipmac_client2server(bit<48> server_mac,bit<32> server_ip) {
 hdr.ethernet_hdr.dstAddr = server_mac;
 hdr.ipv4_hdr.dstAddr = server_ip;
}

// NOTE: dstport of REQ, RES, and notification has been updated in partition_tbl, server, and eg_port_forward_tbl
@pragma stage 10
table update_ipmac_srcport_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  standard_metadata.egress_port: exact;
 }
 actions = {
  update_ipmac_srcport_server2client; // focus on dstip and dstmac to corresponding client; use server[0] as srcip and srcmac; use server_worker_port_start as srcport
  update_ipmac_srcport_switch2switchos; // focus on dstip and dstmac to reflector; use client[0] as srcip and srcmac; use constant (123) as srcport
  update_dstipmac_client2server; // focus on dstip and dstmac to corresponding server; NOT change srcip, srcmac, and srcport
  NoAction;
 }
 default_action = NoAction();
 size = 256;
}

// stage 11

// NOTE: only one operand in add can be action parameter or constant -> resort to controller to configure different hdrlen

action update_pktlen(bit<16> udplen,bit<16> iplen) {
 hdr.udp_hdr.hdrlen = udplen;
 hdr.ipv4_hdr.totalLen = iplen;
 //meta.udp_hdrlen = udplen;
}

action add_pktlen(bit<16> udplen_delta,bit<16> iplen_delta) {
 hdr.udp_hdr.hdrlen = hdr.udp_hdr.hdrlen + udplen_delta;
 hdr.ipv4_hdr.totalLen = hdr.ipv4_hdr.totalLen + iplen_delta;
 //hdr.meta.meta.udp_hdrlen = hdr.meta.meta.udp_hdrlen +  udplen_delta
}

@pragma stage 11
table update_pktlen_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.vallen_hdr.vallen: range;
 }
 actions = {
  /*update_onlyop_pktlen;

		update_val_stat_pktlen;

		update_val_seq_inswitch_stat_pktlen;

		update_val_seq_pktlen;

		update_stat_pktlen;

		update_seq_pktlen;*/
# 958 "/root/P4/farreach-private/farreach/bmv2/p4src/egress_mat.p4"
  update_pktlen;
  add_pktlen;
  NoAction;
 }
 default_action = NoAction(); // not change udp_hdr.hdrlen (GETREQ/GETREQ_POP/GETREQ_NLATEST)
 size = 512;
}

action add_only_vallen() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setInvalid();
 hdr.val2_hdr.setInvalid();
 hdr.val3_hdr.setInvalid();
 hdr.val4_hdr.setInvalid();
 hdr.val5_hdr.setInvalid();
 hdr.val6_hdr.setInvalid();
 hdr.val7_hdr.setInvalid();
 hdr.val8_hdr.setInvalid();
 hdr.val9_hdr.setInvalid();
 hdr.val10_hdr.setInvalid();
 hdr.val11_hdr.setInvalid();
 hdr.val12_hdr.setInvalid();
 hdr.val13_hdr.setInvalid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val1() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setInvalid();
 hdr.val3_hdr.setInvalid();
 hdr.val4_hdr.setInvalid();
 hdr.val5_hdr.setInvalid();
 hdr.val6_hdr.setInvalid();
 hdr.val7_hdr.setInvalid();
 hdr.val8_hdr.setInvalid();
 hdr.val9_hdr.setInvalid();
 hdr.val10_hdr.setInvalid();
 hdr.val11_hdr.setInvalid();
 hdr.val12_hdr.setInvalid();
 hdr.val13_hdr.setInvalid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val2() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setInvalid();
 hdr.val4_hdr.setInvalid();
 hdr.val5_hdr.setInvalid();
 hdr.val6_hdr.setInvalid();
 hdr.val7_hdr.setInvalid();
 hdr.val8_hdr.setInvalid();
 hdr.val9_hdr.setInvalid();
 hdr.val10_hdr.setInvalid();
 hdr.val11_hdr.setInvalid();
 hdr.val12_hdr.setInvalid();
 hdr.val13_hdr.setInvalid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val3() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setValid();
 hdr.val4_hdr.setInvalid();
 hdr.val5_hdr.setInvalid();
 hdr.val6_hdr.setInvalid();
 hdr.val7_hdr.setInvalid();
 hdr.val8_hdr.setInvalid();
 hdr.val9_hdr.setInvalid();
 hdr.val10_hdr.setInvalid();
 hdr.val11_hdr.setInvalid();
 hdr.val12_hdr.setInvalid();
 hdr.val13_hdr.setInvalid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val4() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setValid();
 hdr.val4_hdr.setValid();
 hdr.val5_hdr.setInvalid();
 hdr.val6_hdr.setInvalid();
 hdr.val7_hdr.setInvalid();
 hdr.val8_hdr.setInvalid();
 hdr.val9_hdr.setInvalid();
 hdr.val10_hdr.setInvalid();
 hdr.val11_hdr.setInvalid();
 hdr.val12_hdr.setInvalid();
 hdr.val13_hdr.setInvalid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val5() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setValid();
 hdr.val4_hdr.setValid();
 hdr.val5_hdr.setValid();
 hdr.val6_hdr.setInvalid();
 hdr.val7_hdr.setInvalid();
 hdr.val8_hdr.setInvalid();
 hdr.val9_hdr.setInvalid();
 hdr.val10_hdr.setInvalid();
 hdr.val11_hdr.setInvalid();
 hdr.val12_hdr.setInvalid();
 hdr.val13_hdr.setInvalid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val6() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setValid();
 hdr.val4_hdr.setValid();
 hdr.val5_hdr.setValid();
 hdr.val6_hdr.setValid();
 hdr.val7_hdr.setInvalid();
 hdr.val8_hdr.setInvalid();
 hdr.val9_hdr.setInvalid();
 hdr.val10_hdr.setInvalid();
 hdr.val11_hdr.setInvalid();
 hdr.val12_hdr.setInvalid();
 hdr.val13_hdr.setInvalid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val7() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setValid();
 hdr.val4_hdr.setValid();
 hdr.val5_hdr.setValid();
 hdr.val6_hdr.setValid();
 hdr.val7_hdr.setValid();
 hdr.val8_hdr.setInvalid();
 hdr.val9_hdr.setInvalid();
 hdr.val10_hdr.setInvalid();
 hdr.val11_hdr.setInvalid();
 hdr.val12_hdr.setInvalid();
 hdr.val13_hdr.setInvalid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val8() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setValid();
 hdr.val4_hdr.setValid();
 hdr.val5_hdr.setValid();
 hdr.val6_hdr.setValid();
 hdr.val7_hdr.setValid();
 hdr.val8_hdr.setValid();
 hdr.val9_hdr.setInvalid();
 hdr.val10_hdr.setInvalid();
 hdr.val11_hdr.setInvalid();
 hdr.val12_hdr.setInvalid();
 hdr.val13_hdr.setInvalid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val9() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setValid();
 hdr.val4_hdr.setValid();
 hdr.val5_hdr.setValid();
 hdr.val6_hdr.setValid();
 hdr.val7_hdr.setValid();
 hdr.val8_hdr.setValid();
 hdr.val9_hdr.setValid();
 hdr.val10_hdr.setInvalid();
 hdr.val11_hdr.setInvalid();
 hdr.val12_hdr.setInvalid();
 hdr.val13_hdr.setInvalid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val10() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setValid();
 hdr.val4_hdr.setValid();
 hdr.val5_hdr.setValid();
 hdr.val6_hdr.setValid();
 hdr.val7_hdr.setValid();
 hdr.val8_hdr.setValid();
 hdr.val9_hdr.setValid();
 hdr.val10_hdr.setValid();
 hdr.val11_hdr.setInvalid();
 hdr.val12_hdr.setInvalid();
 hdr.val13_hdr.setInvalid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val11() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setValid();
 hdr.val4_hdr.setValid();
 hdr.val5_hdr.setValid();
 hdr.val6_hdr.setValid();
 hdr.val7_hdr.setValid();
 hdr.val8_hdr.setValid();
 hdr.val9_hdr.setValid();
 hdr.val10_hdr.setValid();
 hdr.val11_hdr.setValid();
 hdr.val12_hdr.setInvalid();
 hdr.val13_hdr.setInvalid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val12() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setValid();
 hdr.val4_hdr.setValid();
 hdr.val5_hdr.setValid();
 hdr.val6_hdr.setValid();
 hdr.val7_hdr.setValid();
 hdr.val8_hdr.setValid();
 hdr.val9_hdr.setValid();
 hdr.val10_hdr.setValid();
 hdr.val11_hdr.setValid();
 hdr.val12_hdr.setValid();
 hdr.val13_hdr.setInvalid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val13() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setValid();
 hdr.val4_hdr.setValid();
 hdr.val5_hdr.setValid();
 hdr.val6_hdr.setValid();
 hdr.val7_hdr.setValid();
 hdr.val8_hdr.setValid();
 hdr.val9_hdr.setValid();
 hdr.val10_hdr.setValid();
 hdr.val11_hdr.setValid();
 hdr.val12_hdr.setValid();
 hdr.val13_hdr.setValid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val14() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setValid();
 hdr.val4_hdr.setValid();
 hdr.val5_hdr.setValid();
 hdr.val6_hdr.setValid();
 hdr.val7_hdr.setValid();
 hdr.val8_hdr.setValid();
 hdr.val9_hdr.setValid();
 hdr.val10_hdr.setValid();
 hdr.val11_hdr.setValid();
 hdr.val12_hdr.setValid();
 hdr.val13_hdr.setValid();
 hdr.val14_hdr.setValid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val15() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setValid();
 hdr.val4_hdr.setValid();
 hdr.val5_hdr.setValid();
 hdr.val6_hdr.setValid();
 hdr.val7_hdr.setValid();
 hdr.val8_hdr.setValid();
 hdr.val9_hdr.setValid();
 hdr.val10_hdr.setValid();
 hdr.val11_hdr.setValid();
 hdr.val12_hdr.setValid();
 hdr.val13_hdr.setValid();
 hdr.val14_hdr.setValid();
 hdr.val15_hdr.setValid();
 hdr.val16_hdr.setInvalid();
}

action add_to_val16() {
 hdr.vallen_hdr.setValid();
 hdr.val1_hdr.setValid();
 hdr.val2_hdr.setValid();
 hdr.val3_hdr.setValid();
 hdr.val4_hdr.setValid();
 hdr.val5_hdr.setValid();
 hdr.val6_hdr.setValid();
 hdr.val7_hdr.setValid();
 hdr.val8_hdr.setValid();
 hdr.val9_hdr.setValid();
 hdr.val10_hdr.setValid();
 hdr.val11_hdr.setValid();
 hdr.val12_hdr.setValid();
 hdr.val13_hdr.setValid();
 hdr.val14_hdr.setValid();
 hdr.val15_hdr.setValid();
 hdr.val16_hdr.setValid();
}

action remove_all() {
 hdr.vallen_hdr.setInvalid();
 hdr.val1_hdr.setInvalid();
 hdr.val2_hdr.setInvalid();
 hdr.val3_hdr.setInvalid();
 hdr.val4_hdr.setInvalid();
 hdr.val5_hdr.setInvalid();
 hdr.val6_hdr.setInvalid();
 hdr.val7_hdr.setInvalid();
 hdr.val8_hdr.setInvalid();
 hdr.val9_hdr.setInvalid();
 hdr.val10_hdr.setInvalid();
 hdr.val11_hdr.setInvalid();
 hdr.val12_hdr.setInvalid();
 hdr.val13_hdr.setInvalid();
 hdr.val14_hdr.setInvalid();
 hdr.val15_hdr.setInvalid();
 hdr.val16_hdr.setInvalid();
}

@pragma stage 11
table add_and_remove_value_header_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.vallen_hdr.vallen: range;
 }
 actions = {
  add_only_vallen;
  add_to_val1;
  add_to_val2;
  add_to_val3;
  add_to_val4;
  add_to_val5;
  add_to_val6;
  add_to_val7;
  add_to_val8;
  add_to_val9;
  add_to_val10;
  add_to_val11;
  add_to_val12;
  add_to_val13;
  add_to_val14;
  add_to_val15;
  add_to_val16;
  remove_all;
 }
 default_action = remove_all();
 size = 512;
}

action drop_getres_latest_seq_inswitch() {
 // NOTE: MATs after drop will not be accessed
 mark_to_drop(standard_metadata);
}

action drop_getres_deleted_seq_inswitch() {
 mark_to_drop(standard_metadata);
}

@pragma stage 11
table drop_tbl {
 key = {
  hdr.op_hdr.optype: exact;
 }
 actions = {
  drop_getres_latest_seq_inswitch;
  drop_getres_deleted_seq_inswitch;
  NoAction;
 }
 default_action = NoAction();
 size = 2;
}
# 5 "/root/P4/farreach-private/farreach/bmv2/p4src/egress.p4" 2
    // registers and MATs
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/regs/cm.p4" 1
bit<16> cm1_res;
bit<16> cm2_res;
bit<16> cm3_res;
bit<16> cm4_res;

register<bit<16>>(65536) cm1_reg;

action update_cm1() {
 // update_cm1_alu.execute_stateful_alu(hdr.inswitch_hdr.hashval_for_cm1);
 cm1_reg.read(cm1_res,(bit<32>)hdr.inswitch_hdr.hashval_for_cm1);
 meta.meta.cm1_predicate = 1;
 if(cm1_res >= hdr.inswitch_hdr.hot_threshold){
  meta.meta.cm1_predicate = 2;
 }
 cm1_reg.write((bit<32>)hdr.inswitch_hdr.hashval_for_cm1,cm1_res+1);
}

action initialize_cm1_predicate() {
 meta.meta.cm1_predicate = 1; // default: false (1)
}

@pragma stage 0
table access_cm1_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.inswitch_hdr.is_sampled: exact;
  hdr.inswitch_hdr.is_cached: exact;
 }
 actions = {
  update_cm1;
  initialize_cm1_predicate;
 }
 default_action = initialize_cm1_predicate();
 size = 2;
}

register<bit<16>>(65536) cm2_reg;

action update_cm2() {

 cm2_reg.read(cm2_res,(bit<32>)hdr.inswitch_hdr.hashval_for_cm2);
 meta.meta.cm2_predicate = 1;
 if(cm2_res >= hdr.inswitch_hdr.hot_threshold){
  meta.meta.cm2_predicate = 2;
 }
 cm2_reg.write((bit<32>)hdr.inswitch_hdr.hashval_for_cm2,cm2_res+1);
}

action initialize_cm2_predicate() {
 meta.meta.cm2_predicate = 1; // default: false (1)
}

@pragma stage 0
table access_cm2_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.inswitch_hdr.is_sampled: exact;
  hdr.inswitch_hdr.is_cached: exact;
 }
 actions = {
  update_cm2;
  initialize_cm2_predicate;
 }
 default_action = initialize_cm2_predicate();
 size = 2;
}

register<bit<16>>(65536) cm3_reg;

action update_cm3() {
 cm3_reg.read(cm3_res,(bit<32>)hdr.inswitch_hdr.hashval_for_cm3);
 meta.meta.cm3_predicate = 1;
 if(cm3_res >= hdr.inswitch_hdr.hot_threshold){
  meta.meta.cm3_predicate = 2;
 }
 cm3_reg.write((bit<32>)hdr.inswitch_hdr.hashval_for_cm3,cm3_res+1);
}


action initialize_cm3_predicate() {
 meta.meta.cm3_predicate = 1; // default: false (1)
}

@pragma stage 0
table access_cm3_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.inswitch_hdr.is_sampled: exact;
  hdr.inswitch_hdr.is_cached: exact;
 }
 actions = {
  update_cm3;
  initialize_cm3_predicate;
 }
 default_action = initialize_cm3_predicate();
 size = 2;
}

register<bit<16>>(65536) cm4_reg;

action update_cm4() {
 cm4_reg.read(cm4_res,(bit<32>)hdr.inswitch_hdr.hashval_for_cm4);
 meta.meta.cm4_predicate = 1;
 if(cm4_res >= hdr.inswitch_hdr.hot_threshold){
  meta.meta.cm4_predicate = 2;
 }
 cm4_reg.write((bit<32>)hdr.inswitch_hdr.hashval_for_cm4,cm4_res+1);
}

action initialize_cm4_predicate() {
 meta.meta.cm4_predicate = 1; // default: false (1)
}

@pragma stage 0
table access_cm4_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.inswitch_hdr.is_sampled: exact;
  hdr.inswitch_hdr.is_cached: exact;
 }
 actions = {
  update_cm4;
  initialize_cm4_predicate;
 }
 default_action = initialize_cm4_predicate();
 size = 2;
}
# 7 "/root/P4/farreach-private/farreach/bmv2/p4src/egress.p4" 2
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/regs/cache_frequency.p4" 1
register<bit<32>>(32768) cache_frequency_reg;
bit<32> cache_frequency_res;

action get_cache_frequency() {
 // get_cache_frequency_alu.execute_stateful_alu(hdr.inswitch_hdr.idx);
 cache_frequency_reg.read(hdr.frequency_hdr.frequency,(bit<32>)hdr.inswitch_hdr.idx);
}

action update_cache_frequency() {
 cache_frequency_reg.read(cache_frequency_res,(bit<32>)hdr.inswitch_hdr.idx);
 cache_frequency_reg.write((bit<32>)hdr.inswitch_hdr.idx,cache_frequency_res+1);
}

action reset_cache_frequency() {
 // reset_cache_frequency_alu.execute_stateful_alu(hdr.inswitch_hdr.idx);
 cache_frequency_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}
@pragma stage 1
table access_cache_frequency_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.inswitch_hdr.is_sampled: exact;
  hdr.inswitch_hdr.is_cached: exact;
 }
 actions = {
  get_cache_frequency;
  update_cache_frequency;
  reset_cache_frequency;
  NoAction;
 }
 default_action = NoAction();
 size = 16;
}
# 8 "/root/P4/farreach-private/farreach/bmv2/p4src/egress.p4" 2
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/regs/validvalue.p4" 1
register<bit<8>>(32768) validvalue_reg;
bit<32> validvalue_res;

action get_validvalue() {
 validvalue_reg.read(hdr.validvalue_hdr.validvalue,(bit<32>)hdr.inswitch_hdr.idx);
}

action set_validvalue() {
 validvalue_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.validvalue_hdr.validvalue);
}
action reset_meta_validvalue() {
 hdr.validvalue_hdr.validvalue = 0;
}

@pragma stage 1
table access_validvalue_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.inswitch_hdr.is_cached: exact;
 }
 actions = {
  get_validvalue;
  set_validvalue;
  reset_meta_validvalue; // not touch validvalue_reg
 }
 default_action = reset_meta_validvalue();
 size = 8;
}
# 9 "/root/P4/farreach-private/farreach/bmv2/p4src/egress.p4" 2
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/regs/latest.p4" 1
register<bit<1>>(32768) latest_reg;

action get_latest() {
 // get_latest_alu.execute_stateful_alu(hdr.inswitch_hdr.idx);
 latest_reg.read(meta.meta.is_latest,(bit<32>)hdr.inswitch_hdr.idx);
}

action set_and_get_latest() {
 // set_and_get_latest_alu.execute_stateful_alu(hdr.inswitch_hdr.idx);
 latest_reg.write((bit<32>)hdr.inswitch_hdr.idx,1);
 meta.meta.is_latest=1;
}


// CACHE_POP_INSWITCH 
action reset_and_get_latest() {
 // reset_and_get_latest_alu.execute_stateful_alu(hdr.inswitch_hdr.idx);
 latest_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
 meta.meta.is_latest=0;
}

action reset_is_latest() {
 meta.meta.is_latest = 0;
}

@pragma stage 2
table access_latest_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.inswitch_hdr.is_cached: exact;
  hdr.validvalue_hdr.validvalue: exact;
  hdr.fraginfo_hdr.cur_fragidx: exact;
 }
 actions = {
  get_latest;
  set_and_get_latest;
  reset_and_get_latest;
  reset_is_latest; // not touch latest_reg
 }
 default_action = reset_is_latest();
 size = 32;
}
# 10 "/root/P4/farreach-private/farreach/bmv2/p4src/egress.p4" 2
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/regs/deleted.p4" 1
register<bit<1>>(32768) deleted_reg;

action get_deleted() {
 // get_deleted_alu.execute_stateful_alu(hdr.inswitch_hdr.idx);
 deleted_reg.read(meta.meta.is_deleted,(bit<32>)hdr.inswitch_hdr.idx);
}


action set_and_get_deleted() {
 // set_and_get_deleted_alu.execute_stateful_alu(hdr.inswitch_hdr.idx);
 deleted_reg.write((bit<32>)hdr.inswitch_hdr.idx,1);
 meta.meta.is_deleted=1;
}


action reset_and_get_deleted() {
 // reset_and_get_deleted_alu.execute_stateful_alu(hdr.inswitch_hdr.idx);
 deleted_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
 meta.meta.is_deleted = 0;
}

action reset_is_deleted() {
 meta.meta.is_deleted = 0;
}

@pragma stage 3
table access_deleted_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.inswitch_hdr.is_cached: exact;
  hdr.validvalue_hdr.validvalue: exact;
  meta.meta.is_latest: exact;
  hdr.stat_hdr.stat: exact;
 }
 actions = {
  get_deleted;
  set_and_get_deleted;
  reset_and_get_deleted;
  reset_is_deleted;
 }
 default_action = reset_is_deleted();
 size = 256;
}
# 11 "/root/P4/farreach-private/farreach/bmv2/p4src/egress.p4" 2
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/regs/seq.p4" 1
register<bit<32>>(32768) seq_reg;
bit<32> seq_res;
action assign_seq() {
 // assign_seq_alu.execute_stateful_alu(hdr.inswitch_hdr.hashval_for_seq);
 seq_reg.read(seq_res,(bit<32>)hdr.inswitch_hdr.hashval_for_seq);
 if(seq_res == 0x7FFFFFFF){
  hdr.seq_hdr.seq=0;
  seq_res =0;
 }
 else{
  hdr.seq_hdr.seq=seq_res+1;
  seq_res= seq_res+1;
 }
 seq_reg.write((bit<32>)hdr.inswitch_hdr.hashval_for_seq,seq_res);
}

@pragma stage 1
table access_seq_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.fraginfo_hdr.cur_fragidx: exact;
 }
 actions = {
  assign_seq;
  NoAction;
 }
 default_action = NoAction();



 size = 4;

}

register<bit<32>>(32768) savedseq_reg;

action get_savedseq() {
 // get_savedseq_alu.execute_stateful_alu(hdr.inswitch_hdr.idx);
 savedseq_reg.read(hdr.seq_hdr.seq,(bit<32>)hdr.inswitch_hdr.idx);
}

action set_and_get_savedseq() {
 // set_and_get_savedseq_alu.execute_stateful_alu(hdr.inswitch_hdr.idx);
 savedseq_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.seq_hdr.seq);
}
@pragma stage 3
table access_savedseq_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.inswitch_hdr.is_cached: exact;
  hdr.validvalue_hdr.validvalue: exact;
  meta.meta.is_latest: exact;
 }
 actions = {
  get_savedseq;
  set_and_get_savedseq;
  NoAction;
 }
 default_action = NoAction();
 size = 64;
}
# 12 "/root/P4/farreach-private/farreach/bmv2/p4src/egress.p4" 2
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/regs/val.p4" 1
// NOTE: we do not match optype for val_reg (especialy for val16_reg), as eg_port_forward_tbl may change optype before accessing val16_reg
// NOTE: we also place drop() in the last stage to avoid skipping val16_reg due to immediate drop semantic

register<bit<16>>(32768) vallen_reg;

action get_vallen() {
 // get_vallen_alu.execute_stateful_alu(hdr.inswitch_hdr.idx);
 vallen_reg.read(hdr.vallen_hdr.vallen,(bit<32>)hdr.inswitch_hdr.idx);
 meta.meta.access_val_mode = 1; // get val_reg
}

action set_and_get_vallen() {
 // set_and_get_vallen_alu.execute_stateful_alu(hdr.inswitch_hdr.idx);
 vallen_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.vallen_hdr.vallen);
 meta.meta.access_val_mode = 2; // set_and_get val_reg
}

action reset_and_get_vallen() {
 // reset_and_get_vallen_alu.execute_stateful_alu(hdr.inswitch_hdr.idx);
 vallen_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
 hdr.vallen_hdr.vallen=0;
 meta.meta.access_val_mode = 3; // reset_and_get val_reg
}

action reset_access_val_mode() {
 meta.meta.access_val_mode = 0; // not access val_reg
}

@pragma stage 3
table update_vallen_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.inswitch_hdr.is_cached: exact;
  hdr.validvalue_hdr.validvalue: exact;
  meta.meta.is_latest: exact;
 }
 actions = {
  get_vallen;
  set_and_get_vallen;
  reset_and_get_vallen;
  reset_access_val_mode;
  NoAction;
 }
 default_action = reset_access_val_mode();
 size = 64;
}
register<bit<32>>(32768) vallo1_reg;

action get_vallo1() {
 vallo1_reg.read(hdr.val1_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}

action set_and_get_vallo1() {
 vallo1_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val1_hdr.vallo);
}

action reset_and_get_vallo1() {
 hdr.val1_hdr.vallo=0;
 vallo1_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 4
table update_vallo1_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo1;
  set_and_get_vallo1;
  reset_and_get_vallo1;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi1_reg;

action get_valhi1() {
 valhi1_reg.read(hdr.val1_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi1() {
 valhi1_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val1_hdr.valhi);
}
action reset_and_get_valhi1() {
 hdr.val1_hdr.valhi=0;
 valhi1_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 4
table update_valhi1_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi1;
  set_and_get_valhi1;
  reset_and_get_valhi1;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo2_reg;

action get_vallo2() {
 vallo2_reg.read(hdr.val2_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo2() {
 vallo2_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val2_hdr.vallo);
}
action reset_and_get_vallo2() {
 hdr.val2_hdr.vallo=0;
 vallo2_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 4
table update_vallo2_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo2;
  set_and_get_vallo2;
  reset_and_get_vallo2;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi2_reg;

action get_valhi2() {
 valhi2_reg.read(hdr.val2_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi2() {
 valhi2_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val2_hdr.valhi);
}
action reset_and_get_valhi2() {
 hdr.val2_hdr.valhi=0;
 valhi2_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}


@pragma stage 4
table update_valhi2_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi2;
  set_and_get_valhi2;
  reset_and_get_valhi2;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo3_reg;

action get_vallo3() {
 vallo3_reg.read(hdr.val3_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo3() {
 vallo3_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val3_hdr.vallo);
}
action reset_and_get_vallo3() {
 hdr.val3_hdr.vallo=0;
 vallo3_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 5
table update_vallo3_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo3;
  set_and_get_vallo3;
  reset_and_get_vallo3;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi3_reg;

action get_valhi3() {
 valhi3_reg.read(hdr.val3_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi3() {
 valhi3_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val3_hdr.valhi);
}
action reset_and_get_valhi3() {
 hdr.val3_hdr.valhi=0;
 valhi3_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}


@pragma stage 5
table update_valhi3_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi3;
  set_and_get_valhi3;
  reset_and_get_valhi3;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo4_reg;

action get_vallo4() {
 vallo4_reg.read(hdr.val4_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo4() {
 vallo4_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val4_hdr.vallo);
}
action reset_and_get_vallo4() {
 hdr.val4_hdr.vallo=0;
 vallo4_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}


@pragma stage 5
table update_vallo4_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo4;
  set_and_get_vallo4;
  reset_and_get_vallo4;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi4_reg;

action get_valhi4() {
 valhi4_reg.read(hdr.val4_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi4() {
 valhi4_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val4_hdr.valhi);
}
action reset_and_get_valhi4() {
 hdr.val4_hdr.valhi=0;
 valhi4_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}


@pragma stage 5
table update_valhi4_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi4;
  set_and_get_valhi4;
  reset_and_get_valhi4;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo5_reg;

action get_vallo5() {
 vallo5_reg.read(hdr.val5_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo5() {
 vallo5_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val5_hdr.vallo);
}
action reset_and_get_vallo5() {
 hdr.val5_hdr.vallo=0;
 vallo5_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}
@pragma stage 6
table update_vallo5_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo5;
  set_and_get_vallo5;
  reset_and_get_vallo5;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi5_reg;

action get_valhi5() {
 valhi5_reg.read(hdr.val5_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi5() {
 valhi5_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val5_hdr.valhi);
}
action reset_and_get_valhi5() {
 hdr.val5_hdr.valhi=0;
 valhi5_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}
@pragma stage 6
table update_valhi5_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi5;
  set_and_get_valhi5;
  reset_and_get_valhi5;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo6_reg;

action get_vallo6() {
 vallo6_reg.read(hdr.val6_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo6() {
 vallo6_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val6_hdr.vallo);
}
action reset_and_get_vallo6() {
 hdr.val6_hdr.vallo=0;
 vallo6_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}
@pragma stage 6
table update_vallo6_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo6;
  set_and_get_vallo6;
  reset_and_get_vallo6;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi6_reg;

action get_valhi6() {
 valhi6_reg.read(hdr.val6_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi6() {
 valhi6_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val6_hdr.valhi);
}
action reset_and_get_valhi6() {
 hdr.val6_hdr.valhi=0;
 valhi6_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 6
table update_valhi6_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi6;
  set_and_get_valhi6;
  reset_and_get_valhi6;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo7_reg;

action get_vallo7() {
 vallo7_reg.read(hdr.val7_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo7() {
 vallo7_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val7_hdr.vallo);
}
action reset_and_get_vallo7() {
 hdr.val7_hdr.vallo=0;
 vallo7_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}



@pragma stage 7
table update_vallo7_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo7;
  set_and_get_vallo7;
  reset_and_get_vallo7;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi7_reg;

action get_valhi7() {
 valhi7_reg.read(hdr.val7_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi7() {
 valhi7_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val7_hdr.valhi);
}
action reset_and_get_valhi7() {
 hdr.val7_hdr.valhi=0;
 valhi7_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}



@pragma stage 7
table update_valhi7_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi7;
  set_and_get_valhi7;
  reset_and_get_valhi7;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo8_reg;

action get_vallo8() {
 vallo8_reg.read(hdr.val8_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo8() {
 vallo8_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val8_hdr.vallo);
}
action reset_and_get_vallo8() {
 hdr.val8_hdr.vallo=0;
 vallo8_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}


@pragma stage 7
table update_vallo8_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo8;
  set_and_get_vallo8;
  reset_and_get_vallo8;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi8_reg;

action get_valhi8() {
 valhi8_reg.read(hdr.val8_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi8() {
 valhi8_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val8_hdr.valhi);
}
action reset_and_get_valhi8() {
 hdr.val8_hdr.valhi=0;
 valhi8_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}


@pragma stage 7
table update_valhi8_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi8;
  set_and_get_valhi8;
  reset_and_get_valhi8;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo9_reg;

action get_vallo9() {
 vallo9_reg.read(hdr.val9_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo9() {
 vallo9_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val9_hdr.vallo);
}
action reset_and_get_vallo9() {
 hdr.val9_hdr.vallo=0;
 vallo9_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 8
table update_vallo9_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo9;
  set_and_get_vallo9;
  reset_and_get_vallo9;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi9_reg;

action get_valhi9() {
 valhi9_reg.read(hdr.val9_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi9() {
 valhi9_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val9_hdr.valhi);
}
action reset_and_get_valhi9() {
 hdr.val9_hdr.valhi=0;
 valhi9_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 8
table update_valhi9_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi9;
  set_and_get_valhi9;
  reset_and_get_valhi9;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo10_reg;

action get_vallo10() {
 vallo10_reg.read(hdr.val10_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo10() {
 vallo10_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val10_hdr.vallo);
}
action reset_and_get_vallo10() {
 hdr.val10_hdr.vallo=0;
 vallo10_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}


@pragma stage 8
table update_vallo10_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo10;
  set_and_get_vallo10;
  reset_and_get_vallo10;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi10_reg;

action get_valhi10() {
 valhi10_reg.read(hdr.val10_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi10() {
 valhi10_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val10_hdr.valhi);
}
action reset_and_get_valhi10() {
 hdr.val10_hdr.valhi=0;
 valhi10_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 8
table update_valhi10_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi10;
  set_and_get_valhi10;
  reset_and_get_valhi10;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo11_reg;

action get_vallo11() {
 vallo11_reg.read(hdr.val11_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo11() {
 vallo11_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val11_hdr.vallo);
}
action reset_and_get_vallo11() {
 hdr.val11_hdr.vallo=0;
 vallo11_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 9
table update_vallo11_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo11;
  set_and_get_vallo11;
  reset_and_get_vallo11;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi11_reg;

action get_valhi11() {
 valhi11_reg.read(hdr.val11_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi11() {
 valhi11_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val11_hdr.valhi);
}
action reset_and_get_valhi11() {
 hdr.val11_hdr.valhi=0;
 valhi11_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}


@pragma stage 9
table update_valhi11_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi11;
  set_and_get_valhi11;
  reset_and_get_valhi11;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo12_reg;

action get_vallo12() {
 vallo12_reg.read(hdr.val12_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo12() {
 vallo12_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val12_hdr.vallo);
}
action reset_and_get_vallo12() {
 hdr.val12_hdr.vallo=0;
 vallo12_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}



@pragma stage 9
table update_vallo12_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo12;
  set_and_get_vallo12;
  reset_and_get_vallo12;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi12_reg;

action get_valhi12() {
 valhi12_reg.read(hdr.val12_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi12() {
 valhi12_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val12_hdr.valhi);
}
action reset_and_get_valhi12() {
 hdr.val12_hdr.valhi=0;
 valhi12_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 9
table update_valhi12_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi12;
  set_and_get_valhi12;
  reset_and_get_valhi12;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo13_reg;

action get_vallo13() {
 vallo13_reg.read(hdr.val13_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo13() {
 vallo13_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val13_hdr.vallo);
}
action reset_and_get_vallo13() {
 hdr.val13_hdr.vallo=0;
 vallo13_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 10
table update_vallo13_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo13;
  set_and_get_vallo13;
  reset_and_get_vallo13;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi13_reg;

action get_valhi13() {
 valhi13_reg.read(hdr.val13_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi13() {
 valhi13_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val13_hdr.valhi);
}
action reset_and_get_valhi13() {
 hdr.val13_hdr.valhi=0;
 valhi13_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}@pragma stage 10
table update_valhi13_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi13;
  set_and_get_valhi13;
  reset_and_get_valhi13;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo14_reg;

action get_vallo14() {
 vallo14_reg.read(hdr.val14_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo14() {
 vallo14_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val14_hdr.vallo);
}
action reset_and_get_vallo14() {
 hdr.val14_hdr.vallo=0;
 vallo14_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 10
table update_vallo14_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo14;
  set_and_get_vallo14;
  reset_and_get_vallo14;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi14_reg;

action get_valhi14() {
 valhi14_reg.read(hdr.val14_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi14() {
 valhi14_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val14_hdr.valhi);
}
action reset_and_get_valhi14() {
 hdr.val14_hdr.valhi=0;
 valhi14_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}


@pragma stage 10
table update_valhi14_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi14;
  set_and_get_valhi14;
  reset_and_get_valhi14;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo15_reg;

action get_vallo15() {
 vallo15_reg.read(hdr.val15_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo15() {
 vallo15_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val15_hdr.vallo);
}
action reset_and_get_vallo15() {
 hdr.val15_hdr.vallo=0;
 vallo15_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 11
table update_vallo15_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo15;
  set_and_get_vallo15;
  reset_and_get_vallo15;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi15_reg;

action get_valhi15() {
 valhi15_reg.read(hdr.val15_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi15() {
 valhi15_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val15_hdr.valhi);
}
action reset_and_get_valhi15() {
 hdr.val15_hdr.valhi=0;
 valhi15_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}


@pragma stage 11
table update_valhi15_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi15;
  set_and_get_valhi15;
  reset_and_get_valhi15;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) vallo16_reg;

action get_vallo16() {
 vallo16_reg.read(hdr.val16_hdr.vallo,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_vallo16() {
 vallo16_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val16_hdr.vallo);
}
action reset_and_get_vallo16() {
 hdr.val16_hdr.vallo=0;
 vallo16_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 11
table update_vallo16_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_vallo16;
  set_and_get_vallo16;
  reset_and_get_vallo16;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}

register<bit<32>>(32768) valhi16_reg;

action get_valhi16() {
 valhi16_reg.read(hdr.val16_hdr.valhi,(bit<32>)hdr.inswitch_hdr.idx);
}
action set_and_get_valhi16() {
 valhi16_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.val16_hdr.valhi);
}
action reset_and_get_valhi16() {
 hdr.val16_hdr.valhi=0;
 valhi16_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
}

@pragma stage 11
table update_valhi16_tbl {
 key = {
  meta.meta.access_val_mode: exact;
 }
 actions = {
  get_valhi16;
  set_and_get_valhi16;
  reset_and_get_valhi16;
  NoAction;
 }
 default_action = NoAction();
 size = 32;
}
# 13 "/root/P4/farreach-private/farreach/bmv2/p4src/egress.p4" 2
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/regs/case1.p4" 1
register<bit<1>>(32768) case1_reg;

action read_case1() {
 case1_reg.read(meta.meta.is_case1,(bit<32>)hdr.inswitch_hdr.idx);
}

action try_case1() {
 latest_reg.write((bit<32>)hdr.inswitch_hdr.idx,1);
 meta.meta.is_case1=1;
}

action reset_is_case1() {
 meta.meta.is_case1 = 0;
}

@pragma stage 3
table access_case1_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.inswitch_hdr.is_cached: exact;
  hdr.validvalue_hdr.validvalue: exact;
  meta.meta.is_latest: exact;
  hdr.inswitch_hdr.snapshot_flag: exact;
 }
 actions = {
  try_case1; // touch case1_reg
  read_case1; // touch case1_reg
  reset_is_case1; // not touch case1_reg
 }
 default_action = reset_is_case1();
 size = 8;
}
# 14 "/root/P4/farreach-private/farreach/bmv2/p4src/egress.p4" 2

    //#ifdef ENABLE_LARGEVALUEBLOCK
# 1 "/root/P4/farreach-private/farreach/bmv2/p4src/regs/largevalueseq.p4" 1
register<bit<32>>(32768) largevalueseq_reg;

action get_largevalueseq() {
 largevalueseq_reg.read(meta.meta.largevalueseq,(bit<32>)hdr.inswitch_hdr.idx);
}

action set_largevalueseq() {
 largevalueseq_reg.write((bit<32>)hdr.inswitch_hdr.idx,hdr.seq_hdr.seq);
 meta.meta.largevalueseq = 0;
 meta.meta.is_largevalueblock = 0;
}

// CACHE_POP_INSWITCH 
action reset_largevalueseq() {
 largevalueseq_reg.write((bit<32>)hdr.inswitch_hdr.idx,0);
 meta.meta.largevalueseq = 0;
 meta.meta.is_largevalueblock = 0;
 hdr.clone_hdr.assignedseq_for_farreach = hdr.seq_hdr.seq;
}

action reset_meta_largevalueseq() {
 meta.meta.largevalueseq = 0;
 meta.meta.is_largevalueblock = 0;
}

@pragma stage 2
table access_largevalueseq_and_save_assignedseq_tbl {
 key = {
  hdr.op_hdr.optype: exact;
  hdr.inswitch_hdr.is_cached: exact;
  hdr.validvalue_hdr.validvalue: exact;
  hdr.fraginfo_hdr.cur_fragidx: exact;
 }
 actions = {
  get_largevalueseq;
  set_largevalueseq;
  reset_largevalueseq; // PUT/DELREQ_INSWITCH will invoke resset_largevalueseq() and save the assignedseq into clone_hdr
  reset_meta_largevalueseq; // not touch largevalueseq_reg
 }
 default_action = reset_meta_largevalueseq();
 size = 32;
}
# 17 "/root/P4/farreach-private/farreach/bmv2/p4src/egress.p4" 2
    //#endif
     /* Egress Processing */

    apply {

        // Stage 0
        //eg_copy_udplen_for_checksum_tbl.apply();
        access_cm1_tbl.apply();
        access_cm2_tbl.apply();
        access_cm3_tbl.apply();
        access_cm4_tbl.apply();

        // Stage 1
        is_hot_tbl.apply();
        access_cache_frequency_tbl.apply();
        access_validvalue_tbl.apply();
        access_seq_tbl.apply();

        // Stage 2
        access_latest_tbl.apply();
    //#ifdef ENABLE_LARGEVALUEBLOCK
        // save seq_hdr.seq into clone_hdr.assignedseq_for_farreach for PUT/DELREQ_INSWITCH, which is used by cache hit response of PUT/DELREQ_INSWITCH and PUT/DELREQ_SEQ_INSWITCH_CASE1 -> [IMPORTANT] must be placed between access_seq_tbl and access_savedseq_tbl
        access_largevalueseq_and_save_assignedseq_tbl.apply(); // used for invalidation of PUTREQ_LARGEVALUE
    //#endif
        // save udp.dstport (client port) for GET/PUT/DELREQ_INSWITCH, which is used by cache hit response of GET/PUT/DELREQ_INSWITCH and PUTREQ/DELREQ_SEQ_INSWITCH_CASE1
        save_client_udpport_tbl.apply();

        // NOTE: we do NOT need seq and savedseq now if using serverstatus
        // CACHEPOP_INSWITCH always sets it as 1, while PUT/DELREQ set it as 0 if cached=1 and valid=1
        // LOADDATA_INSWITCH always read it, while GETREQ key = it if cached=1 and valid=3
        // Only if cached=1, valid=3, and serverstatus=0, GETREQ will try to trigger read blocking
        // TODO: serverstatus_tbl.apply();

        // Stage 3
    //#ifdef ENABLE_LARGEVALUEBLOCK
        if (meta.meta.largevalueseq != 0) {
            is_largevalueblock_tbl.apply(); // used for invalidation of PUTREQ_LARGEVALUE
        }
    //#endif
        access_deleted_tbl.apply();
        update_vallen_tbl.apply();
        access_savedseq_tbl.apply();
        access_case1_tbl.apply();

        // Stage 4-6
        // NOTE: value registers do not reply on op_hdr.optype, they only rely on meta.meta.access_val_mode, which is set by update_vallen_tbl in stage 3
        update_vallo1_tbl.apply();
        update_valhi1_tbl.apply();
        update_vallo2_tbl.apply();
        update_valhi2_tbl.apply();
        update_vallo3_tbl.apply();
        update_valhi3_tbl.apply();
        update_vallo4_tbl.apply();
        update_valhi4_tbl.apply();
        update_vallo5_tbl.apply();
        update_valhi5_tbl.apply();
        update_vallo6_tbl.apply();
        update_valhi6_tbl.apply();

        // Stage 7
        lastclone_lastscansplit_tbl.apply(); // including is_last_scansplit
        update_vallo7_tbl.apply();
        update_valhi7_tbl.apply();
        update_vallo8_tbl.apply();
        update_valhi8_tbl.apply();

        // Stage 8
        // NOTE: we must guarantee that the output optype of another_eg_port_forward_tbl will NOT be matched in eg_port_forward_tbl
        another_eg_port_forward_tbl.apply(); // used to reduce VLIW usage of eg_port_forward_tbl
        update_vallo9_tbl.apply();
        update_valhi9_tbl.apply();
        update_vallo10_tbl.apply();
        update_valhi10_tbl.apply();

        // Stage 9
        eg_port_forward_tbl.apply(); // including scan forwarding
        // NOTE: Comment val11 and val12 in debug mode to save resources for eg_port_forward_counter -> you need to disable debug mode in evaluation

        update_vallo11_tbl.apply();
        update_valhi11_tbl.apply();
        update_vallo12_tbl.apply();
        update_valhi12_tbl.apply();


        // stage 10
        // NOTE: resource in stage 11 is not enough for update_ipmac_src_port_tbl, so we place it into stage 10
        update_ipmac_srcport_tbl.apply(); // Update ip, mac, and srcport for RES to client and notification to switchos
        update_vallo13_tbl.apply();
        update_valhi13_tbl.apply();
        update_vallo14_tbl.apply();
        update_valhi14_tbl.apply();

        // Stage 11
        update_pktlen_tbl.apply(); // Update udl_hdr.en for pkt with variable-length value
        add_and_remove_value_header_tbl.apply(); // Add or remove vallen and val according to optype and vallen
        drop_tbl.apply(); // drop GETRES_LATEST_SEQ_INSWITCH and GETRES_DELETED_SEQ_INSWITCH
        update_vallo15_tbl.apply();
        update_valhi15_tbl.apply();
        update_vallo16_tbl.apply();
        update_valhi16_tbl.apply();
    }
}
# 16 "/root/P4/farreach-private/farreach/bmv2/netbufferv4.p4" 2
//blank checksum
control farreachVerifyChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}
control farreachComputeChecksum(inout headers hdr, inout metadata meta) {
    apply { }
}
//switch architecture
V1Switch(
farreachParser(),
farreachVerifyChecksum(),
farreachIngress(),
farreachEgress(),
farreachComputeChecksum(),
farreachDeparser()
) main;
