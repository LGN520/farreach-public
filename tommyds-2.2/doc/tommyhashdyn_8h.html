<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>TommyDS</title>
<link href="tabs.css" rel="stylesheet" type="text/css">
<link href="tommy.css" rel="stylesheet" type="text/css">
</head>
<body>

<!-- Generated by Doxygen 1.7.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>tommyds/tommyhashdyn.h File Reference</h1>  </div>
</div>
<div class="contents">

<p>Dynamic chained hashtable.  
<a href="#_details">More...</a></p>

<p><a href="tommyhashdyn_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn_struct</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashtable container type.  <a href="structtommy__hashdyn__struct.html#_details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structtommy__node__struct.html">tommy_node</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashdyn_8h.html#aae681213ad96845453f1533ffa555481">tommy_hashdyn_node</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashtable node.  <a href="#aae681213ad96845453f1533ffa555481"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn_struct</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashdyn_8h.html#a00c8b944d273f38f9eef91417a1e8991">tommy_hashdyn</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Hashtable container type.  <a href="#a00c8b944d273f38f9eef91417a1e8991"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashdyn_8h.html#a912bebbbb99e453f9c3230948f332d76">tommy_hashdyn_init</a> (<a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *hashdyn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the hashtable.  <a href="#a912bebbbb99e453f9c3230948f332d76"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashdyn_8h.html#acc92e6ad011a22aa645cb35d24df27a2">tommy_hashdyn_done</a> (<a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *hashdyn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Deinitializes the hashtable.  <a href="#acc92e6ad011a22aa645cb35d24df27a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashdyn_8h.html#adef3d60ad281f391ae1032f43f584dac">tommy_hashdyn_insert</a> (<a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *hashdyn, <a class="el" href="structtommy__node__struct.html">tommy_hashdyn_node</a> *node, void *data, <a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a> hash)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Inserts an element in the hashtable.  <a href="#adef3d60ad281f391ae1032f43f584dac"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashdyn_8h.html#a01457fa26338c432cfe9ba93da4ae2f4">tommy_hashdyn_remove</a> (<a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *hashdyn, <a class="el" href="tommytypes_8h.html#a9008971cd09a3f9c4f9da45cffb4627d">tommy_search_func</a> *cmp, const void *cmp_arg, <a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a> hash)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches and removes an element from the hashtable.  <a href="#a01457fa26338c432cfe9ba93da4ae2f4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structtommy__node__struct.html">tommy_hashdyn_node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashdyn_8h.html#a423346dea8ec61de351e84dc15a80468">tommy_hashdyn_bucket</a> (<a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *hashdyn, <a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a> hash)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the bucket of the specified hash.  <a href="#a423346dea8ec61de351e84dc15a80468"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashdyn_8h.html#a713b5dc93110677d6230d601909fd667">tommy_hashdyn_search</a> (<a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *hashdyn, <a class="el" href="tommytypes_8h.html#a9008971cd09a3f9c4f9da45cffb4627d">tommy_search_func</a> *cmp, const void *cmp_arg, <a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a> hash)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Searches an element in the hashtable.  <a href="#a713b5dc93110677d6230d601909fd667"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashdyn_8h.html#a0d9f4ca17314d1a0e8b7072b5fda25cc">tommy_hashdyn_remove_existing</a> (<a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *hashdyn, <a class="el" href="structtommy__node__struct.html">tommy_hashdyn_node</a> *node)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes an element from the hashtable.  <a href="#a0d9f4ca17314d1a0e8b7072b5fda25cc"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashdyn_8h.html#a010d0131e6e5ddd071dff7dadd181cfa">tommy_hashdyn_foreach</a> (<a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *hashdyn, <a class="el" href="tommytypes_8h.html#a8caf78c4fb7706a85093f99598d61b5d">tommy_foreach_func</a> *func)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the specified function for each element in the hashtable.  <a href="#a010d0131e6e5ddd071dff7dadd181cfa"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashdyn_8h.html#af1cf2aabf2d7acd3fd78f943384aac9c">tommy_hashdyn_foreach_arg</a> (<a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *hashdyn, <a class="el" href="tommytypes_8h.html#ae0aea577584dfbe750f078b3801d0ee6">tommy_foreach_arg_func</a> *func, void *arg)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the specified function with an argument for each element in the hashtable.  <a href="#af1cf2aabf2d7acd3fd78f943384aac9c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="tommytypes_8h.html#a802a296e9903e3bc098432b9bdad03ab">tommy_count_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashdyn_8h.html#a37b1f501d4d2ac31d262a2506f9f93a2">tommy_hashdyn_count</a> (<a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *hashdyn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the number of elements.  <a href="#a37b1f501d4d2ac31d262a2506f9f93a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="tommytypes_8h.html#a32aad870b975610a257f9c2d14b0825e">tommy_size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tommyhashdyn_8h.html#a3662ac977607f8192738aa9887d70d06">tommy_hashdyn_memory_usage</a> (<a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *hashdyn)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of allocated memory.  <a href="#a3662ac977607f8192738aa9887d70d06"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>Dynamic chained hashtable. </p>
<p>This hashtable resizes dynamically. It starts with the minimal size of 16 buckets, it doubles the size then it reaches a load factor greater than 0.5 and it halves the size with a load factor lower than 0.125.</p>
<p>All the elements are reallocated in a single resize operation done inside <a class="el" href="tommyhashdyn_8h.html#adef3d60ad281f391ae1032f43f584dac" title="Inserts an element in the hashtable.">tommy_hashdyn_insert()</a> or <a class="el" href="tommyhashdyn_8h.html#a01457fa26338c432cfe9ba93da4ae2f4" title="Searches and removes an element from the hashtable.">tommy_hashdyn_remove()</a>.</p>
<p>Note that the resize operation takes approximatively 100 [ms] with 1 million of elements, and 1 [second] with 10 millions. This could be a problem in real-time applications.</p>
<p>The resize also fragment the heap, as it involves allocating a double-sized table, copy elements, and deallocating the older table. Leaving a big hole in the heap.</p>
<p>The <a class="el" href="tommyhashlin_8h.html#ad910f88af8bcd013a8e3cd30d528b904" title="Hashtable container type.">tommy_hashlin</a> hashtable fixes both problems.</p>
<p>To initialize the hashtable you have to call <a class="el" href="tommyhashdyn_8h.html#a912bebbbb99e453f9c3230948f332d76" title="Initializes the hashtable.">tommy_hashdyn_init()</a>.</p>
<div class="fragment"><pre class="fragment"> tommy_hashslin hashdyn;

 <a class="code" href="tommyhashdyn_8h.html#a912bebbbb99e453f9c3230948f332d76" title="Initializes the hashtable.">tommy_hashdyn_init</a>(&amp;hashdyn);
</pre></div><p>To insert elements in the hashtable you have to call <a class="el" href="tommyhashdyn_8h.html#adef3d60ad281f391ae1032f43f584dac" title="Inserts an element in the hashtable.">tommy_hashdyn_insert()</a> for each element. In the insertion call you have to specify the address of the node, the address of the object, and the hash value of the key to use. The address of the object is used to initialize the <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer to the object containing the node.">tommy_node::data</a> field of the node, and the hash to initialize the <a class="el" href="structtommy__node__struct.html#a124aaecab9e5d3d1fbb9239dac779d23" title="Key used to store the node.">tommy_node::key</a> field.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>object {
     <span class="keywordtype">int</span> value;
     <span class="comment">// other fields</span>
     <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_node</a> node;
 };

 <span class="keyword">struct </span>object* obj = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="keywordtype">object</span>)); <span class="comment">// creates the object</span>

 obj-&gt;value = ...; <span class="comment">// initializes the object</span>

 <a class="code" href="tommyhashdyn_8h.html#adef3d60ad281f391ae1032f43f584dac" title="Inserts an element in the hashtable.">tommy_hashdyn_insert</a>(&amp;hashdyn, &amp;obj-&gt;node, obj, <a class="code" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71" title="Integer reversible hash function for 32 bits.">tommy_inthash_u32</a>(obj-&gt;value)); <span class="comment">// inserts the object</span>
</pre></div><p>To find and element in the hashtable you have to call <a class="el" href="tommyhashtbl_8h.html#a9a2455500c2ed927005ca7d222aa60ff" title="Searches an element in the hashtable.">tommy_hashtable_search()</a> providing a comparison function, its argument, and the hash of the key to search.</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> compare(<span class="keyword">const</span> <span class="keywordtype">void</span>* arg, <span class="keyword">const</span> <span class="keywordtype">void</span>* obj)
 {
     <span class="keywordflow">return</span> *(<span class="keyword">const</span> <span class="keywordtype">int</span>*)arg != ((<span class="keyword">const</span> <span class="keyword">struct</span> <span class="keywordtype">object</span>*)obj)-&gt;value;
 }

 <span class="keywordtype">int</span> value_to_find = 1;
 <span class="keyword">struct </span>object* obj = <a class="code" href="tommyhashdyn_8h.html#a713b5dc93110677d6230d601909fd667" title="Searches an element in the hashtable.">tommy_hashdyn_search</a>(&amp;hashdyn, compare, &amp;value_to_find, <a class="code" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71" title="Integer reversible hash function for 32 bits.">tommy_inthash_u32</a>(value_to_find));
 <span class="keywordflow">if</span> (!obj) {
     <span class="comment">// not found</span>
 } <span class="keywordflow">else</span> {
     <span class="comment">// found</span>
 }
</pre></div><p>To iterate over all the elements in the hashtable with the same key, you have to use <a class="el" href="tommyhashdyn_8h.html#a423346dea8ec61de351e84dc15a80468" title="Gets the bucket of the specified hash.">tommy_hashdyn_bucket()</a> and follow the <a class="el" href="structtommy__node__struct.html#a53338f3f5366866598ed9ac7e46e64a2" title="Next node.">tommy_node::next</a> pointer until NULL. You have also to check explicitely for the key, as the bucket may contains different keys.</p>
<div class="fragment"><pre class="fragment"> <span class="keywordtype">int</span> value_to_find = 1;
 <a class="code" href="structtommy__node__struct.html" title="Data structure node.">tommy_node</a>* i = <a class="code" href="tommyhashdyn_8h.html#a423346dea8ec61de351e84dc15a80468" title="Gets the bucket of the specified hash.">tommy_hashdyn_bucket</a>(&amp;hashdyn, <a class="code" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71" title="Integer reversible hash function for 32 bits.">tommy_inthash_u32</a>(value_to_find));
 <span class="keywordflow">while</span> (i) {
     <span class="keyword">struct </span>object* obj = i-&gt;<a class="code" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer to the object containing the node.">data</a>; <span class="comment">// gets the object pointer</span>

     <span class="keywordflow">if</span> (obj-&gt;value == value_to_find) {
         printf(<span class="stringliteral">&quot;%d\n&quot;</span>, obj-&gt;value); <span class="comment">// process the object</span>
     }

     i = i-&gt;<a class="code" href="structtommy__node__struct.html#a53338f3f5366866598ed9ac7e46e64a2" title="Next node.">next</a>; <span class="comment">// goes to the next element</span>
 }
</pre></div><p>To remove an element from the hashtable you have to call <a class="el" href="tommyhashdyn_8h.html#a01457fa26338c432cfe9ba93da4ae2f4" title="Searches and removes an element from the hashtable.">tommy_hashdyn_remove()</a> providing a comparison function, its argument, and the hash of the key to search and remove.</p>
<div class="fragment"><pre class="fragment"> <span class="keyword">struct </span>object* obj = <a class="code" href="tommyhashdyn_8h.html#a01457fa26338c432cfe9ba93da4ae2f4" title="Searches and removes an element from the hashtable.">tommy_hashdyn_remove</a>(&amp;hashdyn, compare, &amp;value_to_remove, <a class="code" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71" title="Integer reversible hash function for 32 bits.">tommy_inthash_u32</a>(value_to_remove));
 <span class="keywordflow">if</span> (obj) {
     free(obj); <span class="comment">// frees the object allocated memory</span>
 }
</pre></div><p>To destroy the hashtable you have to remove all the elements, and deinitialize the hashtable calling <a class="el" href="tommyhashdyn_8h.html#acc92e6ad011a22aa645cb35d24df27a2" title="Deinitializes the hashtable.">tommy_hashdyn_done()</a>.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="tommyhashdyn_8h.html#acc92e6ad011a22aa645cb35d24df27a2" title="Deinitializes the hashtable.">tommy_hashdyn_done</a>(&amp;hashdyn);
</pre></div><p>If you need to iterate over all the elements in the hashtable, you can use <a class="el" href="tommyhashdyn_8h.html#a010d0131e6e5ddd071dff7dadd181cfa" title="Calls the specified function for each element in the hashtable.">tommy_hashdyn_foreach()</a> or <a class="el" href="tommyhashdyn_8h.html#af1cf2aabf2d7acd3fd78f943384aac9c" title="Calls the specified function with an argument for each element in the hashtable.">tommy_hashdyn_foreach_arg()</a>. If you need a more precise control with a real iteration, you have to insert all the elements also in a <a class="el" href="tommylist_8h.html#a45d098412d5f0be21113b252caee491b" title="Double linked list type.">tommy_list</a>, and use the list to iterate. See the <a class="el" href="multiindex.html">Tommy Multi Indexing</a> example for more detail. </p>
</div><hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="aae681213ad96845453f1533ffa555481"></a><!-- doxytag: member="tommyhashdyn.h::tommy_hashdyn_node" ref="aae681213ad96845453f1533ffa555481" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structtommy__node__struct.html">tommy_node</a> <a class="el" href="structtommy__node__struct.html">tommy_hashdyn_node</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hashtable node. </p>
<p>This is the node that you have to include inside your objects. </p>

</div>
</div>
<a class="anchor" id="a00c8b944d273f38f9eef91417a1e8991"></a><!-- doxytag: member="tommyhashdyn.h::tommy_hashdyn" ref="a00c8b944d273f38f9eef91417a1e8991" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn_struct</a>  <a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Hashtable container type. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>Don't use internal fields directly, but access the container only using functions. </dd></dl>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a912bebbbb99e453f9c3230948f332d76"></a><!-- doxytag: member="tommyhashdyn.h::tommy_hashdyn_init" ref="a912bebbbb99e453f9c3230948f332d76" args="(tommy_hashdyn *hashdyn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_hashdyn_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *&#160;</td>
          <td class="paramname"><em>hashdyn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Initializes the hashtable. </p>

</div>
</div>
<a class="anchor" id="acc92e6ad011a22aa645cb35d24df27a2"></a><!-- doxytag: member="tommyhashdyn.h::tommy_hashdyn_done" ref="acc92e6ad011a22aa645cb35d24df27a2" args="(tommy_hashdyn *hashdyn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_hashdyn_done </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *&#160;</td>
          <td class="paramname"><em>hashdyn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Deinitializes the hashtable. </p>
<p>You can call this function with elements still contained, but such elements are not going to be freed by this call. </p>

</div>
</div>
<a class="anchor" id="adef3d60ad281f391ae1032f43f584dac"></a><!-- doxytag: member="tommyhashdyn.h::tommy_hashdyn_insert" ref="adef3d60ad281f391ae1032f43f584dac" args="(tommy_hashdyn *hashdyn, tommy_hashdyn_node *node, void *data, tommy_hash_t hash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_hashdyn_insert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *&#160;</td>
          <td class="paramname"><em>hashdyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_hashdyn_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Inserts an element in the hashtable. </p>

</div>
</div>
<a class="anchor" id="a01457fa26338c432cfe9ba93da4ae2f4"></a><!-- doxytag: member="tommyhashdyn.h::tommy_hashdyn_remove" ref="a01457fa26338c432cfe9ba93da4ae2f4" args="(tommy_hashdyn *hashdyn, tommy_search_func *cmp, const void *cmp_arg, tommy_hash_t hash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tommy_hashdyn_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *&#160;</td>
          <td class="paramname"><em>hashdyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#a9008971cd09a3f9c4f9da45cffb4627d">tommy_search_func</a> *&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cmp_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches and removes an element from the hashtable. </p>
<p>You have to provide a compare function and the hash of the element you want to remove. If the element is not found, 0 is returned. If more equal elements are present, the first one is removed. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cmp</td><td>Compare function called with cmp_arg as first argument and with the element to compare as a second one. The function should return 0 for equal elements, anything other for different elements. </td></tr>
    <tr><td class="paramname">cmp_arg</td><td>Compare argument passed as first argument of the compare function. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash of the element to find and remove. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The removed element, or 0 if not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a423346dea8ec61de351e84dc15a80468"></a><!-- doxytag: member="tommyhashdyn.h::tommy_hashdyn_bucket" ref="a423346dea8ec61de351e84dc15a80468" args="(tommy_hashdyn *hashdyn, tommy_hash_t hash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structtommy__node__struct.html">tommy_hashdyn_node</a>* tommy_hashdyn_bucket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *&#160;</td>
          <td class="paramname"><em>hashdyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the bucket of the specified hash. </p>
<p>The bucket is guaranteed to contain ALL the elements with the specified hash, but it can contain also others. You can access elements in the bucket following the ::next pointer until 0. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">hash</td><td>Hash of the element to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The head of the bucket, or 0 if empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a713b5dc93110677d6230d601909fd667"></a><!-- doxytag: member="tommyhashdyn.h::tommy_hashdyn_search" ref="a713b5dc93110677d6230d601909fd667" args="(tommy_hashdyn *hashdyn, tommy_search_func *cmp, const void *cmp_arg, tommy_hash_t hash)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tommy_hashdyn_search </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *&#160;</td>
          <td class="paramname"><em>hashdyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#a9008971cd09a3f9c4f9da45cffb4627d">tommy_search_func</a> *&#160;</td>
          <td class="paramname"><em>cmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>cmp_arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommyhash_8h.html#a4f9b62639e55aa933ebcf10f2125f862">tommy_hash_t</a>&#160;</td>
          <td class="paramname"><em>hash</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Searches an element in the hashtable. </p>
<p>You have to provide a compare function and the hash of the element you want to find. If more equal elements are present, the first one is returned. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">cmp</td><td>Compare function called with cmp_arg as first argument and with the element to compare as a second one. The function should return 0 for equal elements, anything other for different elements. </td></tr>
    <tr><td class="paramname">cmp_arg</td><td>Compare argument passed as first argument of the compare function. </td></tr>
    <tr><td class="paramname">hash</td><td>Hash of the element to find. </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The first element found, or 0 if none. </dd></dl>

</div>
</div>
<a class="anchor" id="a0d9f4ca17314d1a0e8b7072b5fda25cc"></a><!-- doxytag: member="tommyhashdyn.h::tommy_hashdyn_remove_existing" ref="a0d9f4ca17314d1a0e8b7072b5fda25cc" args="(tommy_hashdyn *hashdyn, tommy_hashdyn_node *node)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tommy_hashdyn_remove_existing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *&#160;</td>
          <td class="paramname"><em>hashdyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtommy__node__struct.html">tommy_hashdyn_node</a> *&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Removes an element from the hashtable. </p>
<p>You must already have the address of the element to remove. </p>
<dl class="return"><dt><b>Returns:</b></dt><dd>The <a class="el" href="structtommy__node__struct.html#a6210792ec52fa1efbfb44cf4557d9b6f" title="Pointer to the object containing the node.">tommy_node::data</a> field of the node removed. </dd></dl>

</div>
</div>
<a class="anchor" id="a010d0131e6e5ddd071dff7dadd181cfa"></a><!-- doxytag: member="tommyhashdyn.h::tommy_hashdyn_foreach" ref="a010d0131e6e5ddd071dff7dadd181cfa" args="(tommy_hashdyn *hashdyn, tommy_foreach_func *func)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_hashdyn_foreach </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *&#160;</td>
          <td class="paramname"><em>hashdyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#a8caf78c4fb7706a85093f99598d61b5d">tommy_foreach_func</a> *&#160;</td>
          <td class="paramname"><em>func</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls the specified function for each element in the hashtable. </p>
<p>You cannot add or remove elements from the inside of the callback, but can use it to deallocate them.</p>
<div class="fragment"><pre class="fragment"> <a class="code" href="structtommy__hashdyn__struct.html" title="Hashtable container type.">tommy_hashdyn</a> hashdyn;

 <span class="comment">// initializes the hashtable</span>
 <a class="code" href="tommyhashdyn_8h.html#a912bebbbb99e453f9c3230948f332d76" title="Initializes the hashtable.">tommy_hashdyn_init</a>(&amp;hashdyn);

 ...

 <span class="comment">// creates an object</span>
 <span class="keyword">struct </span>object* obj = malloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> <span class="keywordtype">object</span>));

 ...

 <span class="comment">// insert it in the hashtable</span>
 <a class="code" href="tommyhashdyn_8h.html#adef3d60ad281f391ae1032f43f584dac" title="Inserts an element in the hashtable.">tommy_hashdyn_insert</a>(&amp;hashdyn, &amp;obj-&gt;node, obj, <a class="code" href="tommyhash_8h.html#aea9c8438064a941d13e6f5462b5bff71" title="Integer reversible hash function for 32 bits.">tommy_inthash_u32</a>(obj-&gt;value));

 ...

 <span class="comment">// deallocates all the objects iterating the hashtable</span>
 <a class="code" href="tommyhashdyn_8h.html#a010d0131e6e5ddd071dff7dadd181cfa" title="Calls the specified function for each element in the hashtable.">tommy_hashdyn_foreach</a>(&amp;hashdyn, free);

 <span class="comment">// deallocates the hashtable</span>
 <a class="code" href="tommyhashdyn_8h.html#acc92e6ad011a22aa645cb35d24df27a2" title="Deinitializes the hashtable.">tommy_hashdyn_done</a>(&amp;hashdyn);
</pre></div> 
</div>
</div>
<a class="anchor" id="af1cf2aabf2d7acd3fd78f943384aac9c"></a><!-- doxytag: member="tommyhashdyn.h::tommy_hashdyn_foreach_arg" ref="af1cf2aabf2d7acd3fd78f943384aac9c" args="(tommy_hashdyn *hashdyn, tommy_foreach_arg_func *func, void *arg)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tommy_hashdyn_foreach_arg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *&#160;</td>
          <td class="paramname"><em>hashdyn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="tommytypes_8h.html#ae0aea577584dfbe750f078b3801d0ee6">tommy_foreach_arg_func</a> *&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calls the specified function with an argument for each element in the hashtable. </p>

</div>
</div>
<a class="anchor" id="a37b1f501d4d2ac31d262a2506f9f93a2"></a><!-- doxytag: member="tommyhashdyn.h::tommy_hashdyn_count" ref="a37b1f501d4d2ac31d262a2506f9f93a2" args="(tommy_hashdyn *hashdyn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tommytypes_8h.html#a802a296e9903e3bc098432b9bdad03ab">tommy_count_t</a> tommy_hashdyn_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *&#160;</td>
          <td class="paramname"><em>hashdyn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the number of elements. </p>

</div>
</div>
<a class="anchor" id="a3662ac977607f8192738aa9887d70d06"></a><!-- doxytag: member="tommyhashdyn.h::tommy_hashdyn_memory_usage" ref="a3662ac977607f8192738aa9887d70d06" args="(tommy_hashdyn *hashdyn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="tommytypes_8h.html#a32aad870b975610a257f9c2d14b0825e">tommy_size_t</a> tommy_hashdyn_memory_usage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtommy__hashdyn__struct.html">tommy_hashdyn</a> *&#160;</td>
          <td class="paramname"><em>hashdyn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Gets the size of allocated memory. </p>
<p>It includes the size of the <a class="el" href="tommyhashdyn_8h.html#aae681213ad96845453f1533ffa555481" title="Hashtable node.">tommy_hashdyn_node</a> of the stored elements. </p>

</div>
</div>
</div>
</body>
</html>
